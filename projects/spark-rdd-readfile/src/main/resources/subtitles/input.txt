1
00:00:00,286 --> 00:00:01,777
- [Instructor] Hello and welcome to this

2
00:00:01,777 --> 00:00:03,954
virtual programmer's course,

3
00:00:03,954 --> 00:00:06,692
where we will be exploring Docker.

4
00:00:06,692 --> 00:00:10,304
It's going to be Docker
with particular attention to

5
00:00:10,304 --> 00:00:13,577
how it might affect any
developer working on

6
00:00:13,577 --> 00:00:16,689
or around the Java virtual machine.

7
00:00:16,689 --> 00:00:19,893
This course is in two separate modules,

8
00:00:19,893 --> 00:00:22,051
and the first module
that you're watching now

9
00:00:22,051 --> 00:00:24,272
is going to be covering the basics,

10
00:00:24,272 --> 00:00:27,050
so if you've never worked
with Docker before,

11
00:00:27,050 --> 00:00:29,573
then this is the module for you.

12
00:00:29,573 --> 00:00:31,701
We're going to be starting from nothing

13
00:00:31,701 --> 00:00:34,023
and by the end of this module,

14
00:00:34,023 --> 00:00:38,503
you'll be able to manage
images, run containers,

15
00:00:38,503 --> 00:00:40,449
build your own containers

16
00:00:40,449 --> 00:00:43,668
and we'll be looking at how
a Spring Boot application

17
00:00:43,668 --> 00:00:45,868
might be Dockerized.

18
00:00:45,868 --> 00:00:48,223
And of course I'll be explaining

19
00:00:48,223 --> 00:00:50,408
why you would want to use Docker.

20
00:00:50,408 --> 00:00:52,242
So that will be the basics

21
00:00:52,242 --> 00:00:55,372
and that's really what
anyone working with Docker

22
00:00:55,372 --> 00:00:57,236
will need to know.

23
00:00:57,236 --> 00:00:59,513
But the second module on this course,

24
00:00:59,513 --> 00:01:01,311
which is going to follow on from this,

25
00:01:01,311 --> 00:01:02,868
will get more serious

26
00:01:02,868 --> 00:01:05,375
and we will be turning our attention to

27
00:01:05,375 --> 00:01:07,128
more of those topics that you need

28
00:01:07,128 --> 00:01:11,239
for production Docker use
in a Java environment.

29
00:01:11,239 --> 00:01:12,289
We're going to be deploying

30
00:01:12,289 --> 00:01:14,949
a full microservice architecture

31
00:01:14,949 --> 00:01:18,301
using the very powerful Docker Swarm.

32
00:01:18,301 --> 00:01:23,057
And we'll see how complex
multi-instance deployments

33
00:01:23,057 --> 00:01:25,806
can be relatively easily managed

34
00:01:25,806 --> 00:01:29,306
using something called Docker Stacks.

35
00:01:29,306 --> 00:01:31,077
If you've already studied our previous

36
00:01:31,077 --> 00:01:33,796
microservice deployment course,

37
00:01:33,796 --> 00:01:35,459
while it was a great course

38
00:01:35,459 --> 00:01:38,044
and there was a lot of really
good information on it,

39
00:01:38,044 --> 00:01:41,512
about how to use things
like the Netflix toolkit,

40
00:01:41,512 --> 00:01:42,845
Ansible, Jenkins

41
00:01:43,829 --> 00:01:47,034
and some quite advanced
work on Amazon web services,

42
00:01:47,034 --> 00:01:48,500
which was all great stuff,

43
00:01:48,500 --> 00:01:49,856
I'm really proud of that course

44
00:01:49,856 --> 00:01:53,341
but wow, it was a complicated course.

45
00:01:53,341 --> 00:01:56,258
And it wasn't really hard work

46
00:01:56,258 --> 00:01:57,767
for the viewer of the course

47
00:01:57,767 --> 00:01:59,134
because on that course

48
00:01:59,134 --> 00:02:01,612
we're constantly starting and stopping

49
00:02:01,612 --> 00:02:03,478
ec2 instances.

50
00:02:03,478 --> 00:02:05,186
Even though all of that was scripted,

51
00:02:05,186 --> 00:02:08,395
there was still a lot of
management work to do.

52
00:02:08,395 --> 00:02:10,295
And that's going to be
one of the many things

53
00:02:10,295 --> 00:02:12,981
that Docker can help you with.

54
00:02:12,981 --> 00:02:15,533
So the second module of this course

55
00:02:15,533 --> 00:02:19,616
is going to be looking at how
to use Docker to tame things.

56
00:02:19,616 --> 00:02:21,888
And the end goal of that second module is

57
00:02:21,888 --> 00:02:24,303
that with just one single command line,

58
00:02:24,303 --> 00:02:27,983
your entire microservice
architecture is deployed

59
00:02:27,983 --> 00:02:30,416
to a cluster of instances.

60
00:02:30,416 --> 00:02:33,527
And we'll let Docker worry
about the nasty details

61
00:02:33,527 --> 00:02:37,076
of which instance each
of your microservices

62
00:02:37,076 --> 00:02:38,550
are deployed to.

63
00:02:38,550 --> 00:02:41,258
It's really amazing and powerful.

64
00:02:41,258 --> 00:02:42,786
But I'm getting ahead of myself, really,

65
00:02:42,786 --> 00:02:44,706
I'm just previewing there
what's going to come

66
00:02:44,706 --> 00:02:46,877
in the second module.

67
00:02:46,877 --> 00:02:48,931
This course is the first module,

68
00:02:48,931 --> 00:02:50,522
and we're doing the basics,

69
00:02:50,522 --> 00:02:52,685
but I hope it will still be fun.

70
00:02:52,685 --> 00:02:53,899
The first job of course is

71
00:02:53,899 --> 00:02:56,759
we need to get a good
understanding of what Docker is

72
00:02:56,759 --> 00:02:58,250
and what it's all about.

73
00:02:58,250 --> 00:03:01,359
So, join me in the next
chapter and we'll look at

74
00:03:01,359 --> 00:03:02,609
what is Docker.

1
00:00:00,191 --> 00:00:01,142
- [Instructor] Welcome back.

2
00:00:01,142 --> 00:00:02,785
This is chapter two,
where we're going to be

3
00:00:02,785 --> 00:00:05,007
having a look at what Docker is,

4
00:00:05,007 --> 00:00:07,577
and what it can do for you.

5
00:00:07,577 --> 00:00:10,001
Now, I reckon that every single developer

6
00:00:10,001 --> 00:00:13,813
has found themselves in
the following position.

7
00:00:13,813 --> 00:00:16,065
You need, for some reason, to start up

8
00:00:16,065 --> 00:00:20,168
some development software
on a fresh environment.

9
00:00:20,168 --> 00:00:22,840
Perhaps it's a project
that you've been building

10
00:00:22,840 --> 00:00:25,318
on a different computer,
and, for whatever reason,

11
00:00:25,318 --> 00:00:28,186
you're moving it to a new computer.

12
00:00:28,186 --> 00:00:32,026
Or perhaps you've been
given, maybe, a Java WAR file

13
00:00:32,026 --> 00:00:35,252
or a JAR file from another developer,

14
00:00:35,252 --> 00:00:38,326
and you've got to get
it running for yourself

15
00:00:38,326 --> 00:00:41,079
on your computer for the first time.

16
00:00:41,079 --> 00:00:45,693
And you know what kind of
a nightmare that can be.

17
00:00:45,693 --> 00:00:47,085
You try to run the project,

18
00:00:47,085 --> 00:00:50,598
but you discover that it
won't run until you have done

19
00:00:50,598 --> 00:00:54,515
some kind of configuration
of your environment.

20
00:00:55,957 --> 00:00:59,761
So I've been given a WAR
file from another developer,

21
00:00:59,761 --> 00:01:00,804
and they've assured me

22
00:01:00,804 --> 00:01:03,674
that it works absolutely fine for them.

23
00:01:03,674 --> 00:01:05,072
And they want me to run it,

24
00:01:05,072 --> 00:01:07,729
maybe to do some QA or some testing

25
00:01:07,729 --> 00:01:09,685
or something like that.

26
00:01:09,685 --> 00:01:12,567
And they tell me that
I can run this easily

27
00:01:12,567 --> 00:01:15,182
using the regular Java command line,

28
00:01:15,182 --> 00:01:19,859
java-jar, followed by the
name of that WAR file,

29
00:01:19,859 --> 00:01:22,692
and, apparently, this will just run.

30
00:01:22,692 --> 00:01:26,859
Yeah, this looks like a
regular Spring application.

31
00:01:27,725 --> 00:01:30,531
Appears to be Spring Boot.

32
00:01:30,531 --> 00:01:33,292
And, well, the application
has failed to start

33
00:01:33,292 --> 00:01:36,795
for some rather obscure looking reason.

34
00:01:36,795 --> 00:01:38,515
So I get in touch with the developer,

35
00:01:38,515 --> 00:01:43,261
and apparently it runs
absolutely fine on their machine.

36
00:01:43,261 --> 00:01:46,000
Well, after tearing my
hair out for some hours,

37
00:01:46,000 --> 00:01:49,929
I discover that I needed to
set an environment variable

38
00:01:49,929 --> 00:01:51,259
to make this run.

39
00:01:51,259 --> 00:01:54,887
Now, obviously the other developer
had that environment set,

40
00:01:54,887 --> 00:01:58,816
and they had simply forgotten
that they had done that.

41
00:01:58,816 --> 00:02:01,965
So I can do that on the Java command line.

42
00:02:01,965 --> 00:02:06,132
It happens to be
spring.profiles.active=development.

43
00:02:11,256 --> 00:02:13,382
That appears to have fixed that problem.

44
00:02:13,382 --> 00:02:14,580
I'm sure you've been there.

45
00:02:14,580 --> 00:02:16,760
The application needs Tomcat to run,

46
00:02:16,760 --> 00:02:18,316
but Tomcat won't start

47
00:02:18,316 --> 00:02:21,972
because it's not correctly
configured for your machine.

48
00:02:21,972 --> 00:02:24,672
Or you realise that you haven't installed

49
00:02:24,672 --> 00:02:26,560
the correct Java development kit,

50
00:02:26,560 --> 00:02:29,398
or you've got the wrong
version of the JDK.

51
00:02:29,398 --> 00:02:33,162
The application is running on Java 7,

52
00:02:33,162 --> 00:02:36,329
and yet we've installed Java 1.8.5_12,

53
00:02:37,563 --> 00:02:40,187
and the two versions are a mismatch.

54
00:02:40,187 --> 00:02:43,277
And then we've got the
application up and running,

55
00:02:43,277 --> 00:02:46,033
but the application depends on MySQL

56
00:02:46,033 --> 00:02:47,954
being installed on this machine.

57
00:02:47,954 --> 00:02:50,568
And so you have to instal MySQL,

58
00:02:50,568 --> 00:02:52,424
and then you've got to configure

59
00:02:52,424 --> 00:02:53,976
the security in the ports.

60
00:02:53,976 --> 00:02:56,240
And I'm going on and on and on,

61
00:02:56,240 --> 00:02:58,727
and I might lose an
entire day of development

62
00:02:58,727 --> 00:03:01,965
just messing about,
trying to get my computer

63
00:03:01,965 --> 00:03:04,528
in the same state that it was

64
00:03:04,528 --> 00:03:07,030
on the original development machine.

65
00:03:07,030 --> 00:03:09,075
So I'm sure you've been in that situation.

66
00:03:09,075 --> 00:03:13,757
If you haven't, then I promise
you, you will one day soon.

67
00:03:13,757 --> 00:03:15,936
It's a horrible situation.

68
00:03:15,936 --> 00:03:18,327
And that's where Docker comes in.

69
00:03:18,327 --> 00:03:20,348
Docker changes the way that you think

70
00:03:20,348 --> 00:03:23,646
about delivering and deploying software.

71
00:03:23,646 --> 00:03:26,051
Traditionally, as Java developers,

72
00:03:26,051 --> 00:03:30,055
we think of the JAR file or the WAR file,

73
00:03:30,055 --> 00:03:31,172
same thing, really,

74
00:03:31,172 --> 00:03:33,513
as being the final deliverable,

75
00:03:33,513 --> 00:03:36,468
the end results of our build process.

76
00:03:36,468 --> 00:03:39,653
And that's typically the
item that we hand over

77
00:03:39,653 --> 00:03:42,034
to whoever is going to be responsible

78
00:03:42,034 --> 00:03:45,723
for deploying the system into production.

79
00:03:45,723 --> 00:03:48,492
In Docker, we change focus.

80
00:03:48,492 --> 00:03:51,197
Instead of deploying a JAR file,

81
00:03:51,197 --> 00:03:54,821
which we would run as
an isolated application,

82
00:03:54,821 --> 00:03:56,988
we instead run containers.

83
00:03:59,543 --> 00:04:02,424
And you can think of a
container as being a complete,

84
00:04:02,424 --> 00:04:05,841
self-contained, and complete environment.

85
00:04:08,133 --> 00:04:11,350
Inside the Docker
container can be anything,

86
00:04:11,350 --> 00:04:15,367
but, in our example, we
would have a Docker container

87
00:04:15,367 --> 00:04:19,933
including a fully configured
Java virtual machine,

88
00:04:19,933 --> 00:04:22,577
a configured Tomcat, for example,

89
00:04:22,577 --> 00:04:25,943
and maybe some kind of
front-end proxy service,

90
00:04:25,943 --> 00:04:27,943
such as NGINX or Apache.

91
00:04:29,249 --> 00:04:33,416
And we would also have our WAR
file inside that container.

92
00:04:35,064 --> 00:04:37,897
And the container can also contain

93
00:04:39,405 --> 00:04:41,944
all of the necessary environment variables

94
00:04:41,944 --> 00:04:46,765
and configurations that
that container needs to run.

95
00:04:46,765 --> 00:04:50,299
So this container is a
totally self-contained,

96
00:04:50,299 --> 00:04:52,632
self-sufficient environment.

97
00:04:54,691 --> 00:04:56,412
You're going to discover, on this course,

98
00:04:56,412 --> 00:04:58,243
that setting up one of these containers

99
00:04:58,243 --> 00:05:00,634
is really quite simple.

100
00:05:00,634 --> 00:05:03,613
Well, you know, there is going
to be some work involved,

101
00:05:03,613 --> 00:05:05,612
or you wouldn't need a
training course on this,

102
00:05:05,612 --> 00:05:09,779
but it's quite possibly
simpler than you might imagine.

103
00:05:11,034 --> 00:05:13,451
To define a Docker container,

104
00:05:14,586 --> 00:05:18,290
you need to, first of all, build an image.

105
00:05:18,290 --> 00:05:21,302
And an image is a really
important concept in Docker.

106
00:05:21,302 --> 00:05:24,635
An image is a definition of a container.

107
00:05:26,310 --> 00:05:28,973
So, where previously a developer

108
00:05:28,973 --> 00:05:32,761
would have built a JAR
file, or a WAR file,

109
00:05:32,761 --> 00:05:36,717
here in a development
environment, such as Eclipse,

110
00:05:36,717 --> 00:05:40,346
when you're working in
a Docker style instead,

111
00:05:40,346 --> 00:05:43,763
the developer is going to build an image.

112
00:05:46,005 --> 00:05:48,542
And that image, as described previously,

113
00:05:48,542 --> 00:05:50,678
is going to contain the definition

114
00:05:50,678 --> 00:05:55,203
of a complete environment,
environment variables,

115
00:05:55,203 --> 00:06:00,065
the WAR file or JAR file, any
supporting software needed,

116
00:06:00,065 --> 00:06:03,398
such as the Java JDK, Tomcat, and so on.

117
00:06:05,686 --> 00:06:08,387
On the second module
in this Docker series,

118
00:06:08,387 --> 00:06:10,598
we're going to find out that you can use

119
00:06:10,598 --> 00:06:14,499
standard Java tools to build these images.

120
00:06:14,499 --> 00:06:17,934
We can very easily use Maven, for example,

121
00:06:17,934 --> 00:06:20,710
to create a Docker image.

122
00:06:20,710 --> 00:06:22,511
So it's actually this image

123
00:06:22,511 --> 00:06:26,024
that is going to become
the unit of deployment

124
00:06:26,024 --> 00:06:29,300
when we're working in a Docker style.

125
00:06:29,300 --> 00:06:32,632
So we hand that image
across to somebody else.

126
00:06:32,632 --> 00:06:34,439
Perhaps it's somebody who is going to be

127
00:06:34,439 --> 00:06:38,554
deploying this application
to a live, running server.

128
00:06:38,554 --> 00:06:41,599
So we give them the Docker image.

129
00:06:41,599 --> 00:06:44,182
And we can run a Docker image.

130
00:06:45,331 --> 00:06:47,570
And it's when you run an image

131
00:06:47,570 --> 00:06:49,903
that it becomes a container.

132
00:06:51,830 --> 00:06:53,412
So there's a key point, then.

133
00:06:53,412 --> 00:06:56,662
A container is an instance of an image.

134
00:06:57,858 --> 00:07:00,322
And you instantiate one of these images

135
00:07:00,322 --> 00:07:02,072
by simply running it.

136
00:07:03,964 --> 00:07:05,461
It's quite the common confusion,

137
00:07:05,461 --> 00:07:09,548
the difference between an
image and the container.

138
00:07:09,548 --> 00:07:11,979
The image is the entity that we build,

139
00:07:11,979 --> 00:07:13,461
and when we run that image,

140
00:07:13,461 --> 00:07:17,266
it will become a container at runtime.

141
00:07:17,266 --> 00:07:19,814
So that means you could
take a single image

142
00:07:19,814 --> 00:07:22,814
and you could run it multiple times.

143
00:07:23,741 --> 00:07:25,151
In which case you would end up

144
00:07:25,151 --> 00:07:29,702
with multiple containers
all running the same image.

145
00:07:29,702 --> 00:07:32,239
So then the important
thing about this, then,

146
00:07:32,239 --> 00:07:34,972
is that, instead of
handing over a WAR file

147
00:07:34,972 --> 00:07:39,139
to a deployer, we're going
to hand over a Docker image.

148
00:07:40,177 --> 00:07:42,146
And, because the Docker image contains

149
00:07:42,146 --> 00:07:46,594
a complete environment that
needs no further configuration,

150
00:07:46,594 --> 00:07:50,761
it's much easier to deploy
and to get it up and running.

151
00:07:51,957 --> 00:07:53,582
I'm sure that many of
you will be thinking,

152
00:07:53,582 --> 00:07:56,417
"What's the difference between a container

153
00:07:56,417 --> 00:07:58,417
"and a virtual machine?"

154
00:07:59,909 --> 00:08:02,662
Well, the difference, and
it is a big difference,

155
00:08:02,662 --> 00:08:06,829
is that container does not
contain a full operating system.

156
00:08:07,666 --> 00:08:11,828
And, therefore, it's much
lighter and much more efficient

157
00:08:11,828 --> 00:08:14,477
than running virtual machines.

158
00:08:14,477 --> 00:08:17,160
Let's say, for example,
that you're running

159
00:08:17,160 --> 00:08:19,993
on a Linux-based operating system.

160
00:08:21,303 --> 00:08:25,683
Now, you can develop in
Docker on Windows and Mac,

161
00:08:25,683 --> 00:08:27,615
and, in fact, I'm recording this course

162
00:08:27,615 --> 00:08:30,104
on a Windows-based operating system.

163
00:08:30,104 --> 00:08:32,984
But for reasons that will
become obvious shortly,

164
00:08:32,984 --> 00:08:34,890
it's easier to think about Linux

165
00:08:34,890 --> 00:08:38,347
when we think about the
architecture of Docker.

166
00:08:38,347 --> 00:08:42,095
So I'm simplifying here, but the main part

167
00:08:42,095 --> 00:08:44,323
of the Linux operating system,

168
00:08:44,323 --> 00:08:46,364
well, any operating system, really,

169
00:08:46,364 --> 00:08:48,618
the main part of the operating system

170
00:08:48,618 --> 00:08:52,721
which handles low-level services
such as memory management,

171
00:08:52,721 --> 00:08:56,721
device drivers, and so
on, is called the kernel.

172
00:08:58,325 --> 00:09:01,196
Now, when we launch a container,

173
00:09:01,196 --> 00:09:03,779
the container is running on top

174
00:09:05,843 --> 00:09:09,093
of your host operating system's kernel.

175
00:09:10,050 --> 00:09:12,784
And, actually, if you want
the real low-level detail,

176
00:09:12,784 --> 00:09:16,117
the container is actually just a process

177
00:09:17,665 --> 00:09:19,822
running on your kernel.

178
00:09:19,822 --> 00:09:22,193
So, although a container might feel

179
00:09:22,193 --> 00:09:24,958
like a full virtual machine,

180
00:09:24,958 --> 00:09:28,141
it's not a full virtual machine

181
00:09:28,141 --> 00:09:32,308
because it doesn't contain
it's own operating system.

182
00:09:33,798 --> 00:09:36,844
Now there is quite the
common confusion here.

183
00:09:36,844 --> 00:09:39,178
As you can see from my caption here,

184
00:09:39,178 --> 00:09:42,087
I have included, in my container,

185
00:09:42,087 --> 00:09:44,587
a graphic representing Ubuntu.

186
00:09:45,430 --> 00:09:49,416
And that's because each
container does contain

187
00:09:49,416 --> 00:09:53,583
it's own distribution, it's
own Linux distribution.

188
00:09:54,546 --> 00:09:58,490
So I might have one
container here running Ubuntu

189
00:09:58,490 --> 00:10:00,823
and a stack of applications.

190
00:10:01,657 --> 00:10:05,700
I might have another container
running at the same time

191
00:10:05,700 --> 00:10:08,522
which has it's own distribution.

192
00:10:08,522 --> 00:10:12,441
In this case, this is
the CentOS distribution.

193
00:10:12,441 --> 00:10:14,447
And, of course, I could go on.

194
00:10:14,447 --> 00:10:18,188
Here I have a third
container running MySQL,

195
00:10:18,188 --> 00:10:19,932
which happens to be bundled

196
00:10:19,932 --> 00:10:22,932
with the Red Hat Linux distribution.

197
00:10:23,930 --> 00:10:26,261
Now, the common source
of confusion here is

198
00:10:26,261 --> 00:10:27,700
that people look at this and think,

199
00:10:27,700 --> 00:10:28,616
"Well, hang on.

200
00:10:28,616 --> 00:10:32,783
"You're including operating
systems inside your containers."

201
00:10:34,109 --> 00:10:35,827
It's important to understand

202
00:10:35,827 --> 00:10:38,910
that these are not operating systems.

203
00:10:40,638 --> 00:10:45,375
Ubuntu, CentOS, and Red
Hat Linux are just sets

204
00:10:45,375 --> 00:10:47,542
of applications and tools.

205
00:10:49,307 --> 00:10:53,709
When you get hold of, let's
say, an Ubuntu installation DVD,

206
00:10:53,709 --> 00:10:58,019
what you have on that DVD
are, broadly, two things.

207
00:10:58,019 --> 00:11:01,436
You have on there a suite of applications

208
00:11:03,065 --> 00:11:05,358
that the Ubuntu developers have decided

209
00:11:05,358 --> 00:11:09,271
is a good collection
of tools and utilities,

210
00:11:09,271 --> 00:11:12,770
and it also includes a
copy of the Linux kernel.

211
00:11:12,770 --> 00:11:16,036
Now, when you see that the
container contains Ubuntu,

212
00:11:16,036 --> 00:11:17,204
all we're saying there is

213
00:11:17,204 --> 00:11:21,217
that the container contains
the Ubuntu collection

214
00:11:21,217 --> 00:11:23,937
of tools and utilities.

215
00:11:23,937 --> 00:11:26,017
So it's going to be things like,

216
00:11:26,017 --> 00:11:30,014
I don't know, the cat
command, or the text editor,

217
00:11:30,014 --> 00:11:33,260
or the package manager that you can use

218
00:11:33,260 --> 00:11:34,842
for installing software,

219
00:11:34,842 --> 00:11:38,081
are all parts of the Ubuntu distribution.

220
00:11:38,081 --> 00:11:39,911
And there'll be a slightly
different set of tools

221
00:11:39,911 --> 00:11:44,350
in the CentOS distribution and
in the Red Hat distribution.

222
00:11:44,350 --> 00:11:48,517
But none of these containers
contain the Linux kernel.

223
00:11:50,463 --> 00:11:52,394
And it's the Linux kernel that,

224
00:11:52,394 --> 00:11:54,513
I am being very simplistic here,

225
00:11:54,513 --> 00:11:56,061
but it's the Linux kernel

226
00:11:56,061 --> 00:11:59,343
that is the big, heavyweight component.

227
00:11:59,343 --> 00:12:02,942
So, in other words, you containers share

228
00:12:02,942 --> 00:12:04,775
the same Linux kernel.

229
00:12:06,163 --> 00:12:09,764
So that's the reason
why running containers

230
00:12:09,764 --> 00:12:13,720
is not the same as
running virtual machines.

231
00:12:13,720 --> 00:12:15,976
When you spin up a virtual machine,

232
00:12:15,976 --> 00:12:18,393
it will have it's own kernel.

233
00:12:19,342 --> 00:12:22,370
And for that reason,
virtual machines are heavy,

234
00:12:22,370 --> 00:12:25,726
and you will struggle to
run many virtual machines

235
00:12:25,726 --> 00:12:28,510
on a typical development machine.

236
00:12:28,510 --> 00:12:30,511
Containers are much lighter,

237
00:12:30,511 --> 00:12:33,884
and you can run many more of them.

238
00:12:33,884 --> 00:12:35,691
So, at a technical level,

239
00:12:35,691 --> 00:12:38,500
a container is not a virtual machine.

240
00:12:38,500 --> 00:12:40,465
But I'll say this quite quietly,

241
00:12:40,465 --> 00:12:43,526
because it would offend
a lot of Docker experts.

242
00:12:43,526 --> 00:12:46,511
But, you know what, the
container kind of feels

243
00:12:46,511 --> 00:12:48,810
a bit like a virtual machine,

244
00:12:48,810 --> 00:12:51,420
in the sense that it
feels, to us as developers,

245
00:12:51,420 --> 00:12:54,916
that it's fully self-contained
and stands on its own.

246
00:12:54,916 --> 00:12:57,346
Actually, it isn't
completely self-contained,

247
00:12:57,346 --> 00:12:59,601
because all of your containers are talking

248
00:12:59,601 --> 00:13:01,684
to your one Linux kernel.

249
00:13:02,761 --> 00:13:04,255
In the next chapter on installation,

250
00:13:04,255 --> 00:13:06,695
I'll talk about how this picture differs

251
00:13:06,695 --> 00:13:08,319
if you're running on a Windows

252
00:13:08,319 --> 00:13:11,654
or Macintosh development machine.

253
00:13:11,654 --> 00:13:14,554
So this means, then, instead
of the horrible scenario

254
00:13:14,554 --> 00:13:17,155
that I describe at the
start of this chapter,

255
00:13:17,155 --> 00:13:19,956
if we make it so that,
instead of building a WAR file

256
00:13:19,956 --> 00:13:22,535
and handing that over for deployment,

257
00:13:22,535 --> 00:13:25,202
we build a Docker image instead,

258
00:13:27,174 --> 00:13:28,585
then it's easy for the deployer.

259
00:13:28,585 --> 00:13:32,937
They just run the container
on their target hardware,

260
00:13:32,937 --> 00:13:36,098
assuming they have Docker
installed, of course.

261
00:13:36,098 --> 00:13:37,687
And because the container contains

262
00:13:37,687 --> 00:13:41,631
all of the necessary
configuration and environment,

263
00:13:41,631 --> 00:13:43,048
it will just run.

264
00:13:43,918 --> 00:13:47,805
By the way, I should mention
that these containers

265
00:13:47,805 --> 00:13:49,756
are actually nothing new,

266
00:13:49,756 --> 00:13:52,891
and they weren't invented by Docker.

267
00:13:52,891 --> 00:13:56,088
In fact, containers have been a feature

268
00:13:56,088 --> 00:13:59,255
of the Linux kernel since around 2008.

269
00:14:02,060 --> 00:14:05,727
Now, I'm on the Wikipedia
page here for LXC,

270
00:14:06,576 --> 00:14:09,542
which stands for Linux containers,

271
00:14:09,542 --> 00:14:12,373
and this is described
on the Wikipedia page

272
00:14:12,373 --> 00:14:14,831
as an operating system level,

273
00:14:14,831 --> 00:14:16,844
that means kernel level,

274
00:14:16,844 --> 00:14:19,341
virtualization method for running

275
00:14:19,341 --> 00:14:21,856
exactly what I have just described,

276
00:14:21,856 --> 00:14:25,606
isolated containers on
a single Linux kernel.

277
00:14:26,808 --> 00:14:30,391
Now this LXC was
introduced in around 2008,

278
00:14:33,045 --> 00:14:36,545
and yet Docker has been around since 2013.

279
00:14:38,577 --> 00:14:40,695
So, really, what we have here

280
00:14:40,695 --> 00:14:43,086
is a built-in feature of Linux,

281
00:14:43,086 --> 00:14:45,750
and Docker, you can think
of as being a kind of

282
00:14:45,750 --> 00:14:49,583
an elegant user interface
or management system

283
00:14:51,142 --> 00:14:54,165
that's allowing you to
get to these containers

284
00:14:54,165 --> 00:14:57,086
that your Linux kernel already supports.

285
00:14:57,086 --> 00:14:58,868
I won't go into anymore detail on this,

286
00:14:58,868 --> 00:15:03,035
but, actually, LXC isn't used
now by default by Docker.

287
00:15:03,937 --> 00:15:06,618
They use a different scheme and strategy,

288
00:15:06,618 --> 00:15:07,576
and I'll invite you to check out

289
00:15:07,576 --> 00:15:09,734
the Docker reference
manual if you really want

290
00:15:09,734 --> 00:15:11,638
the low-level details of that.

291
00:15:11,638 --> 00:15:12,896
I just wanted to stress

292
00:15:12,896 --> 00:15:16,135
that Docker didn't'
really invent containers.

293
00:15:16,135 --> 00:15:19,365
It's kind of been there
for a long time already.

294
00:15:19,365 --> 00:15:21,997
Now, I've been going on and on about Linux

295
00:15:21,997 --> 00:15:25,648
on this chapter, and I'm
sure that many of you

296
00:15:25,648 --> 00:15:29,756
are using either Windows
computers or Macintosh computers.

297
00:15:29,756 --> 00:15:30,847
So the big question is,

298
00:15:30,847 --> 00:15:33,884
are you going to be able to use Docker?

299
00:15:33,884 --> 00:15:35,277
And the answer is yes.

300
00:15:35,277 --> 00:15:39,145
But I think I'll defer that
until the next chapter,

301
00:15:39,145 --> 00:15:40,902
because in the next
chapter we're going to be

302
00:15:40,902 --> 00:15:43,326
getting Docker installed and running

303
00:15:43,326 --> 00:15:45,248
on your development computer.

304
00:15:45,248 --> 00:15:47,513
Now, I think this is the most complex part

305
00:15:47,513 --> 00:15:49,177
of learning Docker, to be honest.

306
00:15:49,177 --> 00:15:51,883
So brace yourself for the next chapter.

307
00:15:51,883 --> 00:15:53,339
Once we've got over that,

308
00:15:53,339 --> 00:15:57,506
I hope you'll find working
with Docker an absolute joy.

1
00:00:00,871 --> 00:00:03,161
- [Instructor] Welcome
back to chapter three.

2
00:00:03,161 --> 00:00:07,454
In this chapter, you're
going to instal Docker,

3
00:00:07,454 --> 00:00:09,558
and I have to admit, this
is really the chapter

4
00:00:09,558 --> 00:00:10,939
I've been dreading recording,

5
00:00:10,939 --> 00:00:14,611
because I think by far the
hardest thing in getting started

6
00:00:14,611 --> 00:00:18,390
with Docker is actually
getting it installed.

7
00:00:18,390 --> 00:00:21,523
The reason for that really is that Docker,

8
00:00:21,523 --> 00:00:22,356
if you think about it,

9
00:00:22,356 --> 00:00:24,596
is quite a low level piece of software

10
00:00:24,596 --> 00:00:28,513
in that it's working with
your kernel directly,

11
00:00:29,716 --> 00:00:33,341
and of course there are
so many different types

12
00:00:33,341 --> 00:00:36,466
of Operating Systems out there that really

13
00:00:36,466 --> 00:00:38,888
on this training course, I can't show you

14
00:00:38,888 --> 00:00:41,944
every single Operating System.

15
00:00:41,944 --> 00:00:44,902
So although usually on a
Virtual Pair Programmers course

16
00:00:44,902 --> 00:00:49,044
I would step you through
every step of installing,

17
00:00:49,044 --> 00:00:51,198
I'm not going to do that on this course.

18
00:00:51,198 --> 00:00:54,661
I'm going to give you
a few general pointers

19
00:00:54,661 --> 00:00:59,189
and pieces of guidance so
that you can do this yourself,

20
00:00:59,189 --> 00:01:02,043
hopefully without running into problems.

21
00:01:02,043 --> 00:01:05,073
If you do run into problems,
then please do contact us

22
00:01:05,073 --> 00:01:09,444
through the contact page at
virtualpairprogrammers.com.

23
00:01:09,444 --> 00:01:13,611
Our starting point is the
Docker website at Docker.com.

24
00:01:14,826 --> 00:01:17,993
And there's a link here to get Docker,

25
00:01:19,363 --> 00:01:23,124
and so we have links
here to Mac and Windows.

26
00:01:23,124 --> 00:01:24,901
If you're running on a Cloud Provider,

27
00:01:24,901 --> 00:01:29,068
AWS or Azure, and there's a
list of links to different,

28
00:01:29,966 --> 00:01:31,562
well, there's Windows Server there,

29
00:01:31,562 --> 00:01:33,677
but there's also different flavours

30
00:01:33,677 --> 00:01:35,927
of Linux Operating Systems.

31
00:01:37,013 --> 00:01:40,129
Now we will be doing some work
in the Cloud on this course,

32
00:01:40,129 --> 00:01:43,520
so at the appropriate point in
this course, I will show you

33
00:01:43,520 --> 00:01:46,722
how to work on, I'm going to use AWS,

34
00:01:46,722 --> 00:01:49,743
just as an example of a Cloud Provider,

35
00:01:49,743 --> 00:01:52,180
but everything we do on
the course will be equally

36
00:01:52,180 --> 00:01:55,992
appropriate to Microsoft Azure as well.

37
00:01:55,992 --> 00:01:59,705
Microsoft Azure really is
coming on in leaps and bounds,

38
00:01:59,705 --> 00:02:01,796
catching up AWS.

39
00:02:01,796 --> 00:02:04,877
For your local development,
you're going to, I suppose,

40
00:02:04,877 --> 00:02:08,416
either be on Mac, Windows,
or some kind of Linux

41
00:02:08,416 --> 00:02:10,753
so that's slightly odd
that they've put all

42
00:02:10,753 --> 00:02:13,933
the Linux underservers,
because you can perfectly well

43
00:02:13,933 --> 00:02:18,805
use Linux on a desktop
development machine as well.

44
00:02:18,805 --> 00:02:22,972
In fact, I develop on my laptop
on the Mint Operating System

45
00:02:24,352 --> 00:02:27,123
which is a flavour of Debian Linux.

46
00:02:27,123 --> 00:02:28,581
So that's really our starting point,

47
00:02:28,581 --> 00:02:31,019
and I recommend that you go there yourself

48
00:02:31,019 --> 00:02:34,943
and follow a link to your
particular Operating System.

49
00:02:34,943 --> 00:02:37,424
On this video, I'll go
through the traps and pitfalls

50
00:02:37,424 --> 00:02:39,926
for each of the Operating Systems.

51
00:02:39,926 --> 00:02:42,696
I'm going to start by talking about Linux.

52
00:02:42,696 --> 00:02:46,706
Now, even if you're not
developing on Linux,

53
00:02:46,706 --> 00:02:49,511
then I recommend you do
watch this part of the video

54
00:02:49,511 --> 00:02:52,866
because you might well be
deploying to Linux at some point

55
00:02:52,866 --> 00:02:56,191
and it's worthwhile knowing
how to instal for Linux.

56
00:02:56,191 --> 00:02:57,505
So depending on your distribution,

57
00:02:57,505 --> 00:02:58,982
it's quite possible that you might

58
00:02:58,982 --> 00:03:01,289
already have Docker installed,

59
00:03:01,289 --> 00:03:02,680
so the first thing I would recommend,

60
00:03:02,680 --> 00:03:05,460
if you're on Linux, is
to fire up the terminal

61
00:03:05,460 --> 00:03:07,828
and just type the command Docker.

62
00:03:07,828 --> 00:03:10,301
I'm running here on Amazon Linux,

63
00:03:10,301 --> 00:03:13,329
and as you can see, for
me, it's not installed.

64
00:03:13,329 --> 00:03:15,653
So, if that's the case, then
the natural thing to try

65
00:03:15,653 --> 00:03:19,526
is to try your distribution's
package management system,

66
00:03:19,526 --> 00:03:21,831
which on Amazon is yum.

67
00:03:21,831 --> 00:03:25,414
So I'm going to do sudo yum instal Docker,

68
00:03:26,818 --> 00:03:27,804
and that's good.

69
00:03:27,804 --> 00:03:29,375
That package is available,

70
00:03:29,375 --> 00:03:32,358
so I will go ahead and instal.

71
00:03:32,358 --> 00:03:33,781
If you're not on Amazon Linux,

72
00:03:33,781 --> 00:03:35,181
you'll probably have a different

73
00:03:35,181 --> 00:03:37,341
package installation system.

74
00:03:37,341 --> 00:03:40,526
I'll assume you're familiar
with the details of using that.

75
00:03:40,526 --> 00:03:41,737
Once that's done, you should have

76
00:03:41,737 --> 00:03:43,965
the Docker command available,

77
00:03:43,965 --> 00:03:45,900
and you should get a help page,

78
00:03:45,900 --> 00:03:48,435
a self sufficient runtime for containers,

79
00:03:48,435 --> 00:03:51,907
and a bewildering, long list of commands.

80
00:03:51,907 --> 00:03:54,613
To test if your Docker
installation is running,

81
00:03:54,613 --> 00:03:58,113
what we need to do is Docker container run

82
00:03:59,893 --> 00:04:01,893
followed by hello-world.

83
00:04:03,753 --> 00:04:05,264
We don't need to worry in detail about

84
00:04:05,264 --> 00:04:07,615
what all this means right now.

85
00:04:07,615 --> 00:04:10,339
All will be explained later in the course.

86
00:04:10,339 --> 00:04:14,616
I think you'll probably find
when you run this command that,

87
00:04:14,616 --> 00:04:17,702
yeah, you will get an error
saying it can't connect

88
00:04:17,702 --> 00:04:20,198
to the Docker daemon.

89
00:04:20,198 --> 00:04:21,960
Now the first thing it's
asking you to check is,

90
00:04:21,960 --> 00:04:24,572
is the Docker daemon running?

91
00:04:24,572 --> 00:04:27,659
Docker runs the daemon
process in the background,

92
00:04:27,659 --> 00:04:31,233
and again, this will vary
depending on your flavour of Linux

93
00:04:31,233 --> 00:04:33,844
and I will assume you know
how to do this on your Linux

94
00:04:33,844 --> 00:04:38,011
but on Amazon it will be
sudo service Docker start

95
00:04:40,401 --> 00:04:43,868
which is okay, but I think
you'll find if I recall the

96
00:04:43,868 --> 00:04:46,674
Docker container run command,

97
00:04:46,674 --> 00:04:48,997
we now have a different error message

98
00:04:48,997 --> 00:04:52,247
and it appears to be permission denied.

99
00:04:53,118 --> 00:04:55,633
You can fix that by
running this under Sudu

100
00:04:55,633 --> 00:04:58,719
but I don't think that's a
very good long term solution,

101
00:04:58,719 --> 00:05:00,897
and actually, the answer is, we need to do

102
00:05:00,897 --> 00:05:03,564
sudo usermod, aG and then Docker

103
00:05:10,352 --> 00:05:12,432
and then the name of your user.

104
00:05:12,432 --> 00:05:15,396
Now I've logged in as ec2-user.

105
00:05:15,396 --> 00:05:17,439
That might be different for you.

106
00:05:17,439 --> 00:05:20,925
All we're doing here is
we're adding the current user

107
00:05:20,925 --> 00:05:22,758
into the Docker group.

108
00:05:23,875 --> 00:05:26,495
Now that won't immediately work.

109
00:05:26,495 --> 00:05:30,309
If I do a recall of Docker
container run again,

110
00:05:30,309 --> 00:05:32,166
it will still have the same problem,

111
00:05:32,166 --> 00:05:35,900
but that can be fixed
by simply logging off,

112
00:05:35,900 --> 00:05:37,733
logging back on again,

113
00:05:38,696 --> 00:05:41,388
and then the changes
should now be implied.

114
00:05:41,388 --> 00:05:43,282
So for one final time, I'll do

115
00:05:43,282 --> 00:05:45,949
Docker container run hello-world

116
00:05:47,281 --> 00:05:49,393
and this time something should happen.

117
00:05:49,393 --> 00:05:53,067
There was a short delay while
it was doing this pulling

118
00:05:53,067 --> 00:05:55,831
whatever that is, all will be explained,

119
00:05:55,831 --> 00:05:59,152
and you should be seeing
a hello from Docker.

120
00:05:59,152 --> 00:06:01,484
So that's how things work on Linux.

121
00:06:01,484 --> 00:06:05,930
It's now time to look at
Macintosh and Windows.

122
00:06:05,930 --> 00:06:07,706
Now the problem here is that,

123
00:06:07,706 --> 00:06:10,804
as I described in the previous chapter,

124
00:06:10,804 --> 00:06:13,618
Docker is exploiting containers,

125
00:06:13,618 --> 00:06:17,618
which is a built in feature
of the Linux kernel,

126
00:06:19,014 --> 00:06:23,419
so until very recently,
containers have been something

127
00:06:23,419 --> 00:06:25,336
very specific to Linux.

128
00:06:26,797 --> 00:06:29,423
Now that has changed a little bit.

129
00:06:29,423 --> 00:06:33,590
In September 2016, Microsoft
released a new version

130
00:06:35,008 --> 00:06:39,425
of Windows Server 2016, and
that's the first version

131
00:06:39,425 --> 00:06:43,592
of Windows that have implemented
their own implantation

132
00:06:45,168 --> 00:06:49,425
of containers that run
natively on Windows.

133
00:06:49,425 --> 00:06:52,431
So that's great and exciting,
but at the time of recording,

134
00:06:52,431 --> 00:06:56,598
I'm in 2017 when recording,
this is for containers

135
00:06:57,614 --> 00:07:00,888
on the Server edition of Windows.

136
00:07:00,888 --> 00:07:02,472
This doesn't really change things

137
00:07:02,472 --> 00:07:05,825
when you're developing locally.

138
00:07:05,825 --> 00:07:07,385
So, if you are running on Windows,

139
00:07:07,385 --> 00:07:12,307
you almost certainly do not
have native container support

140
00:07:12,307 --> 00:07:16,474
on your development computer,
and as far as I know,

141
00:07:18,007 --> 00:07:21,332
if you're on a Macintosh,
then you definitely don't have

142
00:07:21,332 --> 00:07:25,736
any kind of support for containers
on your Operating System.

143
00:07:25,736 --> 00:07:28,386
As said in a previous
chapter, that doesn't mean

144
00:07:28,386 --> 00:07:30,964
you can't develop on Docker.

145
00:07:30,964 --> 00:07:33,837
You can, it's just that we
have to do a little trick

146
00:07:33,837 --> 00:07:35,482
to make it work.

147
00:07:35,482 --> 00:07:37,513
I'm not going to talk
any more on this course

148
00:07:37,513 --> 00:07:40,115
about native Windows containers.

149
00:07:40,115 --> 00:07:41,770
It's something of a new feature,

150
00:07:41,770 --> 00:07:44,766
and this is going to develop over time.

151
00:07:44,766 --> 00:07:48,675
In any case, really, this is only relevant

152
00:07:48,675 --> 00:07:51,942
if you're planning on
deploying your software

153
00:07:51,942 --> 00:07:56,783
to a Windows server, and I
would say that's a fairly

154
00:07:56,783 --> 00:08:00,361
unusual thing to do for job development,

155
00:08:00,361 --> 00:08:03,798
so I'm not going to think
any further about this.

156
00:08:03,798 --> 00:08:06,727
However, of course, it
is common to develop

157
00:08:06,727 --> 00:08:11,670
on Windows or Macintosh so
what you're going to do,

158
00:08:11,670 --> 00:08:14,617
if we follow the link for Get Docker,

159
00:08:14,617 --> 00:08:17,582
and I'm recording on Windows but actually,

160
00:08:17,582 --> 00:08:19,531
the details I'm about to follow

161
00:08:19,531 --> 00:08:22,031
are very similar on Macintosh.

162
00:08:22,986 --> 00:08:24,576
By the time you watch this video,

163
00:08:24,576 --> 00:08:26,769
they may have changed the
structure of the website,

164
00:08:26,769 --> 00:08:28,773
but of course this is going to be

165
00:08:28,773 --> 00:08:31,065
a straight forward download.

166
00:08:31,065 --> 00:08:34,301
First of all, there are
two editions of Docker.

167
00:08:34,301 --> 00:08:37,767
It's the common patent
in open source software

168
00:08:37,767 --> 00:08:40,542
in that produce a community edition

169
00:08:40,542 --> 00:08:44,221
and an enterprise edition, and naturally,

170
00:08:44,221 --> 00:08:45,995
the community edition is free,

171
00:08:45,995 --> 00:08:49,974
whereas the enterprise
edition is commercial.

172
00:08:49,974 --> 00:08:52,823
The community edition
will more than suffice

173
00:08:52,823 --> 00:08:54,975
for what we're doing
on the training course,

174
00:08:54,975 --> 00:08:57,135
and actually would probably be sufficient

175
00:08:57,135 --> 00:08:59,760
for many professional
developments as well.

176
00:08:59,760 --> 00:09:02,217
I invite you to check out
the enterprise edition

177
00:09:02,217 --> 00:09:07,114
if you're interested in any of
the features in that edition.

178
00:09:07,114 --> 00:09:08,757
So you should be on the download page

179
00:09:08,757 --> 00:09:10,606
of the community edition.

180
00:09:10,606 --> 00:09:13,506
The complexity is,
depending on which version

181
00:09:13,506 --> 00:09:16,960
of Windows or Mac OS you're running on,

182
00:09:16,960 --> 00:09:21,358
there are two very different
installations that you need.

183
00:09:21,358 --> 00:09:22,657
This is a little bit complicated,

184
00:09:22,657 --> 00:09:25,036
so I will switch to a caption.

185
00:09:25,036 --> 00:09:27,440
If you are running Windows,

186
00:09:27,440 --> 00:09:30,190
then there are two possibilities.

187
00:09:31,188 --> 00:09:35,355
If you are on Windows 10
Pro or Enterprise or later,

188
00:09:37,018 --> 00:09:41,185
you're going to be downloading
Docker for Windows.

189
00:09:42,394 --> 00:09:46,561
Otherwise, you're going to be
downloading Docker Toolbox.

190
00:09:49,064 --> 00:09:52,024
So the otherwise here
would be Windows Vista,

191
00:09:52,024 --> 00:09:55,191
Windows 7, or Windows 10 Home Edition.

192
00:09:57,040 --> 00:10:01,722
We'll talk in a moment about
what Docker Toolbox is.

193
00:10:01,722 --> 00:10:05,322
It's a similar story if you're on a Mac.

194
00:10:05,322 --> 00:10:08,572
If you're on Yosemite 10.10.3 or above,

195
00:10:10,753 --> 00:10:13,670
you will be getting Docker for Mac.

196
00:10:14,966 --> 00:10:17,416
Otherwise, again, you're going

197
00:10:17,416 --> 00:10:20,526
to be getting Docker Toolbox.

198
00:10:20,526 --> 00:10:24,693
This will be the Macintosh
version of Docker Toolbox.

199
00:10:26,195 --> 00:10:29,657
Now what's this all about,
and what's the difference?

200
00:10:29,657 --> 00:10:34,281
Well let's start by talking
about what Docker Toolbox is.

201
00:10:34,281 --> 00:10:36,405
You'll be getting this if
you're on the older versions

202
00:10:36,405 --> 00:10:38,391
of the operating systems.

203
00:10:38,391 --> 00:10:41,813
What this will do is it
will, in the background,

204
00:10:41,813 --> 00:10:44,813
instal a copy of Oracle VirtualBox,

205
00:10:45,907 --> 00:10:49,026
which is a commercial
virtual machine system.

206
00:10:49,026 --> 00:10:51,002
We have actually used virtual box

207
00:10:51,002 --> 00:10:53,088
on previous Virtual Pair
Programmers courses.

208
00:10:53,088 --> 00:10:57,313
I think in particular on the Haduk Course.

209
00:10:57,313 --> 00:11:01,641
All this is going to do
is, it runs a Linux kernel

210
00:11:01,641 --> 00:11:05,808
in a virtual machine, so it
is a bit of a trick really

211
00:11:06,946 --> 00:11:10,296
that although you are
developing on Windows or Mac,

212
00:11:10,296 --> 00:11:12,504
we're going to be using a virtual machine

213
00:11:12,504 --> 00:11:16,152
just to get those container
features from Linux.

214
00:11:16,152 --> 00:11:17,976
Now if you're worried about
this, I can assure you

215
00:11:17,976 --> 00:11:19,506
that it's all in the background.

216
00:11:19,506 --> 00:11:24,097
You don't actually have to run
Oracle VirtualBox yourself.

217
00:11:24,097 --> 00:11:26,377
It will be largely in the background.

218
00:11:26,377 --> 00:11:29,415
Only if you get advanced
do you actually need

219
00:11:29,415 --> 00:11:32,582
to do anything with Oracle VirtualBox.

220
00:11:33,422 --> 00:11:34,799
So it's a bit of a trick really,

221
00:11:34,799 --> 00:11:38,716
but if you're on those
newer Operating Systems,

222
00:11:40,032 --> 00:11:44,290
so just to remind you that's
Windows 10 Pro or Enterprise

223
00:11:44,290 --> 00:11:48,395
or I guess any future
Operating System for Windows,

224
00:11:48,395 --> 00:11:51,562
or for Mac, Yosemite 10.10.3 or above,

225
00:11:52,820 --> 00:11:56,010
then you will get Docker for Windows/Mac,

226
00:11:56,010 --> 00:12:00,177
and the big difference here
is that it's still running

227
00:12:01,617 --> 00:12:03,649
the Linux virtual machine.

228
00:12:03,649 --> 00:12:07,267
I think some people think
Docker for Windows or Mac

229
00:12:07,267 --> 00:12:10,491
is some kind of native
support from Docker.

230
00:12:10,491 --> 00:12:11,858
Actually, it isn't.

231
00:12:11,858 --> 00:12:14,969
It is still running a virtual machine,

232
00:12:14,969 --> 00:12:19,136
it's just that it's using the
native virtualization support

233
00:12:20,232 --> 00:12:23,013
from your host operating system,

234
00:12:23,013 --> 00:12:26,582
so it doesn't need to
run Oracle VirtualBox,

235
00:12:26,582 --> 00:12:29,471
is the fundamental difference.

236
00:12:29,471 --> 00:12:31,337
So on Windows 10 Professional,

237
00:12:31,337 --> 00:12:34,530
that service is called Hyper-V.

238
00:12:34,530 --> 00:12:36,198
I must admit, I'm not
sure what it's called

239
00:12:36,198 --> 00:12:37,551
on the Mac OS.

240
00:12:37,551 --> 00:12:40,685
I haven't developed on
my OS in some years now,

241
00:12:40,685 --> 00:12:42,473
but it's a very similar idea.

242
00:12:42,473 --> 00:12:45,056
So this is more efficient
because it's using

243
00:12:45,056 --> 00:12:48,056
native support for virtual machines,

244
00:12:48,986 --> 00:12:51,900
but either way, you're still
running a virtual machine.

245
00:12:51,900 --> 00:12:53,924
So if you've installed Docker for Windows

246
00:12:53,924 --> 00:12:56,437
or Docker for Mac, it
will show up as an app

247
00:12:56,437 --> 00:12:58,547
on your Operating System.

248
00:12:58,547 --> 00:13:02,557
It should automatically start
when you boot your computer

249
00:13:02,557 --> 00:13:05,605
but if not, then you'll
need to run the app

250
00:13:05,605 --> 00:13:08,688
Docker for Windows or Docker for Mac.

251
00:13:09,908 --> 00:13:12,210
I think the confusing thing
about Docker for Windows

252
00:13:12,210 --> 00:13:14,262
at least, I'm not sure about Mac,

253
00:13:14,262 --> 00:13:16,772
is that it actually runs in the background

254
00:13:16,772 --> 00:13:21,307
and it doesn't have any
obvious windows or icons.

255
00:13:21,307 --> 00:13:25,474
It will in fact show up as an
icon in your tool tray here

256
00:13:26,778 --> 00:13:30,031
and it's this icon here, and we can see,

257
00:13:30,031 --> 00:13:32,803
it's just saying Docker is starting.

258
00:13:32,803 --> 00:13:35,886
There is a right click menu available

259
00:13:36,845 --> 00:13:40,542
where you can quit
Docker, and there's a link

260
00:13:40,542 --> 00:13:42,912
to the documentation and so on there,

261
00:13:42,912 --> 00:13:45,321
but just as I've been talking about it,

262
00:13:45,321 --> 00:13:49,886
I do have a window saying
Docker is now up and running.

263
00:13:49,886 --> 00:13:53,841
So I am recording here on
Windows 10 Professional,

264
00:13:53,841 --> 00:13:56,664
so I'm able to use Docker for Windows.

265
00:13:56,664 --> 00:13:59,842
So if you're using Docker for
Windows or Docker for Mac,

266
00:13:59,842 --> 00:14:02,799
once you've installed it and it's running,

267
00:14:02,799 --> 00:14:05,268
then you can use Docker really

268
00:14:05,268 --> 00:14:07,778
from any of your terminal windows.

269
00:14:07,778 --> 00:14:11,480
Here I have a regular Cygwin installation,

270
00:14:11,480 --> 00:14:15,623
and if I type Docker there,
I'm seeing the Docker commands.

271
00:14:15,623 --> 00:14:17,957
I have to tell you though
that there are a few problems

272
00:14:17,957 --> 00:14:21,222
with running Docker in Cygwin,

273
00:14:21,222 --> 00:14:24,348
and I've never really worked
my way through those problems,

274
00:14:24,348 --> 00:14:26,786
and that's because Docker
recommend that you use

275
00:14:26,786 --> 00:14:29,427
the Windows PowerShell.

276
00:14:29,427 --> 00:14:32,076
So obviously this is
only relevant to Windows.

277
00:14:32,076 --> 00:14:33,516
If you're on a Mac then just

278
00:14:33,516 --> 00:14:36,991
use the regular terminal prompt.

279
00:14:36,991 --> 00:14:39,817
The PowerShell ships with Windows,

280
00:14:39,817 --> 00:14:42,468
and you can get at it
through the Start menu,

281
00:14:42,468 --> 00:14:44,320
and just type in Power.

282
00:14:44,320 --> 00:14:46,521
This is effectively a
much improved version

283
00:14:46,521 --> 00:14:48,311
of the command prompt and you'll be able

284
00:14:48,311 --> 00:14:51,758
to issue your Docker commands from there.

285
00:14:51,758 --> 00:14:55,726
Finally, if you're not able
to run Docker for Windows

286
00:14:55,726 --> 00:15:00,015
or Docker for Mac, then you'll
be running Docker Toolbox.

287
00:15:00,015 --> 00:15:02,909
The big difference is you
won't be able to access Docker

288
00:15:02,909 --> 00:15:07,296
from your regular terminal
or command prompts.

289
00:15:07,296 --> 00:15:10,592
Instead, you're going
to have to manually run

290
00:15:10,592 --> 00:15:13,967
the Docker Quickstart Terminal.

291
00:15:13,967 --> 00:15:16,682
Now, I do have it
installed on this computer

292
00:15:16,682 --> 00:15:19,345
just for demonstration
purposes, but I can't run it

293
00:15:19,345 --> 00:15:22,185
because it will crash my Operating System.

294
00:15:22,185 --> 00:15:25,408
You absolutely should not have the Toolbox

295
00:15:25,408 --> 00:15:28,832
and Docker for Windows
installed at the same time.

296
00:15:28,832 --> 00:15:31,453
I just have it here for illustration,

297
00:15:31,453 --> 00:15:34,587
and it's exactly the same on a Macintosh.

298
00:15:34,587 --> 00:15:36,807
When you instal the Docker Toolbox,

299
00:15:36,807 --> 00:15:38,626
you'll be given an icon to run

300
00:15:38,626 --> 00:15:41,379
the Docker Quickstart Terminal,

301
00:15:41,379 --> 00:15:44,646
and that terminal will be
a terminal very much like

302
00:15:44,646 --> 00:15:48,124
PowerShell, that should
recognise Docker commands.

303
00:15:48,124 --> 00:15:49,813
Now I know all of that was painful.

304
00:15:49,813 --> 00:15:52,321
I hated describing it and explaining it,

305
00:15:52,321 --> 00:15:55,185
but there's a lot of misconceptions
about what's happening

306
00:15:55,185 --> 00:15:58,076
when you're installing
Docker on Windows and Mac.

307
00:15:58,076 --> 00:16:01,084
You are running virtual machines.

308
00:16:01,084 --> 00:16:02,547
I hope you've managed to do this

309
00:16:02,547 --> 00:16:04,537
without any problems for yourself.

310
00:16:04,537 --> 00:16:07,587
If not, please do contact us
at Virtual Pair Programmers

311
00:16:07,587 --> 00:16:10,944
and we will try our
best to get you started.

312
00:16:10,944 --> 00:16:14,489
The end result of all this should be,

313
00:16:14,489 --> 00:16:16,590
in whichever kind of, whether you're

314
00:16:16,590 --> 00:16:19,352
in the Quickstart Terminal or
if you're in the PowerShell

315
00:16:19,352 --> 00:16:21,576
or whatever, you should be able to type

316
00:16:21,576 --> 00:16:24,243
Docker container run hello-world

317
00:16:31,080 --> 00:16:34,509
and you should see output similar to mine.

318
00:16:34,509 --> 00:16:37,751
You will have had an unable
to find image locally,

319
00:16:37,751 --> 00:16:39,910
it will have done some operations,

320
00:16:39,910 --> 00:16:43,706
and then you should be
seeing a Hello from Docker.

321
00:16:43,706 --> 00:16:46,859
If you've gotten this
far, seriously, well done.

322
00:16:46,859 --> 00:16:49,181
It's a real pain getting
started with Docker

323
00:16:49,181 --> 00:16:51,688
on Windows and Mac, but if you're here,

324
00:16:51,688 --> 00:16:54,945
we're ready to start to
reap the benefits of Docker

325
00:16:54,945 --> 00:16:57,883
which we'll be doing in the next chapter.

326
00:16:57,883 --> 00:17:01,383
If you didn't get this far, do contact us.

1
00:00:00,636 --> 00:00:03,419
- [Instructor] Hello and welcome back!

2
00:00:03,419 --> 00:00:06,185
In this chapter, we're going to go through

3
00:00:06,185 --> 00:00:10,435
a realistic scenario in
which you might use Docker.

4
00:00:10,435 --> 00:00:12,995
We're going to deploy a fairly complex

5
00:00:12,995 --> 00:00:17,113
Java Tomcat application to
our local development machine,

6
00:00:17,113 --> 00:00:21,439
hopefully without having
to do too much work.

7
00:00:21,439 --> 00:00:22,985
I admit that the previous chapter

8
00:00:22,985 --> 00:00:25,903
was probably quite painful for some of you

9
00:00:25,903 --> 00:00:29,056
depending on which operating
system you're running on,

10
00:00:29,056 --> 00:00:31,856
but I hope by now the position you're in

11
00:00:31,856 --> 00:00:34,755
is that either on your Powershell,

12
00:00:34,755 --> 00:00:37,050
if you're running Windows 10 Professional,

13
00:00:37,050 --> 00:00:40,040
or on your terminal, if
you're running on Linux,

14
00:00:40,040 --> 00:00:43,373
or Mac OS from Yosemite 10.10.3 onwards,

15
00:00:45,026 --> 00:00:49,270
or you'll be using the
Docker Quickstart Terminal

16
00:00:49,270 --> 00:00:51,906
if you're on older versions of Windows

17
00:00:51,906 --> 00:00:54,695
or older versions of Mac OS.

18
00:00:54,695 --> 00:00:56,883
Either way, you should be on
some kind of a command line,

19
00:00:56,883 --> 00:00:57,722
and you should be able
(keyboard clicking)

20
00:00:57,722 --> 00:01:01,889
to type docker container
run, followed by hello-world,

21
00:01:04,291 --> 00:01:07,900
and you should see output like this

22
00:01:07,900 --> 00:01:10,694
and definitely no errors.

23
00:01:10,694 --> 00:01:12,204
If you've got that far, then you can start

24
00:01:12,204 --> 00:01:14,957
to reap the benefits of Docker.

25
00:01:14,957 --> 00:01:16,245
And I thought what we'd do on this course

26
00:01:16,245 --> 00:01:20,170
rather than me ploughing
through endless commands

27
00:01:20,170 --> 00:01:25,073
and going into deep tech
analysis about how Docker works,

28
00:01:25,073 --> 00:01:27,565
I'd rather sort of use Docker

29
00:01:27,565 --> 00:01:30,256
in the way that you might be using Docker

30
00:01:30,256 --> 00:01:32,506
in a real live environment.

31
00:01:33,372 --> 00:01:35,216
So I have a made-up scenario here.

32
00:01:35,216 --> 00:01:37,805
We're working in an operations team now.

33
00:01:37,805 --> 00:01:40,768
I know that many of you will
be working it as DevOps,

34
00:01:40,768 --> 00:01:42,810
where you're both a developer

35
00:01:42,810 --> 00:01:44,728
and you're working in operations,

36
00:01:44,728 --> 00:01:47,014
but I think for the course, it's useful

37
00:01:47,014 --> 00:01:51,181
to distinguish the roles of
developer and operations.

38
00:01:52,404 --> 00:01:53,853
So we're working in operations,

39
00:01:53,853 --> 00:01:56,311
and we've had an e-mail.

40
00:01:56,311 --> 00:01:59,512
And the e-mail says that this developer

41
00:01:59,512 --> 00:02:03,345
has finally got something
working on a web app

42
00:02:04,330 --> 00:02:06,036
that they're developing.

43
00:02:06,036 --> 00:02:09,012
If you're been on the previous
virtual pair programmes course

44
00:02:09,012 --> 00:02:12,132
for deploying microservices,

45
00:02:12,132 --> 00:02:14,636
then you'll be familiar with this web app.

46
00:02:14,636 --> 00:02:16,878
Actually, we developed this originally

47
00:02:16,878 --> 00:02:19,045
on the spring boot course.

48
00:02:19,885 --> 00:02:23,325
It's a fleet manager that tracks vehicles.

49
00:02:23,325 --> 00:02:28,180
Now, apparently, the developer
has now got the vehicles

50
00:02:28,180 --> 00:02:32,184
animated, and they can
now move on the web page,

51
00:02:32,184 --> 00:02:35,343
and they want us to test
that there are changes.

52
00:02:35,343 --> 00:02:36,466
How are we going to do that?

53
00:02:36,466 --> 00:02:39,665
Well, they've given us
two pieces of information.

54
00:02:39,665 --> 00:02:42,126
They've told us first of
all the image is called

55
00:02:42,126 --> 00:02:46,293
virtualpairprogrammers/fleetman-webapp.

56
00:02:47,305 --> 00:02:50,317
And they've given us a
link to some kind of a file

57
00:02:50,317 --> 00:02:54,484
called the Dockerfile at
the URL you can see here.

58
00:02:55,598 --> 00:02:59,729
And they're asking us to
run it, and if it runs okay,

59
00:02:59,729 --> 00:03:03,525
they'd like us to try to
run it on an EC2 instance

60
00:03:03,525 --> 00:03:06,256
and give them the IP address.

61
00:03:06,256 --> 00:03:09,001
So, and I went through this
in the introduction chapters,

62
00:03:09,001 --> 00:03:13,492
but we don't really know
much about this application.

63
00:03:13,492 --> 00:03:15,697
I guess we could inspect the source code

64
00:03:15,697 --> 00:03:18,688
if we went across this git hub repository,

65
00:03:18,688 --> 00:03:21,838
and we could work out that
it's a Tomcat application.

66
00:03:21,838 --> 00:03:26,086
It needs a war file,
it's using a database,

67
00:03:26,086 --> 00:03:27,911
we need to configure that database,

68
00:03:27,911 --> 00:03:31,271
we need to open up the
ports, et cetera, et cetera,

69
00:03:31,271 --> 00:03:32,991
et cetera, and you all know what kind

70
00:03:32,991 --> 00:03:34,908
of a nightmare that is.

71
00:03:35,789 --> 00:03:37,753
But you know that we're using Docker,

72
00:03:37,753 --> 00:03:41,437
and I've gone through
the concept of images,

73
00:03:41,437 --> 00:03:44,322
and that's clearly what we have here,

74
00:03:44,322 --> 00:03:48,818
and we know that an image is
a definition of a container.

75
00:03:48,818 --> 00:03:52,119
And the image is going to
contain all of the software

76
00:03:52,119 --> 00:03:57,069
and the environment needed
to run this application.

77
00:03:57,069 --> 00:04:01,637
What I didn't tell you was
that all images have names,

78
00:04:01,637 --> 00:04:03,223
and this is the name of the image

79
00:04:03,223 --> 00:04:05,521
that the developer has built.

80
00:04:05,521 --> 00:04:07,929
What can we do with that name?

81
00:04:07,929 --> 00:04:10,200
Well, we can download that image.

82
00:04:10,200 --> 00:04:14,117
And the command to do
that is docker image pull

83
00:04:17,538 --> 00:04:20,059
followed by the name of the image.

84
00:04:20,059 --> 00:04:24,226
And that was
virtualpairprogrammers/fleetman-webapp.

85
00:04:29,826 --> 00:04:33,133
So, you should be able
to follow along with me.

86
00:04:33,133 --> 00:04:35,302
And on issuing this command,

87
00:04:35,302 --> 00:04:37,885
you should see a download happening.

88
00:04:37,885 --> 00:04:41,048
So, clearly what's
happening here is somehow

89
00:04:41,048 --> 00:04:43,886
these images that I've been talking about

90
00:04:43,886 --> 00:04:47,355
are able to be distributed really easily.

91
00:04:47,355 --> 00:04:49,749
You haven't had to kind
of download this image

92
00:04:49,749 --> 00:04:53,455
from a website or anything,
you just put in this label,

93
00:04:53,455 --> 00:04:56,460
and somehow Docker is
able to find that image

94
00:04:56,460 --> 00:04:58,585
and start downloading it.

95
00:04:58,585 --> 00:05:00,145
Now, of course I'll be
giving you full details

96
00:05:00,145 --> 00:05:03,033
about how all this works
later on in the course,

97
00:05:03,033 --> 00:05:05,514
but for now, I think it's
probably just enough to know

98
00:05:05,514 --> 00:05:07,326
that hey, you know, we
can, as long as we know

99
00:05:07,326 --> 00:05:10,393
the name of an image that
somebody has created,

100
00:05:10,393 --> 00:05:14,560
we can simply download it
by using docker image pull.

101
00:05:15,408 --> 00:05:17,377
Now while that's
downloading, I will say that

102
00:05:17,377 --> 00:05:19,972
probably the hardest thing
about working with Docker

103
00:05:19,972 --> 00:05:23,225
is remembering this long list of commands,

104
00:05:23,225 --> 00:05:24,847
and it is going to feel on this course

105
00:05:24,847 --> 00:05:27,985
like I'm throwing loads
of commands at you.

106
00:05:27,985 --> 00:05:29,702
So for that reason,
I'm going to gather all

107
00:05:29,702 --> 00:05:31,842
of these commands
together, and I'll put them

108
00:05:31,842 --> 00:05:35,214
in an easy reference guide
that you can download

109
00:05:35,214 --> 00:05:37,060
as part of this course.

110
00:05:37,060 --> 00:05:39,223
So that's one command we've got now.

111
00:05:39,223 --> 00:05:40,723
Docker image pull.

112
00:05:42,039 --> 00:05:44,078
Okay, well, we've downloaded that image,

113
00:05:44,078 --> 00:05:45,314
so what can we do with it?

114
00:05:45,314 --> 00:05:48,190
Well, as described in the introduction,

115
00:05:48,190 --> 00:05:52,341
what we want to do with
an image is run it,

116
00:05:52,341 --> 00:05:57,231
and when we run an image,
it will become a container.

117
00:05:57,231 --> 00:05:59,854
A self-contained complete environment

118
00:05:59,854 --> 00:06:02,745
that's running some kind of software.

119
00:06:02,745 --> 00:06:04,283
Before we try that,
there is one little bit

120
00:06:04,283 --> 00:06:06,334
of information that the developer gave us,

121
00:06:06,334 --> 00:06:10,001
which is the Dockerfile
is at this URL here.

122
00:06:11,507 --> 00:06:15,102
And you can follow that
URL if you want to,

123
00:06:15,102 --> 00:06:17,104
but you don't need to,
because I've mounted it

124
00:06:17,104 --> 00:06:18,837
onto this caption.

125
00:06:18,837 --> 00:06:21,776
We'll be looking at this
Dockerfile in great detail

126
00:06:21,776 --> 00:06:24,128
later on in the course,
and you will be writing

127
00:06:24,128 --> 00:06:26,620
your own Dockerfiles, but for now,

128
00:06:26,620 --> 00:06:28,450
it's enough to know that a Dockerfile

129
00:06:28,450 --> 00:06:32,533
is what we use to define
the content of an image,

130
00:06:33,414 --> 00:06:36,809
and therefore, the Dockerfile determines

131
00:06:36,809 --> 00:06:40,202
what's going to be in the
ultimate running container.

132
00:06:40,202 --> 00:06:41,949
And there's quite a lot
of information in here

133
00:06:41,949 --> 00:06:44,269
that isn't really of
relevance to us right now,

134
00:06:44,269 --> 00:06:46,951
but there are a couple of
important pieces of information

135
00:06:46,951 --> 00:06:49,725
that we need as deployers.

136
00:06:49,725 --> 00:06:53,142
The first line is here, this EXPOSE 8080.

137
00:06:55,516 --> 00:06:58,077
Now, I'm assuming that
if you're on this course,

138
00:06:58,077 --> 00:07:00,993
you're familiar with
Java web developments,

139
00:07:00,993 --> 00:07:03,795
and you'll recognise
8080 as the common pull

140
00:07:03,795 --> 00:07:06,378
that Tomcat runs on by default.

141
00:07:07,548 --> 00:07:11,037
And effectively what the
developer is telling us here

142
00:07:11,037 --> 00:07:14,194
is that they want Tomcat to run

143
00:07:14,194 --> 00:07:17,111
on port 8080 inside this container.

144
00:07:19,264 --> 00:07:20,960
Without this piece of
knowledge, we wouldn't know

145
00:07:20,960 --> 00:07:24,906
what port the developer
wants it to run on.

146
00:07:24,906 --> 00:07:28,764
The other piece of
information is the part here

147
00:07:28,764 --> 00:07:30,418
that I've emboldened.

148
00:07:30,418 --> 00:07:32,554
This is why the developer is specifying

149
00:07:32,554 --> 00:07:35,611
how they want their
war file to be deployed

150
00:07:35,611 --> 00:07:39,715
to the running Tomcat
inside this container.

151
00:07:39,715 --> 00:07:43,008
And the only reason this is
of interest to us right now

152
00:07:43,008 --> 00:07:45,634
is we need to know the name here.

153
00:07:45,634 --> 00:07:47,753
Again, I'm assuming
you're familiar with this

154
00:07:47,753 --> 00:07:50,017
from Java web development.

155
00:07:50,017 --> 00:07:54,886
The name of the war file
here will become the context

156
00:07:54,886 --> 00:07:58,088
under which this
application is going to run.

157
00:07:58,088 --> 00:07:59,788
And we need to know the name of that

158
00:07:59,788 --> 00:08:03,895
so we know what to type in on the browser

159
00:08:03,895 --> 00:08:07,182
when we actually visit
this running application.

160
00:08:07,182 --> 00:08:10,579
Now, if there'd been anything
here other than ROOT,

161
00:08:10,579 --> 00:08:14,135
then we would have to
include that name in the URL.

162
00:08:14,135 --> 00:08:16,127
However, I don't know if you know this,

163
00:08:16,127 --> 00:08:17,825
we must have done it on previous courses,

164
00:08:17,825 --> 00:08:20,658
but if the war is called ROOT.war,

165
00:08:23,283 --> 00:08:26,466
then it becomes the ROOT application,

166
00:08:26,466 --> 00:08:28,938
and we can just visit this application

167
00:08:28,938 --> 00:08:32,064
via its domain name or IP address.

168
00:08:32,064 --> 00:08:34,311
We don't need to put a forward slash

169
00:08:34,311 --> 00:08:36,771
followed by some kind of a name.

170
00:08:36,771 --> 00:08:38,808
So that's definitely of relevance to us.

171
00:08:38,808 --> 00:08:40,874
Without that, we wouldn't have known how

172
00:08:40,874 --> 00:08:43,312
to visit this application.

173
00:08:43,312 --> 00:08:45,531
Quite a lot to learn about Dockerfiles

174
00:08:45,531 --> 00:08:47,387
later on in the course,

175
00:08:47,387 --> 00:08:50,064
but for now, we actually know enough

176
00:08:50,064 --> 00:08:53,036
to be able to run this image.

177
00:08:53,036 --> 00:08:57,203
To run an image, we need the
command docker container run

178
00:09:00,632 --> 00:09:03,896
followed by the name of the
image that we're running.

179
00:09:03,896 --> 00:09:04,853
So that's going to be

180
00:09:04,853 --> 00:09:09,020
virtualpairprogrammers/fleetman-webapp.

181
00:09:11,764 --> 00:09:13,531
Before I run that
command, there's something

182
00:09:13,531 --> 00:09:15,856
very important that we need to do.

183
00:09:15,856 --> 00:09:19,381
We know from that Dockerfile
that inside this container,

184
00:09:19,381 --> 00:09:23,548
we're going to have an Apache
Tomcat running on port 8080.

185
00:09:26,035 --> 00:09:28,572
But it's really important to understand

186
00:09:28,572 --> 00:09:31,822
that that port 8080 will not be visible

187
00:09:33,139 --> 00:09:37,306
from outside the container,
or at least, by default.

188
00:09:38,494 --> 00:09:41,494
The components inside the container,

189
00:09:42,834 --> 00:09:45,614
let's say we had, I don't
know, say a database server

190
00:09:45,614 --> 00:09:49,457
running inside this container,
that database server

191
00:09:49,457 --> 00:09:53,207
would be able to contact
Tomcat on port 8080,

192
00:09:54,344 --> 00:09:57,294
because it's running inside the container.

193
00:09:57,294 --> 00:09:59,226
But from outside the container,

194
00:09:59,226 --> 00:10:01,407
these ports are not visible.

195
00:10:01,407 --> 00:10:03,903
They're not published.

196
00:10:03,903 --> 00:10:06,561
Now that's a nice feature
actually of Docker,

197
00:10:06,561 --> 00:10:09,524
because it means that at deployment time,

198
00:10:09,524 --> 00:10:12,706
in other words, when we're
actually running the container,

199
00:10:12,706 --> 00:10:16,661
we as deployers get to be able to choose

200
00:10:16,661 --> 00:10:18,656
which parts of the container are going

201
00:10:18,656 --> 00:10:21,284
to be exposed to the outside world.

202
00:10:21,284 --> 00:10:24,278
It's actually a pretty
neat security feature.

203
00:10:24,278 --> 00:10:27,061
So what we need to do
when we run the container

204
00:10:27,061 --> 00:10:29,394
is we need to publish ports.

205
00:10:31,752 --> 00:10:36,382
So we need to somehow say
that if we have a browser

206
00:10:36,382 --> 00:10:38,720
trying to access this container,

207
00:10:38,720 --> 00:10:40,887
and it accesses port 8080,

208
00:10:41,825 --> 00:10:45,187
well we want that traffic to be forwarded

209
00:10:45,187 --> 00:10:48,270
to the internal containers port 8080.

210
00:10:49,225 --> 00:10:50,979
And we do that as part of the commands.

211
00:10:50,979 --> 00:10:52,399
So I haven't run this command yet,

212
00:10:52,399 --> 00:10:56,515
but I'm going to back up
to just after the run part.

213
00:10:56,515 --> 00:10:59,970
And we do this through
command line arguments.

214
00:10:59,970 --> 00:11:01,524
And the argument is -p,

215
00:11:01,524 --> 00:11:04,357
which actually stands for publish.

216
00:11:05,300 --> 00:11:07,545
And what we do with this is we say

217
00:11:07,545 --> 00:11:11,614
which port do we want to
expose to the outside world,

218
00:11:11,614 --> 00:11:15,781
in that case for us, this is
8080, followed by a colon,

219
00:11:16,813 --> 00:11:20,382
followed by the internal
port inside the container

220
00:11:20,382 --> 00:11:23,555
that we want to forward that traffic to.

221
00:11:23,555 --> 00:11:26,424
So this means that if
in a browser I type in

222
00:11:26,424 --> 00:11:30,846
IP address :8080, that
traffic will be directed

223
00:11:30,846 --> 00:11:34,179
to the Tomcat port inside the container.

224
00:11:35,150 --> 00:11:37,385
And that, until we get a
little bit more advanced

225
00:11:37,385 --> 00:11:40,506
is all we need to run a container.

226
00:11:40,506 --> 00:11:41,586
If you're following along with me,

227
00:11:41,586 --> 00:11:43,419
let's give this a try.

228
00:11:47,957 --> 00:11:50,175
And you should recognise from here

229
00:11:50,175 --> 00:11:55,065
what looks like definitely a
regular Java web apps login,

230
00:11:55,065 --> 00:11:56,805
but we can see from here

231
00:11:56,805 --> 00:12:00,239
this looks like a spring boot application,

232
00:12:00,239 --> 00:12:01,672
and there's some hibernate logging

233
00:12:01,672 --> 00:12:03,172
going on in there.

234
00:12:04,287 --> 00:12:06,263
So something to do with databases

235
00:12:06,263 --> 00:12:10,770
even though we haven't
configured a database ourselves.

236
00:12:10,770 --> 00:12:12,666
It might take a while to start up for me,

237
00:12:12,666 --> 00:12:14,643
it took about 30 seconds.

238
00:12:14,643 --> 00:12:16,294
Depending on the speed of your machine,

239
00:12:16,294 --> 00:12:18,336
it might take longer.

240
00:12:18,336 --> 00:12:20,394
Now of course, because I've
just given you this image,

241
00:12:20,394 --> 00:12:22,542
we don't know how
complicated the image was,

242
00:12:22,542 --> 00:12:24,021
but I want you to take this step back

243
00:12:24,021 --> 00:12:26,025
and really think about we didn't have

244
00:12:26,025 --> 00:12:29,628
to do any configuration
other than that little bit

245
00:12:29,628 --> 00:12:33,549
of work in publishing
the appropriate ports.

246
00:12:33,549 --> 00:12:37,337
We should now be able to
visit this in a browser.

247
00:12:37,337 --> 00:12:39,901
Now depending on which version of Docker

248
00:12:39,901 --> 00:12:43,253
you have installed, you might be able to,

249
00:12:43,253 --> 00:12:46,753
in your browser now, visit localhost:8080,

250
00:12:49,856 --> 00:12:53,435
the port that we've
published, and that's it.

251
00:12:53,435 --> 00:12:55,612
Because we know from the Docker file

252
00:12:55,612 --> 00:13:00,163
that the application has
been deployed to ROOT.war,

253
00:13:00,163 --> 00:13:03,255
therefore, there's no sub folder

254
00:13:03,255 --> 00:13:06,435
like Fleetman web app
or anything like that.

255
00:13:06,435 --> 00:13:08,436
If you have been on earlier courses

256
00:13:08,436 --> 00:13:10,902
where you've developed
this Fleetman application,

257
00:13:10,902 --> 00:13:13,099
I have slightly re-engineered this

258
00:13:13,099 --> 00:13:16,309
to remove the rather complex URL schemes

259
00:13:16,309 --> 00:13:17,212
that we had in there.

260
00:13:17,212 --> 00:13:20,083
I've made the front
page be as it should be,

261
00:13:20,083 --> 00:13:22,872
just on the forward slash.

262
00:13:22,872 --> 00:13:25,122
So, that is working for me.

263
00:13:26,916 --> 00:13:28,664
I'm seeing a running application.

264
00:13:28,664 --> 00:13:32,642
Now, if you're running on Docker toolbox,

265
00:13:32,642 --> 00:13:35,516
so that's if you're on Mac or Windows,

266
00:13:35,516 --> 00:13:40,318
then you're probably not
getting anything at this stage.

267
00:13:40,318 --> 00:13:42,054
And that's because the virtual machine

268
00:13:42,054 --> 00:13:43,085
that you're running on,

269
00:13:43,085 --> 00:13:47,252
remember Mac and Windows are
all using virtual machines

270
00:13:48,255 --> 00:13:51,688
for the Linux colonel, the
IP address of that virtual

271
00:13:51,688 --> 00:13:55,438
machine is not actually
mapped to local host.

272
00:13:56,794 --> 00:14:01,068
What you need to put in here
is actually the IP address

273
00:14:01,068 --> 00:14:03,302
of your virtual machine.

274
00:14:03,302 --> 00:14:05,341
So how do you find that?

275
00:14:05,341 --> 00:14:07,722
Well, again, you can get
that from the command line,

276
00:14:07,722 --> 00:14:09,764
and I'm going to do a Control+C,

277
00:14:09,764 --> 00:14:11,668
pressing Control+C on the Powershell

278
00:14:11,668 --> 00:14:14,285
does not kill a container.

279
00:14:14,285 --> 00:14:17,383
It actually leaves it
running in the background.

280
00:14:17,383 --> 00:14:18,994
But that gives me a chance to show you

281
00:14:18,994 --> 00:14:21,224
some extra Docker commands.

282
00:14:21,224 --> 00:14:24,427
Again, these are all going
to be in the PDF document

283
00:14:24,427 --> 00:14:27,335
that you can download
as part of this course.

284
00:14:27,335 --> 00:14:30,002
If you do a docker container ls,

285
00:14:32,275 --> 00:14:36,747
that's going to list all
of your running containers.

286
00:14:36,747 --> 00:14:40,326
So we can see here that
we have a container ID,

287
00:14:40,326 --> 00:14:45,179
which is some kind of
random generated ID number.

288
00:14:45,179 --> 00:14:48,862
That's the image that the
container was created from.

289
00:14:48,862 --> 00:14:50,886
We'll think about the command later.

290
00:14:50,886 --> 00:14:52,357
The lifetime of the container,

291
00:14:52,357 --> 00:14:55,037
mines been up for 13 minutes,

292
00:14:55,037 --> 00:14:57,184
and there's the port mapping.

293
00:14:57,184 --> 00:14:58,718
And finally we have a name.

294
00:14:58,718 --> 00:15:01,107
Now, we can give every
container that we run

295
00:15:01,107 --> 00:15:03,940
a unique name if we wish to do so.

296
00:15:05,274 --> 00:15:07,032
We will need to do that shortly,

297
00:15:07,032 --> 00:15:08,847
but for now, it really doesn't matter

298
00:15:08,847 --> 00:15:10,217
what the name of the container is,

299
00:15:10,217 --> 00:15:12,441
so we will get one automatically

300
00:15:12,441 --> 00:15:15,616
randomly generated by Docker.

301
00:15:15,616 --> 00:15:17,366
And just in case you're interested,

302
00:15:17,366 --> 00:15:22,105
the random generation is
some kind of adjective,

303
00:15:22,105 --> 00:15:25,684
a describing word, followed by I think

304
00:15:25,684 --> 00:15:28,830
they have a long list
of surnames of famous

305
00:15:28,830 --> 00:15:31,707
and notable people, so
you may well recognise

306
00:15:31,707 --> 00:15:34,251
some of these surnames.

307
00:15:34,251 --> 00:15:36,944
The name's not important for us right now.

308
00:15:36,944 --> 00:15:37,850
So we'll leave the container

309
00:15:37,850 --> 00:15:39,492
running in the background for the moment,

310
00:15:39,492 --> 00:15:42,235
but now I'll show you
how to get the IP address

311
00:15:42,235 --> 00:15:45,937
if you're running on Docker Toolbox.

312
00:15:45,937 --> 00:15:48,354
You can do docker-machine ip.

313
00:15:52,339 --> 00:15:54,929
Now for me, that's not
going to give me any,

314
00:15:54,929 --> 00:15:56,940
well it's actually giving an error,

315
00:15:56,940 --> 00:15:59,555
and that's because I'm
using Docker for Windows.

316
00:15:59,555 --> 00:16:02,288
But on the Docker Toolbox,
you should see an IP address

317
00:16:02,288 --> 00:16:04,650
in there, which you'll be able to use

318
00:16:04,650 --> 00:16:08,375
in your browser instead of local host.

319
00:16:08,375 --> 00:16:10,075
So if you do have an IP address here,

320
00:16:10,075 --> 00:16:14,242
then copy that in and paste
it into your browser: 8080.

321
00:16:15,428 --> 00:16:18,076
Before we move on, a couple
of things I'd like to do.

322
00:16:18,076 --> 00:16:21,855
So we've seen that we can
do the docker container ls,

323
00:16:21,855 --> 00:16:23,597
which will show us a list

324
00:16:23,597 --> 00:16:26,198
of all of the running containers.

325
00:16:26,198 --> 00:16:27,777
I guess it would be useful to show you

326
00:16:27,777 --> 00:16:30,659
how to stop a running container.

327
00:16:30,659 --> 00:16:34,326
Well, we do that with
docker container stop,

328
00:16:35,584 --> 00:16:38,359
and you can put in now
the ID of the container.

329
00:16:38,359 --> 00:16:41,052
Now, the ID of the
container is quite a long

330
00:16:41,052 --> 00:16:44,301
random generated string of characters.

331
00:16:44,301 --> 00:16:47,123
But you're allowed to
enter the fewest number

332
00:16:47,123 --> 00:16:51,290
of characters that uniquely
identifies this container.

333
00:16:52,416 --> 00:16:54,473
So, I think actually we could just say

334
00:16:54,473 --> 00:16:56,473
docker container stop 4.

335
00:16:57,495 --> 00:16:59,481
Now, I personally like to put in at least

336
00:16:59,481 --> 00:17:02,913
the first couple of characters of that ID,

337
00:17:02,913 --> 00:17:06,913
so 4c would do it, or 4c8
would certainly do it.

338
00:17:08,757 --> 00:17:12,194
Just to show you that 4c is sufficient,

339
00:17:12,194 --> 00:17:14,525
I don't see an error message there,

340
00:17:14,525 --> 00:17:16,465
and we just get echoed back the ID

341
00:17:16,465 --> 00:17:18,878
of the container that we've stopped.

342
00:17:18,878 --> 00:17:21,301
Of course, yours almost
certainly won't be 4c,

343
00:17:21,301 --> 00:17:24,361
so just substitute in as required.

344
00:17:24,361 --> 00:17:27,088
And if we run docker container ls again,

345
00:17:27,088 --> 00:17:30,894
you can now see that we
have no running containers.

346
00:17:30,894 --> 00:17:33,791
Go back to the browser
and do a refresh here.

347
00:17:33,791 --> 00:17:35,580
Remember, if you're on Docker Toolbox,

348
00:17:35,580 --> 00:17:37,871
you'll need an IP address in there.

349
00:17:37,871 --> 00:17:42,066
Then, yeah, the site
can now not be reached.

350
00:17:42,066 --> 00:17:43,598
Now I wanted to do that just to show you

351
00:17:43,598 --> 00:17:47,765
that if I recall the command
that ran the container,

352
00:17:49,075 --> 00:17:53,714
I want to focus in on
this publishing of ports.

353
00:17:53,714 --> 00:17:56,041
Now we know now that the left hand number

354
00:17:56,041 --> 00:17:58,621
is the external port, that's the port

355
00:17:58,621 --> 00:18:01,589
that's been entered in the browser,

356
00:18:01,589 --> 00:18:03,932
and this is getting forwarded

357
00:18:03,932 --> 00:18:08,393
to the internal port number
inside the container.

358
00:18:08,393 --> 00:18:11,055
Well, you're probably
not surprised to learn

359
00:18:11,055 --> 00:18:14,098
that we can use really any number here.

360
00:18:14,098 --> 00:18:18,113
I've just used a random
port number of 8161.

361
00:18:18,113 --> 00:18:19,497
And what this means is that although

362
00:18:19,497 --> 00:18:23,136
Tomcat internally will be running on 8080,

363
00:18:23,136 --> 00:18:27,303
the external published port
is now going to be 8161.

364
00:18:28,228 --> 00:18:29,478
Let's try that.

365
00:18:32,251 --> 00:18:36,581
So just to check, if we visit
the old port number of 8080,

366
00:18:36,581 --> 00:18:40,205
we know that Tomcat is
running on port 8080

367
00:18:40,205 --> 00:18:42,162
inside the container,

368
00:18:42,162 --> 00:18:45,164
but it's not visible to the browser.

369
00:18:45,164 --> 00:18:49,245
But if I change that to
8161, then wonderful!

370
00:18:49,245 --> 00:18:52,328
8161 is being forwarded to port 8080.

371
00:18:54,429 --> 00:18:56,913
So, the real important thing about this

372
00:18:56,913 --> 00:19:00,651
is that means if I do a Control+C,

373
00:19:00,651 --> 00:19:04,651
I'll repeat the process of
doing a docker container ls,

374
00:19:04,651 --> 00:19:09,516
and we'll do a docker container
stop on that container ID,

375
00:19:09,516 --> 00:19:11,266
for me, beginning 95,

376
00:19:12,731 --> 00:19:15,244
and then I'll go back to the run command.

377
00:19:15,244 --> 00:19:17,678
The really important aspect of this is

378
00:19:17,678 --> 00:19:19,595
if I didn't do that -p,

379
00:19:20,960 --> 00:19:24,104
then that port 8080 would not be exposed

380
00:19:24,104 --> 00:19:28,348
to the outside world, a very
important security measure.

381
00:19:28,348 --> 00:19:30,603
But it also means that we could
be a bit professional here.

382
00:19:30,603 --> 00:19:34,020
If we did a -p, and we forwarded ports 80

383
00:19:35,723 --> 00:19:37,556
to port 8080, then ...

384
00:19:43,058 --> 00:19:44,749
Then of course, we have the nice situation

385
00:19:44,749 --> 00:19:46,646
where we don't need a port number at all,

386
00:19:46,646 --> 00:19:48,896
because the default port 80

387
00:19:50,235 --> 00:19:55,197
is now automatically forwarding
to the internal port 8080.

388
00:19:55,197 --> 00:19:56,269
So that's quite nice.

389
00:19:56,269 --> 00:19:58,677
Well, going back to the
requirements for this exercise.

390
00:19:58,677 --> 00:20:02,411
The developer says if this looks okay,

391
00:20:02,411 --> 00:20:04,348
and I think it does, they want us

392
00:20:04,348 --> 00:20:07,405
to throw it onto an EC2 instance

393
00:20:07,405 --> 00:20:09,933
and then tell them the IP address.

394
00:20:09,933 --> 00:20:11,871
Now you don't need to
follow along with me here

395
00:20:11,871 --> 00:20:16,190
if you don't have easy
access to an EC2 instance.

396
00:20:16,190 --> 00:20:17,872
If you do want to follow along,

397
00:20:17,872 --> 00:20:19,630
and you've never used EC2 before,

398
00:20:19,630 --> 00:20:23,125
then I recommend the virtual
pair programmers course

399
00:20:23,125 --> 00:20:26,247
called Cloud Deployment with AWS,

400
00:20:26,247 --> 00:20:28,739
and we take you through
the basics of that.

401
00:20:28,739 --> 00:20:32,102
So I have here an EC2 instance
that I started up earlier.

402
00:20:32,102 --> 00:20:34,724
In fact, it's the one I use to demonstrate

403
00:20:34,724 --> 00:20:36,443
installing on Linux.

404
00:20:36,443 --> 00:20:38,693
So, we should find we have,

405
00:20:41,753 --> 00:20:44,113
just a quick test of the hello-world image

406
00:20:44,113 --> 00:20:46,808
shows that Docker's up and running okay.

407
00:20:46,808 --> 00:20:49,713
And really, the purpose of this exercise

408
00:20:49,713 --> 00:20:51,483
is just to show you that
even though we're now

409
00:20:51,483 --> 00:20:54,770
on quite a complicated cloud platform,

410
00:20:54,770 --> 00:20:58,022
the command is going to be identical.

411
00:20:58,022 --> 00:20:59,772
Docker container run.

412
00:21:00,630 --> 00:21:04,380
- p will do 80, being
forwarded to 8080 again.

413
00:21:05,943 --> 00:21:06,911
And the image name

414
00:21:06,911 --> 00:21:11,078
is virtualpairprogrammers/fleetman-webapp.

415
00:21:14,503 --> 00:21:15,958
Now you might be thinking, oh hang on,

416
00:21:15,958 --> 00:21:18,382
we haven't done a pull.

417
00:21:18,382 --> 00:21:20,882
Turns out, you actually
don't need to do a pull,

418
00:21:20,882 --> 00:21:23,415
because if we don't
have a copy of the image

419
00:21:23,415 --> 00:21:25,871
here on this machine,
it will automatically

420
00:21:25,871 --> 00:21:28,231
go into a pull anyway.

421
00:21:28,231 --> 00:21:30,888
So, if we run that command,

422
00:21:30,888 --> 00:21:32,636
yeah, you can see they're unable to find

423
00:21:32,636 --> 00:21:34,579
the image locally.

424
00:21:34,579 --> 00:21:36,672
It's now doing a download.

425
00:21:36,672 --> 00:21:39,260
It's a fairly sizeable download.

426
00:21:39,260 --> 00:21:40,473
Of course, it's having to download

427
00:21:40,473 --> 00:21:43,472
a Tomcat Java virtual machine,

428
00:21:43,472 --> 00:21:46,697
and the war file are
all part of this image,

429
00:21:46,697 --> 00:21:49,697
so there's quite a lot in the image.

430
00:21:51,313 --> 00:21:53,503
And we're now seeing what looks exactly

431
00:21:53,503 --> 00:21:56,253
the same login as we had locally.

432
00:21:57,945 --> 00:22:01,963
And I know that the IP
address of my EC2 instance

433
00:22:01,963 --> 00:22:04,539
is the IP address here, and we should now

434
00:22:04,539 --> 00:22:08,330
be able to simply visit that IP address.

435
00:22:08,330 --> 00:22:10,063
And if you're following along on EC2,

436
00:22:10,063 --> 00:22:12,562
you will need to make sure
that your security group

437
00:22:12,562 --> 00:22:16,630
for that instance allows
traffic from port 80.

438
00:22:16,630 --> 00:22:18,096
But you didn't need to follow along.

439
00:22:18,096 --> 00:22:20,260
I just wanted to
demonstrate that the process

440
00:22:20,260 --> 00:22:22,640
of deploying there was identical

441
00:22:22,640 --> 00:22:24,828
to the process of doing a local test,

442
00:22:24,828 --> 00:22:26,971
and that's the point of Docker.

443
00:22:26,971 --> 00:22:29,053
To make our development environments,

444
00:22:29,053 --> 00:22:32,918
really every environment
that we work in, identical

445
00:22:32,918 --> 00:22:34,926
with it just running containers,

446
00:22:34,926 --> 00:22:37,987
and the containers are
from the same images.

447
00:22:37,987 --> 00:22:39,414
This isn't quite professional yet,

448
00:22:39,414 --> 00:22:42,840
because we need to make this
some kind of a demon process,

449
00:22:42,840 --> 00:22:44,611
but I hope that little
exercise has given you

450
00:22:44,611 --> 00:22:47,666
a flavour for what Docker can do for us.

451
00:22:47,666 --> 00:22:48,989
Over the next few chapters, we're going

452
00:22:48,989 --> 00:22:52,295
to go into a little more
detail on what's going on here.

453
00:22:52,295 --> 00:22:53,677
And in particular, we're going to see how

454
00:22:53,677 --> 00:22:56,677
to make our own images from scratch.

455
00:22:57,571 --> 00:23:00,738
So, I'll see you in the next chapter.

1
00:00:00,864 --> 00:00:01,869
- [Instructor] Welcome back.

2
00:00:01,869 --> 00:00:05,202
We know that we can somehow build images

3
00:00:07,567 --> 00:00:09,249
which contain a definition

4
00:00:09,249 --> 00:00:11,851
of what we want a container to look like.

5
00:00:11,851 --> 00:00:16,813
So, an image can specify the
container needs to run Tomcat

6
00:00:16,813 --> 00:00:19,867
with a particular application deployed,

7
00:00:19,867 --> 00:00:23,778
and it's going to expose
port 8080 and so on.

8
00:00:23,778 --> 00:00:26,307
And we've seen the, well again,

9
00:00:26,307 --> 00:00:28,312
somehow, as if by magic,

10
00:00:28,312 --> 00:00:30,946
these images are magically transported

11
00:00:30,946 --> 00:00:34,405
from one developer's machine to another.

12
00:00:34,405 --> 00:00:37,519
Hopefully, you ran the Fleetman web app

13
00:00:37,519 --> 00:00:39,282
for yourself in the previous chapter

14
00:00:39,282 --> 00:00:43,449
and it just seamlessly downloaded
from the cloud somehow.

15
00:00:44,994 --> 00:00:47,443
In this chapter, we'll
be having a deeper look

16
00:00:47,443 --> 00:00:50,161
at images and how to manage them.

17
00:00:50,161 --> 00:00:51,789
And that's going to give us a change

18
00:00:51,789 --> 00:00:54,672
to acquire quite a few
more Docker commands,

19
00:00:54,672 --> 00:00:59,371
and we're going to finish
with short worked exercise.

20
00:00:59,371 --> 00:01:01,182
So, in the previous chapter,

21
00:01:01,182 --> 00:01:04,501
we ran the fleetman-webapp image.

22
00:01:04,501 --> 00:01:06,828
Now, I don't know what
state your environment

23
00:01:06,828 --> 00:01:09,868
is currently in, but actually,

24
00:01:09,868 --> 00:01:12,709
I'm just recording straight
after the previous chapter.

25
00:01:12,709 --> 00:01:17,276
So, my container is still
running here locally.

26
00:01:17,276 --> 00:01:20,779
And we've seen, if we do a Control C,

27
00:01:20,779 --> 00:01:23,529
if we do a "docker container ls",

28
00:01:26,043 --> 00:01:29,113
that container will continue to run,

29
00:01:29,113 --> 00:01:33,752
and we can stop the container
with "docker container stop"

30
00:01:33,752 --> 00:01:36,800
followed by the ID of that container,

31
00:01:36,800 --> 00:01:40,300
or at least enough of the ID to be unique.

32
00:01:41,988 --> 00:01:45,385
So, actually, I could just
do "docker container stop a"

33
00:01:45,385 --> 00:01:47,117
and it will stop that container.

34
00:01:47,117 --> 00:01:49,051
You might need to use
two or three characters

35
00:01:49,051 --> 00:01:50,551
to make it unique.

36
00:01:51,684 --> 00:01:53,815
The first thing I want to
address is where on earth did

37
00:01:53,815 --> 00:01:57,982
this
virtualpairprogrammers/fleetman-webapp
image come from?

38
00:01:59,912 --> 00:02:02,671
It should have just downloaded for you,

39
00:02:02,671 --> 00:02:05,231
but clearly what I've done,
in advance of this course,

40
00:02:05,231 --> 00:02:09,202
is I've published that image
and made it available to you.

41
00:02:09,202 --> 00:02:13,369
Well, the answer comes from a
website called the Docker Hub,

42
00:02:15,167 --> 00:02:19,000
and you'll find it at
the url, hub.docker.com.

43
00:02:20,875 --> 00:02:25,757
Now this is very much like
a Maven repository in Java.

44
00:02:25,757 --> 00:02:29,257
This website hosts Docker images publicly.

45
00:02:31,462 --> 00:02:34,587
And you'll find on this site
a collection of repositories,

46
00:02:34,587 --> 00:02:39,331
and each repository
contains a number of images.

47
00:02:39,331 --> 00:02:43,553
So, virtualpairprogrammers
has an account at Docker Hub,

48
00:02:43,553 --> 00:02:45,461
and at the time of recording,

49
00:02:45,461 --> 00:02:48,547
there'll probably be more
by the time you watch this,

50
00:02:48,547 --> 00:02:50,820
we've got eight or nine repositories

51
00:02:50,820 --> 00:02:53,088
available to the public.

52
00:02:53,088 --> 00:02:56,860
Each of these repositories
contains an image.

53
00:02:56,860 --> 00:02:58,720
So, there's the one right at the top

54
00:02:58,720 --> 00:03:00,612
that we've been dealing
with on the course,

55
00:03:00,612 --> 00:03:04,068
virtualpairprogrammers/fleetman-webapp

56
00:03:04,068 --> 00:03:06,839
and you can see there that it is public.

57
00:03:06,839 --> 00:03:08,699
Going a little further down,

58
00:03:08,699 --> 00:03:12,866
you can also have private
repositories on Docker Hub,

59
00:03:13,944 --> 00:03:15,846
and this is definitely what you would want

60
00:03:15,846 --> 00:03:19,444
if you were developing
commercial software internally,

61
00:03:19,444 --> 00:03:22,122
and you only wanted to publish your images

62
00:03:22,122 --> 00:03:24,128
within your organisation.

63
00:03:24,128 --> 00:03:28,845
Now, anybody can create
an account on Docker Hub,

64
00:03:28,845 --> 00:03:33,012
and it is free as long you only
want one private repository.

65
00:03:34,034 --> 00:03:36,603
If you want any more than
one private repository,

66
00:03:36,603 --> 00:03:39,526
then you have to start paying.

67
00:03:39,526 --> 00:03:41,943
Don't worry that this
is somehow locking you

68
00:03:41,943 --> 00:03:43,413
into the people behind Docker

69
00:03:43,413 --> 00:03:47,084
because you can also host
your own repositories,

70
00:03:47,084 --> 00:03:51,206
your own private repositories
on your own hardware,

71
00:03:51,206 --> 00:03:53,855
and that is really easy to do.

72
00:03:53,855 --> 00:03:56,342
And we'll be doing that
on this series of courses,

73
00:03:56,342 --> 00:03:58,941
but I don't think the
time is quite right yet

74
00:03:58,941 --> 00:04:01,690
so that will probably
be on the second module

75
00:04:01,690 --> 00:04:03,760
of this series.

76
00:04:03,760 --> 00:04:05,043
But for now, you can see

77
00:04:05,043 --> 00:04:07,548
that I'm publishing a series of images,

78
00:04:07,548 --> 00:04:10,646
most of them are in some way related

79
00:04:10,646 --> 00:04:13,080
to this Fleetman application,

80
00:04:13,080 --> 00:04:14,605
and the one we've been working with

81
00:04:14,605 --> 00:04:17,678
is this one here, fleetman-webapp.

82
00:04:17,678 --> 00:04:21,440
And we can see here there's
a description of the image

83
00:04:21,440 --> 00:04:23,606
and often on these images,

84
00:04:23,606 --> 00:04:25,608
the developers will give you details

85
00:04:25,608 --> 00:04:29,715
on how to run a container from that image.

86
00:04:29,715 --> 00:04:31,296
So we know now that by default,

87
00:04:31,296 --> 00:04:35,373
when you do a docker pull or a docker run,

88
00:04:35,373 --> 00:04:37,640
you don't actually have
to do a pull first,

89
00:04:37,640 --> 00:04:41,606
Docker knows to, by
default, automatically go

90
00:04:41,606 --> 00:04:46,444
to hub.docker.com to find
the corresponding image.

91
00:04:46,444 --> 00:04:49,494
There are thousands of images
available on Docker Hub,

92
00:04:49,494 --> 00:04:52,866
and they really serve two purposes.

93
00:04:52,866 --> 00:04:57,427
Some images are there just
so they can be distributed,

94
00:04:57,427 --> 00:05:00,352
made available to other developers.

95
00:05:00,352 --> 00:05:03,012
This fleetman-webapp is a good example.

96
00:05:03,012 --> 00:05:05,285
I put this image on Docker Hub

97
00:05:05,285 --> 00:05:09,248
just so that you, thousands
of miles away from me,

98
00:05:09,248 --> 00:05:11,504
can get easy access to it.

99
00:05:11,504 --> 00:05:13,963
I'm not really imaging that you would want

100
00:05:13,963 --> 00:05:16,796
to change this image particularly.

101
00:05:18,214 --> 00:05:20,357
And hopefully, that's worked well for you.

102
00:05:20,357 --> 00:05:22,603
But the other use of images is

103
00:05:22,603 --> 00:05:26,770
that anybody can take an image
and can extend that image.

104
00:05:28,820 --> 00:05:30,548
It's important to know that, actually,

105
00:05:30,548 --> 00:05:33,701
you can't modify any images,

106
00:05:33,701 --> 00:05:37,868
you can only extend it by
creating your own images

107
00:05:39,029 --> 00:05:41,446
based on the original images.

108
00:05:42,519 --> 00:05:44,880
Now, we'll be learning in the
next chapter how to do that,

109
00:05:44,880 --> 00:05:47,920
but for now, I just want
you to be aware that really,

110
00:05:47,920 --> 00:05:51,087
the main purpose of
many of these containers

111
00:05:51,087 --> 00:05:54,087
is just so you can extend from them.

112
00:05:55,162 --> 00:05:57,208
Let's run another example.

113
00:05:57,208 --> 00:06:01,050
You've been asked to
deploy a Java application

114
00:06:01,050 --> 00:06:02,946
into a container.

115
00:06:02,946 --> 00:06:05,774
But for some reason, I don't know why,

116
00:06:05,774 --> 00:06:08,662
the container must be based

117
00:06:08,662 --> 00:06:11,412
on the Ubuntu Linux distribution.

118
00:06:12,932 --> 00:06:14,931
How would you do that?

119
00:06:14,931 --> 00:06:17,510
Well, you would need to find a base image,

120
00:06:17,510 --> 00:06:19,427
an image to start from.

121
00:06:20,292 --> 00:06:24,158
And from that image, we could
run an Ubuntu container.

122
00:06:24,158 --> 00:06:27,115
Hmm, well, is there an
Ubuntu image available?

123
00:06:27,115 --> 00:06:29,451
Well, I hope so, let's go to Docker Hub.

124
00:06:29,451 --> 00:06:32,141
And you'll find a search box at the top

125
00:06:32,141 --> 00:06:35,141
and we can easily search for Ubuntu.

126
00:06:36,132 --> 00:06:38,799
And you can select that I've got

127
00:06:40,267 --> 00:06:43,100
27 thousand repositories returned.

128
00:06:44,713 --> 00:06:47,722
And I'm gonna scroll down
into the middle of the list

129
00:06:47,722 --> 00:06:51,169
and I'm going to pick a random one,

130
00:06:51,169 --> 00:06:54,157
this really genuinely is a random image.

131
00:06:54,157 --> 00:06:58,324
I'm gonna go for this one
here, pivotaldata/ubuntu,

132
00:06:59,907 --> 00:07:02,101
and I can see it's a pretty popular image

133
00:07:02,101 --> 00:07:05,194
because it's had more
than a million polls.

134
00:07:05,194 --> 00:07:07,820
So, if we have a click through

135
00:07:07,820 --> 00:07:09,461
to that and have a look at it,

136
00:07:09,461 --> 00:07:10,878
now, I haven't rehearsed this,

137
00:07:10,878 --> 00:07:14,231
so I really have no
idea what this image is

138
00:07:14,231 --> 00:07:16,020
or what it's for.

139
00:07:16,020 --> 00:07:17,775
And I must admit,

140
00:07:17,775 --> 00:07:20,396
the description doesn't really
give anything away here.

141
00:07:20,396 --> 00:07:22,008
But what we do know from here is

142
00:07:22,008 --> 00:07:26,367
that the owner of this image
is somebody called pivotaldata.

143
00:07:26,367 --> 00:07:28,363
I imagine it's related to Pivotal,

144
00:07:28,363 --> 00:07:32,689
who maintain and manage
the spring projects.

145
00:07:32,689 --> 00:07:35,343
And we also know the
owner from here, actually,

146
00:07:35,343 --> 00:07:37,074
it's just the first time
I've mentioned this,

147
00:07:37,074 --> 00:07:41,241
that the name of the
image is the owner/ubuntu,

148
00:07:43,754 --> 00:07:46,026
and we saw that with the
fleetman-webapp image,

149
00:07:46,026 --> 00:07:49,586
which was owned by me,
virtualpairprogrammers.

150
00:07:49,586 --> 00:07:52,179
So what we're seeing here
is some kind of an image

151
00:07:52,179 --> 00:07:54,613
that has been created by pivotaldata,

152
00:07:54,613 --> 00:07:58,702
and for whatever reason, they've
published it to Docker Hub

153
00:07:58,702 --> 00:08:01,914
so that we can take
that image and reuse it.

154
00:08:01,914 --> 00:08:04,286
I have no idea what this image represents

155
00:08:04,286 --> 00:08:07,639
and I guess I could look
in the GitHub repository

156
00:08:07,639 --> 00:08:11,303
to get an idea of what this image is for.

157
00:08:11,303 --> 00:08:12,780
We saw from the search results

158
00:08:12,780 --> 00:08:16,540
that really are, I mean
just 27 thousand images

159
00:08:16,540 --> 00:08:17,991
with the name Ubuntu in them,

160
00:08:17,991 --> 00:08:21,454
so there must be a scary
number of images available.

161
00:08:21,454 --> 00:08:23,230
And you've got to be very careful.

162
00:08:23,230 --> 00:08:25,258
If you do take this image and extend it

163
00:08:25,258 --> 00:08:27,626
and modify it for your own purposes,

164
00:08:27,626 --> 00:08:29,047
you've gotta be very careful

165
00:08:29,047 --> 00:08:31,266
to make sure that it's safe image;

166
00:08:31,266 --> 00:08:35,017
we don't know if this image
might not container malware

167
00:08:35,017 --> 00:08:36,407
or something like that.

168
00:08:36,407 --> 00:08:38,609
So, you want to inspect
the contents of this image

169
00:08:38,609 --> 00:08:41,648
and I'll be showing you how to
do that in the next chapter.

170
00:08:41,648 --> 00:08:43,779
But really, I'm not interested in that.

171
00:08:43,779 --> 00:08:46,998
What I am interested in if I
got to the top of the results,

172
00:08:46,998 --> 00:08:51,120
and there's one here with
10 million plus polls,

173
00:08:51,120 --> 00:08:53,723
and this one's just called ubuntu.

174
00:08:53,723 --> 00:08:55,913
So, this looks a bit unusual

175
00:08:55,913 --> 00:08:59,513
in that it doesn't have the
forward slash in front of it,

176
00:08:59,513 --> 00:09:02,511
and it's actually got a
tag here called Official.

177
00:09:02,511 --> 00:09:04,121
Now what's going on here is

178
00:09:04,121 --> 00:09:06,137
that there are a number of images

179
00:09:06,137 --> 00:09:10,066
which have been designed
by Docker themselves,

180
00:09:10,066 --> 00:09:12,198
and it is a full time team of people

181
00:09:12,198 --> 00:09:14,476
who are doing this for a living,

182
00:09:14,476 --> 00:09:16,932
and they create images
that they think are going

183
00:09:16,932 --> 00:09:19,200
to be globally useful.

184
00:09:19,200 --> 00:09:23,650
And you have a kind of reassurance
with the official images,

185
00:09:23,650 --> 00:09:26,802
that they've been fully
tested, and that they're safe,

186
00:09:26,802 --> 00:09:31,253
they don't contain malware
or viruses, and so on.

187
00:09:31,253 --> 00:09:33,814
So, usually, given the scenario

188
00:09:33,814 --> 00:09:38,582
where we need to create
an Ubunto-based container,

189
00:09:38,582 --> 00:09:42,749
I would suggest that this
official image here, ubuntu,

190
00:09:44,157 --> 00:09:47,010
is the one that we
would want to work from.

191
00:09:47,010 --> 00:09:48,895
So, we've got the command here,

192
00:09:48,895 --> 00:09:50,739
we can do a docker pull ubuntu,

193
00:09:50,739 --> 00:09:53,576
and that will download it
into our own environment.

194
00:09:53,576 --> 00:09:56,434
And then we can either use that image

195
00:09:56,434 --> 00:09:58,360
and run a container from it,

196
00:09:58,360 --> 00:10:01,410
or more likely, we can extend it.

197
00:10:01,410 --> 00:10:03,356
So what we could do
once we have that image

198
00:10:03,356 --> 00:10:05,832
is we could build on that base image,

199
00:10:05,832 --> 00:10:07,594
we could add on another layer,

200
00:10:07,594 --> 00:10:09,667
which would mean creating a new image

201
00:10:09,667 --> 00:10:12,000
from that base Ubuntu image,

202
00:10:12,865 --> 00:10:17,722
which adds on our own layer,
perhaps containing Java 8.

203
00:10:17,722 --> 00:10:19,737
Now notice I've said create a new image

204
00:10:19,737 --> 00:10:22,164
because images cannot be modified,

205
00:10:22,164 --> 00:10:24,996
so we will be creating a new image.

206
00:10:24,996 --> 00:10:28,325
Once we've got an image
with Ubuntu and Java,

207
00:10:28,325 --> 00:10:31,903
we also want our application
to be part of that image

208
00:10:31,903 --> 00:10:34,282
so we would repeat the process.

209
00:10:34,282 --> 00:10:38,900
We'd create a new image
based on the previous image,

210
00:10:38,900 --> 00:10:41,400
which adds on the application.

211
00:10:42,434 --> 00:10:45,998
So we'd end up with our
own image containing Ubuntu

212
00:10:45,998 --> 00:10:48,615
and Java, and our application,

213
00:10:48,615 --> 00:10:52,421
and we could now run that as a container.

214
00:10:52,421 --> 00:10:54,940
So, we will be doing all of
that in the next chapter.

215
00:10:54,940 --> 00:10:56,906
But for now, I just want to show you

216
00:10:56,906 --> 00:10:59,571
how we would get access
to this base layer.

217
00:10:59,571 --> 00:11:03,392
In our example, the Ubuntu base layer.

218
00:11:03,392 --> 00:11:05,415
Well actually, we've see
the command to do this

219
00:11:05,415 --> 00:11:07,097
in the previous chapters.

220
00:11:07,097 --> 00:11:09,680
There is a docker pull command,

221
00:11:11,032 --> 00:11:14,762
which will pull any image from Docker Hub.

222
00:11:14,762 --> 00:11:16,837
So let's do that, we can
copy that command verbatim,

223
00:11:16,837 --> 00:11:19,337
which is "docker pull ubuntu",

224
00:11:22,388 --> 00:11:26,961
and as usual, you should see
there's some kind of a download

225
00:11:26,961 --> 00:11:30,141
and that shouldn't take
too long to complete.

226
00:11:30,141 --> 00:11:32,419
So now, I have a copy of this image

227
00:11:32,419 --> 00:11:35,086
on my local development machine.

228
00:11:35,982 --> 00:11:37,399
Now before we go any further,

229
00:11:37,399 --> 00:11:39,471
I just want to talk
about a slight confusion

230
00:11:39,471 --> 00:11:41,343
with the Docker commands.

231
00:11:41,343 --> 00:11:42,926
You might remember,

232
00:11:43,881 --> 00:11:47,236
and you can verify from the PDF document

233
00:11:47,236 --> 00:11:50,068
that you can download
as part of this course,

234
00:11:50,068 --> 00:11:52,561
where I've given you a
list of Docker commands,

235
00:11:52,561 --> 00:11:54,090
that in the previous chapters,

236
00:11:54,090 --> 00:11:57,067
we actually did a
slightly different command

237
00:11:57,067 --> 00:12:00,150
which was "docker image pull ubuntu".

238
00:12:04,652 --> 00:12:06,251
Now this is not going to have any effect

239
00:12:06,251 --> 00:12:08,024
because we've already done the pull,

240
00:12:08,024 --> 00:12:11,221
but I hope you can see that
the effect of that command

241
00:12:11,221 --> 00:12:13,304
is exactly the same.

242
00:12:13,304 --> 00:12:14,950
Now, what's going on here is

243
00:12:14,950 --> 00:12:17,651
there's really two styles
of Docker commands,

244
00:12:17,651 --> 00:12:19,728
and I call them the classic commands,

245
00:12:19,728 --> 00:12:21,830
and the modern commands.

246
00:12:21,830 --> 00:12:24,919
And the reason for this duplication is

247
00:12:24,919 --> 00:12:26,833
that not long ago, in fact,

248
00:12:26,833 --> 00:12:30,030
not very long before I
started writing this course,

249
00:12:30,030 --> 00:12:33,227
the Docker team made a reorganisation

250
00:12:33,227 --> 00:12:34,785
of the Docker commands.

251
00:12:34,785 --> 00:12:36,332
And I think the reason was really

252
00:12:36,332 --> 00:12:39,529
that Docker was starting to
get a little bit unwieldy.

253
00:12:39,529 --> 00:12:42,078
The classic way of working,

254
00:12:42,078 --> 00:12:44,168
the original of working with Docker,

255
00:12:44,168 --> 00:12:47,918
was that every way Docker
command was docker,

256
00:12:49,215 --> 00:12:52,947
followed by some command like pull,

257
00:12:52,947 --> 00:12:57,773
followed by whatever parameters
are needed for that command.

258
00:12:57,773 --> 00:12:59,353
But the problem with that was

259
00:12:59,353 --> 00:13:01,631
as Docker got bigger,
and bigger, and bigger,

260
00:13:01,631 --> 00:13:04,410
and there were more areas added to Docker,

261
00:13:04,410 --> 00:13:07,983
the list of commands started
to get very unwieldy.

262
00:13:07,983 --> 00:13:11,149
And there was also a lot
of duplication going on.

263
00:13:11,149 --> 00:13:15,705
For example, there is a command
to allow you to list all

264
00:13:15,705 --> 00:13:19,872
of the images that you have
in your development area.

265
00:13:20,773 --> 00:13:22,629
But there's also a command to allow you

266
00:13:22,629 --> 00:13:27,289
to list all of the containers
that you have running.

267
00:13:27,289 --> 00:13:29,560
So they had a real problem
in that they had to come up

268
00:13:29,560 --> 00:13:32,729
with separate names for the command

269
00:13:32,729 --> 00:13:36,156
to list containers and the
command to list images.

270
00:13:36,156 --> 00:13:38,010
Somewhat confusingly, the commands

271
00:13:38,010 --> 00:13:41,843
to list your running
containers was docker ps,

272
00:13:42,867 --> 00:13:45,870
which really means docker processes.

273
00:13:45,870 --> 00:13:47,437
Now that's quite confusing,

274
00:13:47,437 --> 00:13:50,255
I mentioned very briefly
earlier on in the course

275
00:13:50,255 --> 00:13:54,230
that a Docker container
is actually just a process

276
00:13:54,230 --> 00:13:55,944
on your Linux kernel.

277
00:13:55,944 --> 00:13:58,500
So that's why they went for the command ps

278
00:13:58,500 --> 00:13:59,963
to list your containers.

279
00:13:59,963 --> 00:14:02,318
But it's not really very intuitive

280
00:14:02,318 --> 00:14:03,671
because clearly, what you want to do

281
00:14:03,671 --> 00:14:06,220
is you want to do a list.

282
00:14:06,220 --> 00:14:09,513
Now, I don't have any
running containers right now.

283
00:14:09,513 --> 00:14:11,966
I don't know what state
your environment's in,

284
00:14:11,966 --> 00:14:15,299
but what you can do is do a docker ps -a

285
00:14:16,561 --> 00:14:18,676
to list all of your containers,

286
00:14:18,676 --> 00:14:21,351
even if they've been stopped.

287
00:14:21,351 --> 00:14:25,070
You can see that these
exited some time ago.

288
00:14:25,070 --> 00:14:29,533
So, this style of just
docker followed by a command

289
00:14:29,533 --> 00:14:31,800
has now been replaced.

290
00:14:31,800 --> 00:14:35,224
The old commands are still
valid, at least for now.

291
00:14:35,224 --> 00:14:38,536
I imagine they might possibly
remove these commands

292
00:14:38,536 --> 00:14:40,483
at some point in the future.

293
00:14:40,483 --> 00:14:43,299
What we should do instead is,

294
00:14:43,299 --> 00:14:45,990
really as we've been
doing through the course,

295
00:14:45,990 --> 00:14:50,562
and that's docker followed
by what are you dealing with?

296
00:14:50,562 --> 00:14:52,578
Are you dealing with a container?

297
00:14:52,578 --> 00:14:55,076
Or are you dealing with an image?

298
00:14:55,076 --> 00:14:56,951
And we'll see there's more than containers

299
00:14:56,951 --> 00:14:59,178
and images later in the course.

300
00:14:59,178 --> 00:15:01,392
So now, the command for listing containers

301
00:15:01,392 --> 00:15:03,975
would be "docker container ls",

302
00:15:05,039 --> 00:15:08,101
well, I think we've actually
seen that command already.

303
00:15:08,101 --> 00:15:11,995
It is exactly the same
as the old docker ps.

304
00:15:11,995 --> 00:15:16,054
So we could do "docker container ls -a"

305
00:15:16,054 --> 00:15:18,185
and the results are the same.

306
00:15:18,185 --> 00:15:22,956
We can probably guess now that
to list all of our images,

307
00:15:22,956 --> 00:15:25,289
we can do "docker image ls",

308
00:15:28,630 --> 00:15:31,104
and you'll probably have the same as me,

309
00:15:31,104 --> 00:15:34,242
our fleetman-webapp, the
Ubuntu that we just pulled,

310
00:15:34,242 --> 00:15:38,390
and the hello-world that
we used for testing.

311
00:15:38,390 --> 00:15:40,005
So you might be a bit confused by that,

312
00:15:40,005 --> 00:15:42,925
there's a kind of a
parallel set of commands.

313
00:15:42,925 --> 00:15:46,724
I strongly recommend you use
the modern form from now on,

314
00:15:46,724 --> 00:15:49,672
docker container, or docker image,

315
00:15:49,672 --> 00:15:52,464
but you will find tutorials, and possibly,

316
00:15:52,464 --> 00:15:54,136
if you have some colleagues

317
00:15:54,136 --> 00:15:56,090
who have been using
Docker for a long time,

318
00:15:56,090 --> 00:15:59,319
then they might still be
using the old commands.

319
00:15:59,319 --> 00:16:01,365
I guess the time is right now to show you

320
00:16:01,365 --> 00:16:04,199
that of course there
is a help with Docker.

321
00:16:04,199 --> 00:16:08,019
You will get a complete
list of all of the commands.

322
00:16:08,019 --> 00:16:09,774
But you'll see that under here,

323
00:16:09,774 --> 00:16:13,003
there's a set of management commands,

324
00:16:13,003 --> 00:16:14,999
and actually, that's
what we're dealing with

325
00:16:14,999 --> 00:16:17,371
with that second word in the command line.

326
00:16:17,371 --> 00:16:21,713
We say docker container
to manage containers,

327
00:16:21,713 --> 00:16:24,213
docker image to manage images.

328
00:16:25,282 --> 00:16:26,505
But we'll be looking at some

329
00:16:26,505 --> 00:16:29,429
of these other management
commands later on in the course.

330
00:16:29,429 --> 00:16:32,773
These commands down here
are those classic commands

331
00:16:32,773 --> 00:16:34,707
that I was telling you about before,

332
00:16:34,707 --> 00:16:38,373
the old ps there to list containers.

333
00:16:38,373 --> 00:16:41,195
I would hope at some point in the future,

334
00:16:41,195 --> 00:16:45,514
they'll remove these commands
because it is quite confusing.

335
00:16:45,514 --> 00:16:48,961
If you want help on what's
available for containers,

336
00:16:48,961 --> 00:16:53,346
for example, we can say
"docker container --help",

337
00:16:53,346 --> 00:16:55,203
and there's the list of all the things

338
00:16:55,203 --> 00:16:57,862
we can do with a container.

339
00:16:57,862 --> 00:17:02,029
And similarly, we'll be able
to do "docker image --help"

340
00:17:03,901 --> 00:17:05,479
and there's a small number of jobs

341
00:17:05,479 --> 00:17:08,059
that we can do with images.

342
00:17:08,059 --> 00:17:09,826
Okay, so that was a little
bit of a digression,

343
00:17:09,826 --> 00:17:12,927
but the important thing we've
done is we've just done a pull

344
00:17:12,927 --> 00:17:16,510
and we have got ourselves
the Ubuntu image.

345
00:17:17,505 --> 00:17:21,399
So, the next questions is how
do we run that as a container?

346
00:17:21,399 --> 00:17:23,613
Well, we've seen the command already.

347
00:17:23,613 --> 00:17:26,335
We can do "docker container run",

348
00:17:26,335 --> 00:17:30,650
followed by the name of the
image that we're running.

349
00:17:30,650 --> 00:17:32,607
Previously, when we ran a container,

350
00:17:32,607 --> 00:17:35,951
we did publishing of port, that
won't be necessary this time

351
00:17:35,951 --> 00:17:38,699
because Ubuntu isn't a server.

352
00:17:38,699 --> 00:17:41,280
So we don't need to open
any particular ports.

353
00:17:41,280 --> 00:17:45,716
Now, we're going to find
when we run this command,

354
00:17:45,716 --> 00:17:48,331
apparently, nothing happened.

355
00:17:48,331 --> 00:17:49,900
And I guess we can confirm that

356
00:17:49,900 --> 00:17:53,338
by doing a "docker container ls".

357
00:17:53,338 --> 00:17:56,217
As you can see, we have
no containers running.

358
00:17:56,217 --> 00:17:57,841
So what's going on here?

359
00:17:57,841 --> 00:18:02,658
Well, we might have a clue
if we do a "container ls -a"

360
00:18:02,658 --> 00:18:06,347
which you know by now shows
all of the containers,

361
00:18:06,347 --> 00:18:09,696
even the ones that have
stopped and exited.

362
00:18:09,696 --> 00:18:14,028
And can you see that here
we did have a container?

363
00:18:14,028 --> 00:18:16,066
This one beginning c3,

364
00:18:16,066 --> 00:18:18,874
and it was created 19 seconds ago

365
00:18:18,874 --> 00:18:21,291
but it exited 18 seconds ago.

366
00:18:22,542 --> 00:18:25,319
Well, what's going on here is
that every single container,

367
00:18:25,319 --> 00:18:28,160
when it's started, will run a command.

368
00:18:28,160 --> 00:18:32,327
And your container will exist
and will live and survive

369
00:18:34,179 --> 00:18:37,868
for as long as that command is running.

370
00:18:37,868 --> 00:18:42,184
If we can have a look at the
old fleetman-webapp container

371
00:18:42,184 --> 00:18:44,502
that we started some time ago,

372
00:18:44,502 --> 00:18:48,506
the command for that
was "catalina.sh run".

373
00:18:48,506 --> 00:18:50,148
If you know about Tomcat, then you'll know

374
00:18:50,148 --> 00:18:54,315
that that is the command to
run Tomcat just as a command,

375
00:18:55,340 --> 00:18:59,772
and it will run forever,
basically, until you kill it.

376
00:18:59,772 --> 00:19:04,160
So therefore, that's why the
fleetman-webapp container,

377
00:19:04,160 --> 00:19:07,679
once we've started it, continued running.

378
00:19:07,679 --> 00:19:09,479
Well, the problem with
the Ubuntu container

379
00:19:09,479 --> 00:19:12,540
is it's running the command called bash.

380
00:19:12,540 --> 00:19:14,765
Now, you might be familiar with bash,

381
00:19:14,765 --> 00:19:17,002
it's the shell, it's one
of the shells available

382
00:19:17,002 --> 00:19:18,835
on Linux environments.

383
00:19:19,777 --> 00:19:21,449
The problem with bash is

384
00:19:21,449 --> 00:19:23,291
if it's not connected to a terminal,

385
00:19:23,291 --> 00:19:26,875
when bash is used, it's just
going to be running script.

386
00:19:26,875 --> 00:19:31,815
And if there's not script there,
it just immediately exits.

387
00:19:31,815 --> 00:19:33,772
So, this gives me a chance to show you

388
00:19:33,772 --> 00:19:36,309
some more command line arguments.

389
00:19:36,309 --> 00:19:39,780
If we recall the command to run Ubuntu,

390
00:19:39,780 --> 00:19:43,245
we can add on to to that command line -it,

391
00:19:43,245 --> 00:19:45,146
that's actually two commands.

392
00:19:45,146 --> 00:19:49,525
It's just shortened really
for saying -i and -t.

393
00:19:49,525 --> 00:19:50,794
So you'll hear people saying

394
00:19:50,794 --> 00:19:53,312
this is the interactive command.

395
00:19:53,312 --> 00:19:57,051
Actually, it's two commands;
the -i means interactive

396
00:19:57,051 --> 00:20:01,571
and the t means, "Connect
the container to a terminal,"

397
00:20:01,571 --> 00:20:04,268
with a little bit of detail
that we don't really need.

398
00:20:04,268 --> 00:20:06,410
But, just think of -it as being,

399
00:20:06,410 --> 00:20:09,357
"We're running this
container interactively."

400
00:20:09,357 --> 00:20:12,322
And the results of it is you can see there

401
00:20:12,322 --> 00:20:15,779
that it's dropping me onto a command line.

402
00:20:15,779 --> 00:20:18,312
And you can see from the prompt,

403
00:20:18,312 --> 00:20:19,837
I hope you can see from the prompt,

404
00:20:19,837 --> 00:20:23,271
that this is a different
prompt to the one I had before.

405
00:20:23,271 --> 00:20:25,140
I was on a Windows command line,

406
00:20:25,140 --> 00:20:28,416
but now I'm on some kind
of a UNIX command line,

407
00:20:28,416 --> 00:20:31,718
and I am in fact in a bash shell

408
00:20:31,718 --> 00:20:34,414
inside that Docker container.

409
00:20:34,414 --> 00:20:37,871
So, I can now start doing UNIX commands,

410
00:20:37,871 --> 00:20:39,605
I can do an ls there.

411
00:20:39,605 --> 00:20:42,637
The colours aren't flashing
there, but I hope you can see

412
00:20:42,637 --> 00:20:47,611
that there is a UNIX Linux
style file system right there.

413
00:20:47,611 --> 00:20:49,020
And you might be wondering,

414
00:20:49,020 --> 00:20:51,414
"Well, what can we do
inside this container?"

415
00:20:51,414 --> 00:20:54,204
And there're several
answers to that question.

416
00:20:54,204 --> 00:20:57,198
The first answer is really,
you can do everything in here

417
00:20:57,198 --> 00:21:00,536
that you could do in any
other Linux environment.

418
00:21:00,536 --> 00:21:02,783
Let's have a little play around in here.

419
00:21:02,783 --> 00:21:05,562
I'm fairly certain that if we were

420
00:21:05,562 --> 00:21:07,286
to try to run something like Git,

421
00:21:07,286 --> 00:21:09,710
that would not be installed by default.

422
00:21:09,710 --> 00:21:11,988
But we can very easily instal it.

423
00:21:11,988 --> 00:21:15,353
We can use the standard
package manager for Ubuntu,

424
00:21:15,353 --> 00:21:17,461
which is apt-get.

425
00:21:17,461 --> 00:21:20,870
And the usual thing to
do is an apt-get update

426
00:21:20,870 --> 00:21:23,302
followed by double ampersands,

427
00:21:23,302 --> 00:21:27,469
and then an "apt-get instal"
and we'll instal Git.

428
00:21:29,313 --> 00:21:33,636
And I'll need to confirm
the installation with a y.

429
00:21:33,636 --> 00:21:37,053
I could have done -y on the command line.

430
00:21:38,873 --> 00:21:42,604
And great, we now have Git
available inside this container,

431
00:21:42,604 --> 00:21:45,759
which was quite good fun, I suppose.

432
00:21:45,759 --> 00:21:49,716
But the question was, "What
can we do with this container?"

433
00:21:49,716 --> 00:21:52,969
And the other answer, really, is not much.

434
00:21:52,969 --> 00:21:55,469
As soon as we do an exit here,

435
00:21:56,626 --> 00:21:58,570
that will now mean that the bash command,

436
00:21:58,570 --> 00:22:02,833
the command that this container
was running, has now exited.

437
00:22:02,833 --> 00:22:07,000
So, I think you'll find, if
we do a "docker container ls",

438
00:22:08,042 --> 00:22:11,047
yeah, we have no running containers.

439
00:22:11,047 --> 00:22:13,466
We can do an ls -a to confirm

440
00:22:13,466 --> 00:22:16,966
that that container exited 17 seconds ago.

441
00:22:18,814 --> 00:22:21,564
So, if I were to, let's recall...

442
00:22:23,222 --> 00:22:27,175
The docker container
run -it ubuntu command,

443
00:22:27,175 --> 00:22:30,570
and I did git again, well,
we have a new container now.

444
00:22:30,570 --> 00:22:33,151
It's a new container
formed from the same image,

445
00:22:33,151 --> 00:22:36,784
but we're back to exactly
the same point as we were.

446
00:22:36,784 --> 00:22:39,521
So what's the purpose of this Ubuntu image

447
00:22:39,521 --> 00:22:42,514
if we can't really do very much with it?

448
00:22:42,514 --> 00:22:45,282
Well, I've already said,
but I want to reemphasize,

449
00:22:45,282 --> 00:22:46,880
the points of all this is

450
00:22:46,880 --> 00:22:49,337
that we would take that Ubuntu image

451
00:22:49,337 --> 00:22:53,337
and we would create our
own image based upon it,

452
00:22:54,394 --> 00:22:58,540
and we would add our own extra
layers, as they're called.

453
00:22:58,540 --> 00:23:00,755
We might want to add in something

454
00:23:00,755 --> 00:23:03,449
like a Java Virtual Machine.

455
00:23:03,449 --> 00:23:06,055
We're going to be doing
that in the next chapter.

456
00:23:06,055 --> 00:23:07,351
But I wanted to play around

457
00:23:07,351 --> 00:23:09,200
with the command line a little bit,

458
00:23:09,200 --> 00:23:12,708
and I wanted to show you how
we can take an existing image

459
00:23:12,708 --> 00:23:15,052
and play around with it a little bit,

460
00:23:15,052 --> 00:23:17,691
such as running a bash shell inside it.

461
00:23:17,691 --> 00:23:21,530
So I'm inside that new
Linux container right now,

462
00:23:21,530 --> 00:23:23,354
let's exit back out of that.

463
00:23:23,354 --> 00:23:25,884
To end this chapter,
let's have a quick look

464
00:23:25,884 --> 00:23:28,604
at container life cycles.

465
00:23:28,604 --> 00:23:32,418
Up until now, we have been
running our Fleetman container

466
00:23:32,418 --> 00:23:34,581
by using docker container run,

467
00:23:34,581 --> 00:23:39,221
we've been publishing a
port, and we'll do 80:8080,

468
00:23:39,221 --> 00:23:43,076
and we've been running fleetman-webapp,

469
00:23:43,076 --> 00:23:47,243
or I should remember
virtualpairprogrammers/fleetman-webapp.

470
00:23:50,400 --> 00:23:54,120
And you know that that
runs that container,

471
00:23:54,120 --> 00:23:58,287
but is also outputting the
log directly to the console.

472
00:23:59,535 --> 00:24:02,178
And we can check that's
running on local host.

473
00:24:02,178 --> 00:24:05,310
Remember, if you're running
on the Docker Toolbox,

474
00:24:05,310 --> 00:24:07,977
you will need to do a Docker Machine IP

475
00:24:07,977 --> 00:24:11,091
to find the IP address
of your virtual machine.

476
00:24:11,091 --> 00:24:13,344
You know that if we press Control C,

477
00:24:13,344 --> 00:24:15,386
that container will continue to run

478
00:24:15,386 --> 00:24:19,565
and we can verify that now
with a "docker container ls",

479
00:24:19,565 --> 00:24:21,034
and there's the container,

480
00:24:21,034 --> 00:24:23,766
just been running for
me for about a minute.

481
00:24:23,766 --> 00:24:25,309
And as a double check,

482
00:24:25,309 --> 00:24:28,967
we can safely refresh the application.

483
00:24:28,967 --> 00:24:30,482
But you know now that the reason

484
00:24:30,482 --> 00:24:33,609
that this container continues
to exist is that this command,

485
00:24:33,609 --> 00:24:38,373
catalina.sh is a long-running
command, it will never exit,

486
00:24:38,373 --> 00:24:41,234
but we can stop the container at any time

487
00:24:41,234 --> 00:24:43,817
with a "docker container stop",

488
00:24:46,104 --> 00:24:48,233
followed by the ID of that container.

489
00:24:48,233 --> 00:24:51,952
And as usual, I'll just do
the first two characters.

490
00:24:51,952 --> 00:24:54,241
And going back to the web
app, we now do a refresh,

491
00:24:54,241 --> 00:24:56,803
yes the application's gone away.

492
00:24:56,803 --> 00:25:00,199
If we now do a "docker container ls",

493
00:25:00,199 --> 00:25:04,232
you'll find that the
container is no longer listed.

494
00:25:04,232 --> 00:25:07,552
But as you know, we can do a -a on the ls

495
00:25:07,552 --> 00:25:10,029
and that will show as
all of the containers,

496
00:25:10,029 --> 00:25:12,119
even if they stopped.

497
00:25:12,119 --> 00:25:14,925
So, it's this one here
at the top of the list

498
00:25:14,925 --> 00:25:17,542
which exited 24 seconds ago.

499
00:25:17,542 --> 00:25:21,606
It's absolutely fine to
restart a stopped container.

500
00:25:21,606 --> 00:25:24,523
We can do "docker container start",

501
00:25:25,463 --> 00:25:29,637
followed by the ID of the
container that we're starting.

502
00:25:29,637 --> 00:25:31,224
The difference this time is

503
00:25:31,224 --> 00:25:33,138
this is going to run in the background,

504
00:25:33,138 --> 00:25:36,002
we're not seeing any
further logging appearing

505
00:25:36,002 --> 00:25:38,835
on the console, but I can confirm.

506
00:25:41,334 --> 00:25:45,084
Yeah, our application
is back up and running.

507
00:25:46,506 --> 00:25:49,498
I could have restarted any
of the earlier containers

508
00:25:49,498 --> 00:25:51,378
that we worked with before.

509
00:25:51,378 --> 00:25:53,751
Now, a stopped container
won't do any harm,

510
00:25:53,751 --> 00:25:56,123
but it is going to be
eating some resources,

511
00:25:56,123 --> 00:25:57,690
in particular, memory.

512
00:25:57,690 --> 00:26:02,121
So, it's absolutely fine to
remove stopped containers,

513
00:26:02,121 --> 00:26:05,941
and we could do that with
a "docker container rn",

514
00:26:05,941 --> 00:26:07,282
and I'll pick any of them,

515
00:26:07,282 --> 00:26:10,782
let's go for this one here beginning a7...

516
00:26:11,991 --> 00:26:15,408
and there it is, if we do an ls -a again,

517
00:26:16,296 --> 00:26:18,359
we can see now that container's gone away.

518
00:26:18,359 --> 00:26:20,397
You will find when
you're working in Docker

519
00:26:20,397 --> 00:26:22,570
that it's very easy to
start the containers

520
00:26:22,570 --> 00:26:25,178
and then abandon them
and forget about them

521
00:26:25,178 --> 00:26:28,030
and leave them in this stopped state.

522
00:26:28,030 --> 00:26:29,839
And it's quite common to end it

523
00:26:29,839 --> 00:26:33,789
with great big long lists
of stopped containers.

524
00:26:33,789 --> 00:26:36,794
So, quite recently in Docker,

525
00:26:36,794 --> 00:26:41,479
there is now a command called
docker container prune,

526
00:26:41,479 --> 00:26:44,114
and you will get a
warning when you run this.

527
00:26:44,114 --> 00:26:47,342
As it says, it "will remove
all stopped containers,

528
00:26:47,342 --> 00:26:48,502
"are you sure?"

529
00:26:48,502 --> 00:26:50,808
And if you are, go ahead,

530
00:26:50,808 --> 00:26:53,800
and you will get some memory reclaimed.

531
00:26:53,800 --> 00:26:57,307
We can now do, let's repeat the ls -a

532
00:26:57,307 --> 00:26:58,711
and you can see now we just have

533
00:26:58,711 --> 00:27:01,454
our running container returned.

534
00:27:01,454 --> 00:27:03,810
One more thing I'd like to show you,

535
00:27:03,810 --> 00:27:06,810
if we stop the container, a1 for me,

536
00:27:08,594 --> 00:27:11,740
and actually, I'll repeat the prune

537
00:27:11,740 --> 00:27:15,032
to get rid of that stopped container.

538
00:27:15,032 --> 00:27:17,913
Every time we've been running
the Fleetman container,

539
00:27:17,913 --> 00:27:21,406
it's been outputting the
log directly to the console

540
00:27:21,406 --> 00:27:25,312
and we've had to do that rather
annoying Control C business.

541
00:27:25,312 --> 00:27:26,992
But there is a switch we can add

542
00:27:26,992 --> 00:27:29,924
into the command, which is -d.

543
00:27:29,924 --> 00:27:32,206
You'll hear some people say that's

544
00:27:32,206 --> 00:27:33,857
"Run this container as a daemon."

545
00:27:33,857 --> 00:27:38,024
Actually, formally, in the
documentation, -d means detached,

546
00:27:40,221 --> 00:27:42,791
which just means really it
runs it in the background.

547
00:27:42,791 --> 00:27:46,144
It won't attach the output to our terminal

548
00:27:46,144 --> 00:27:50,280
so we can't see what's
happening inside that container.

549
00:27:50,280 --> 00:27:52,547
And oftentimes, that's what you want.

550
00:27:52,547 --> 00:27:55,973
You just want to run the
container and away it goes.

551
00:27:55,973 --> 00:27:58,015
Now, we know that this container takes

552
00:27:58,015 --> 00:28:00,182
about 30 seconds to start,

553
00:28:01,025 --> 00:28:04,128
so don't be too hasty, but
if you give it long enough,

554
00:28:04,128 --> 00:28:06,688
you should find that quite soon,

555
00:28:06,688 --> 00:28:08,715
you're able to refresh your webpage

556
00:28:08,715 --> 00:28:11,535
and get some tracking data.

557
00:28:11,535 --> 00:28:13,662
Couple more things I'd like to show you.

558
00:28:13,662 --> 00:28:17,573
We have a container running
but we can't see its output.

559
00:28:17,573 --> 00:28:19,044
So how do we do that?

560
00:28:19,044 --> 00:28:21,910
And this is something I
need to do very frequently,

561
00:28:21,910 --> 00:28:25,396
we'll be doing this a lot on this course

562
00:28:25,396 --> 00:28:27,165
and definitely in the next module.

563
00:28:27,165 --> 00:28:30,494
We can look at the
output for any container

564
00:28:30,494 --> 00:28:33,161
by doing "docker container logs"

565
00:28:37,318 --> 00:28:40,560
followed by the ID of the
container that you're logging.

566
00:28:40,560 --> 00:28:42,891
Well, we know that the
ID of this container

567
00:28:42,891 --> 00:28:45,859
was this long string beginning ee,

568
00:28:45,859 --> 00:28:49,756
so if I just do "docker
container logs ee" for me,

569
00:28:49,756 --> 00:28:53,288
they've got the console
output for that container.

570
00:28:53,288 --> 00:28:56,642
And actually, what you're seeing
here is not the Tomcat log,

571
00:28:56,642 --> 00:29:00,079
it's just verbatim what that console

572
00:29:00,079 --> 00:29:03,023
is outputting to system.out

573
00:29:03,023 --> 00:29:06,102
and that will become relevant
a bit later on in the course.

574
00:29:06,102 --> 00:29:08,321
If you want to monitor a log,

575
00:29:08,321 --> 00:29:12,488
then exactly as you can do in
Linux, if you do a logs -f,

576
00:29:14,044 --> 00:29:17,959
that will allow you to follow that log

577
00:29:17,959 --> 00:29:20,658
and this log isn't doing anything
interesting at the moment

578
00:29:20,658 --> 00:29:23,061
but if there was further
logging appearing on there,

579
00:29:23,061 --> 00:29:26,258
then we would be able to
watch that interactively.

580
00:29:26,258 --> 00:29:28,128
If I do a Control C here,

581
00:29:28,128 --> 00:29:31,577
then the container will continue to run.

582
00:29:31,577 --> 00:29:33,416
And the final thing I'd
like to show you is,

583
00:29:33,416 --> 00:29:36,666
this is a common question, how do we...

584
00:29:37,985 --> 00:29:41,019
do the equivalence of an
ssh into that container?

585
00:29:41,019 --> 00:29:43,473
And we might want to do
that to do some debugging

586
00:29:43,473 --> 00:29:48,309
or to check if a particular is
installed in that container.

587
00:29:48,309 --> 00:29:50,455
There are a lot of reasons
why we would want to do that.

588
00:29:50,455 --> 00:29:54,122
And the answer is you
do not need to do ssh.

589
00:29:55,042 --> 00:29:57,260
I have seen people trained to do that

590
00:29:57,260 --> 00:30:00,299
and it's almost always
the wrong thing to do.

591
00:30:00,299 --> 00:30:04,241
And the reason for that is
there is an exec command.

592
00:30:04,241 --> 00:30:07,824
It goes like this:
"docker container exec",

593
00:30:08,901 --> 00:30:10,416
I always struggle with this command,

594
00:30:10,416 --> 00:30:12,861
and as with all the commands, it is listed

595
00:30:12,861 --> 00:30:15,396
on your docker command sheets

596
00:30:15,396 --> 00:30:18,148
that you can download
as part of this course.

597
00:30:18,148 --> 00:30:22,192
Now, exec allows me to execute a command

598
00:30:22,192 --> 00:30:24,312
inside this container.

599
00:30:24,312 --> 00:30:28,479
So in theory, all I need to
do is do something like bash

600
00:30:29,690 --> 00:30:33,776
which will run a bash
shell in that container.

601
00:30:33,776 --> 00:30:35,622
You'll find just like that

602
00:30:35,622 --> 00:30:38,475
though it's not going to do very much,

603
00:30:38,475 --> 00:30:40,431
and well, actually, I have an error

604
00:30:40,431 --> 00:30:41,884
and the error's because I forgot

605
00:30:41,884 --> 00:30:43,713
to put the ID of the container

606
00:30:43,713 --> 00:30:45,614
that we're running that command again.

607
00:30:45,614 --> 00:30:47,976
I've forgotten the ID of my container.

608
00:30:47,976 --> 00:30:50,741
So, I'll do a "docker container ls".

609
00:30:50,741 --> 00:30:52,532
See, it's this one starting ee,

610
00:30:52,532 --> 00:30:54,831
and I actually need it to put,

611
00:30:54,831 --> 00:30:58,070
before the command that I'm running,

612
00:30:58,070 --> 00:31:00,026
the ID of the container.

613
00:31:00,026 --> 00:31:02,253
Now, I don't really, I don't enjoy working

614
00:31:02,253 --> 00:31:04,327
with this command particularly.

615
00:31:04,327 --> 00:31:08,494
But this is saying, "Execute
in the container IDed ee,

616
00:31:09,614 --> 00:31:12,947
"I want to run the command bash," but...

617
00:31:15,075 --> 00:31:19,828
It's actually just hanging,
not doing anything useful.

618
00:31:19,828 --> 00:31:21,344
And the reason for that is,

619
00:31:21,344 --> 00:31:23,734
and I just did a Control C there

620
00:31:23,734 --> 00:31:25,333
to get back to the command line,

621
00:31:25,333 --> 00:31:29,114
we also need to remember to add in a -it,

622
00:31:29,114 --> 00:31:32,562
which, once again, makes
this an interactive command

623
00:31:32,562 --> 00:31:36,651
which is connected to our
terminal, that's crucial.

624
00:31:36,651 --> 00:31:37,989
And we'll find now...

625
00:31:37,989 --> 00:31:42,156
Fantastic, we are now in a bash
shell inside that container.

626
00:31:43,557 --> 00:31:45,366
So as I said, this could be useful

627
00:31:45,366 --> 00:31:47,234
if we needed to do some debugging,

628
00:31:47,234 --> 00:31:50,559
for example, I could look
inside this webapps folder

629
00:31:50,559 --> 00:31:54,749
and, oh, I can see there's
a ROOT.war and root folder.

630
00:31:54,749 --> 00:31:57,378
And you can imagine the kinds of things

631
00:31:57,378 --> 00:32:00,956
that you might need to
do with the exec command.

632
00:32:00,956 --> 00:32:03,481
As I said, I've never
find it very intuitive

633
00:32:03,481 --> 00:32:06,473
writing that command, but
when you're setting up

634
00:32:06,473 --> 00:32:09,613
a new dock environment and
you're building new containers,

635
00:32:09,613 --> 00:32:12,280
that command you use very often.

636
00:32:13,199 --> 00:32:16,180
So in this session, we've
really been kicking the toys

637
00:32:16,180 --> 00:32:19,200
of Docker and just getting
a few extra commands

638
00:32:19,200 --> 00:32:20,464
under our belt,

639
00:32:20,464 --> 00:32:23,281
and we've seen where we can find images.

640
00:32:23,281 --> 00:32:26,437
But really, we're not
able to anything useful

641
00:32:26,437 --> 00:32:30,187
with, for example, the
Ubuntu image directly.

642
00:32:31,038 --> 00:32:32,836
The intention of those images is

643
00:32:32,836 --> 00:32:36,639
that we create our own
images based on them

644
00:32:36,639 --> 00:32:39,364
and we'll learn how to do
that in the next chapter.

645
00:32:39,364 --> 00:32:41,307
But what I'll do to end the chapter

646
00:32:41,307 --> 00:32:43,972
is give you a very short exercise

647
00:32:43,972 --> 00:32:46,336
just to practise what we've done here.

648
00:32:46,336 --> 00:32:48,979
And the exercise is I
would you to have a try

649
00:32:48,979 --> 00:32:53,405
at finding an image which
is supporting Tomcat.

650
00:32:53,405 --> 00:32:56,095
And if you can find that image,

651
00:32:56,095 --> 00:32:59,303
then run a container from it and see

652
00:32:59,303 --> 00:33:03,470
if you can expose the default
Tomcat homepage on port 80.

653
00:33:05,342 --> 00:33:06,628
Your starting point for this is

654
00:33:06,628 --> 00:33:08,687
to have a look at Docker Hub.

655
00:33:08,687 --> 00:33:11,265
And I promise you this is
a really simple exercise.

656
00:33:11,265 --> 00:33:14,590
So, if you find yourself
getting in real trouble,

657
00:33:14,590 --> 00:33:16,898
then a quick walkthrough will follow

658
00:33:16,898 --> 00:33:19,065
after this fades to black.

659
00:33:20,452 --> 00:33:22,272
So definitely a simple exercise, this one,

660
00:33:22,272 --> 00:33:26,143
because you might have thought
before doing this course

661
00:33:26,143 --> 00:33:28,222
that to get a Docker container,

662
00:33:28,222 --> 00:33:31,864
you're going to have to get
yourself an Ubuntu container,

663
00:33:31,864 --> 00:33:35,748
for example, and then somehow
ssh into that container

664
00:33:35,748 --> 00:33:38,988
and instal Java, and then instal Tomcat,

665
00:33:38,988 --> 00:33:40,459
and then configure Tomcat.

666
00:33:40,459 --> 00:33:42,113
But you know now from this chapter

667
00:33:42,113 --> 00:33:46,186
that there are thousands of
predefined images available.

668
00:33:46,186 --> 00:33:48,597
There's almost certainly one available

669
00:33:48,597 --> 00:33:52,854
that will have a Tomcat
installation preconfigured.

670
00:33:52,854 --> 00:33:55,504
So, if we do a search on
Docker Hub for Tomcat,

671
00:33:55,504 --> 00:33:58,601
yeah, we've got 6.5 thousand repositories

672
00:33:58,601 --> 00:33:59,895
at the time of recording,

673
00:33:59,895 --> 00:34:01,924
a lot of really mysterious ones,

674
00:34:01,924 --> 00:34:04,348
no idea what these are for,

675
00:34:04,348 --> 00:34:07,744
but there may be something
very useful in these.

676
00:34:07,744 --> 00:34:09,589
But we're right at the very top,

677
00:34:09,589 --> 00:34:12,957
there's the official one, there's
no forward slash in front,

678
00:34:12,957 --> 00:34:15,505
so we know this is going
to be a safe image,

679
00:34:15,505 --> 00:34:18,471
a well-defined, well-configured image,

680
00:34:18,471 --> 00:34:21,234
the Tomcat official image.

681
00:34:21,234 --> 00:34:23,769
Now there's a lot of information on here.

682
00:34:23,769 --> 00:34:26,448
Actually, one of the things
I haven't talked about so far

683
00:34:26,448 --> 00:34:28,681
is the concept of tags.

684
00:34:28,681 --> 00:34:30,377
You can think of these tags

685
00:34:30,377 --> 00:34:33,636
as just being different
versions of that image.

686
00:34:33,636 --> 00:34:36,960
and as a Java developer, you'll
almost certainly recognise

687
00:34:36,960 --> 00:34:40,446
the fact that, oh, yeah,
they've got images here

688
00:34:40,446 --> 00:34:43,779
supporting Tomcat 6, Tomcat 7, 8, and 9,

689
00:34:44,688 --> 00:34:47,095
and they've got also gone to the effort

690
00:34:47,095 --> 00:34:50,940
supporting various
different Java Runtimes.

691
00:34:50,940 --> 00:34:55,339
So it's looks like Java
7's supported and Java 8,

692
00:34:55,339 --> 00:34:59,686
and I would hope seeing there
will be support for Java 9,

693
00:34:59,686 --> 00:35:01,703
if it ever gets released.

694
00:35:01,703 --> 00:35:04,127
Now, another thing that I'll return

695
00:35:04,127 --> 00:35:05,576
to later on in the course,

696
00:35:05,576 --> 00:35:08,725
but you'll see some of these Tomcat images

697
00:35:08,725 --> 00:35:10,308
are tagged -alpine.

698
00:35:11,264 --> 00:35:13,061
What's going on there is

699
00:35:13,061 --> 00:35:15,966
there is a Linux
distribution called Alpine,

700
00:35:15,966 --> 00:35:18,375
which is getting more
and more attention now,

701
00:35:18,375 --> 00:35:22,246
really because of Docker,
and that often what we want

702
00:35:22,246 --> 00:35:25,823
in containers is the smallest
possible container size.

703
00:35:25,823 --> 00:35:28,039
And there really is no sense

704
00:35:28,039 --> 00:35:31,612
in having a full Linux distribution

705
00:35:31,612 --> 00:35:35,050
with millions and millions
of tools and packages

706
00:35:35,050 --> 00:35:38,331
that that containers never going to use.

707
00:35:38,331 --> 00:35:41,014
So, Alpine is fantastic in that

708
00:35:41,014 --> 00:35:44,847
it is a very minimal Linux distribution.

709
00:35:44,847 --> 00:35:47,045
I mean, there's almost
nothing bundled with it,

710
00:35:47,045 --> 00:35:48,795
just the very basics.

711
00:35:49,908 --> 00:35:52,029
And oftentimes, that's perfect

712
00:35:52,029 --> 00:35:53,917
for what you need in a container.

713
00:35:53,917 --> 00:35:55,327
So, I didn't tell you this,

714
00:35:55,327 --> 00:35:57,129
but you can pick of these tags.

715
00:35:57,129 --> 00:35:59,699
And the way you would
choose a particular tag

716
00:35:59,699 --> 00:36:03,532
is when you do the pull,
"docker pull tomcat",

717
00:36:05,028 --> 00:36:08,511
you would do colon, followed by the tag

718
00:36:08,511 --> 00:36:09,868
that you want to pull.

719
00:36:09,868 --> 00:36:12,397
And in Docker images,
there's always one image

720
00:36:12,397 --> 00:36:14,704
that is tagged as latest,

721
00:36:14,704 --> 00:36:16,076
and that will become the default

722
00:36:16,076 --> 00:36:18,344
if you don't specify it.

723
00:36:18,344 --> 00:36:20,564
And tomcat's quite an interesting one.

724
00:36:20,564 --> 00:36:22,523
I mean usually, the latest tag would be

725
00:36:22,523 --> 00:36:27,246
the most up to date version
of this particular image,

726
00:36:27,246 --> 00:36:30,653
but actually, if we click the
link through to tags here,

727
00:36:30,653 --> 00:36:34,099
there's a complete list
of all of the tags.

728
00:36:34,099 --> 00:36:37,894
So, there's Tomcat 9 built against Alpine,

729
00:36:37,894 --> 00:36:40,644
and quite a long, long, long list

730
00:36:42,491 --> 00:36:46,337
until we get to this one
here, which is tagged latest.

731
00:36:46,337 --> 00:36:50,587
Is this image here which is 127 megabytes.

732
00:36:50,587 --> 00:36:54,682
And actually, the latest tag is an alias,

733
00:36:54,682 --> 00:36:56,932
effectively, for Version 8.

734
00:36:58,099 --> 00:37:02,263
Which is itself an alias
for, in fact, all of these,

735
00:37:02,263 --> 00:37:05,706
all of these tags,
which are 127 megabytes,

736
00:37:05,706 --> 00:37:08,623
are all aliases for the same image.

737
00:37:10,847 --> 00:37:14,111
Really, this latest, this 8.5.16

738
00:37:14,111 --> 00:37:16,528
built against Java Runtime 8,

739
00:37:17,671 --> 00:37:20,588
and they've just provided
these alternative tags

740
00:37:20,588 --> 00:37:22,658
as kind of conveniences,

741
00:37:22,658 --> 00:37:25,924
and also that happens
to be tagged as latest.

742
00:37:25,924 --> 00:37:27,392
Or as by the time you do this,

743
00:37:27,392 --> 00:37:30,031
the latest time will
probably be associated

744
00:37:30,031 --> 00:37:31,749
with something different.

745
00:37:31,749 --> 00:37:33,324
Anyway, that's a lot of talk,

746
00:37:33,324 --> 00:37:37,860
but we know we can just do a
"docker image pull tomcat" will

747
00:37:37,860 --> 00:37:41,803
and we can see using
the default tag: latest,

748
00:37:41,803 --> 00:37:44,498
and then it will be downloaded.

749
00:37:44,498 --> 00:37:45,926
Something else to notice is that

750
00:37:45,926 --> 00:37:48,772
if you've already got a particular image,

751
00:37:48,772 --> 00:37:50,272
or even part of an image,

752
00:37:50,272 --> 00:37:53,166
then it won't download it again.

753
00:37:53,166 --> 00:37:55,209
So that's good efficiency.

754
00:37:55,209 --> 00:37:57,772
I happen to have already
got the Tomcat image,

755
00:37:57,772 --> 00:37:59,445
so I didn't need to download it.

756
00:37:59,445 --> 00:38:01,774
Now we need to run a container from it.

757
00:38:01,774 --> 00:38:04,888
So, it's going to be
"docker container run".

758
00:38:04,888 --> 00:38:09,380
I suggest it would be
worth doing a -d on this

759
00:38:09,380 --> 00:38:13,259
because we want to run in the
background in detached state.

760
00:38:13,259 --> 00:38:15,947
We need to publish the ports,

761
00:38:15,947 --> 00:38:18,114
80 is going to go to 8080,

762
00:38:18,966 --> 00:38:21,637
and then, I think we're done really.

763
00:38:21,637 --> 00:38:23,720
We can run Tomcat.

764
00:38:23,720 --> 00:38:26,384
Ah, yes, so, I'm glad this has happened.

765
00:38:26,384 --> 00:38:27,815
It might well have happened to you.

766
00:38:27,815 --> 00:38:31,982
It's important to remember that
this on any machine, really,

767
00:38:32,842 --> 00:38:35,598
across all of your Docker containers,

768
00:38:35,598 --> 00:38:38,568
you can only use a single port once.

769
00:38:38,568 --> 00:38:42,151
You can't have Container
A using port 8080,

770
00:38:43,144 --> 00:38:45,811
and Container B using port 8080.

771
00:38:46,665 --> 00:38:48,450
And that's because ultimately,

772
00:38:48,450 --> 00:38:51,104
these containers are
running on the same machine,

773
00:38:51,104 --> 00:38:54,781
they are sharing the same Linux kernel.

774
00:38:54,781 --> 00:38:58,948
So, it's important then,
if I do a "docker ls -a",

775
00:38:59,942 --> 00:39:03,743
I should say "docker container ls -a",

776
00:39:03,743 --> 00:39:07,630
it's important to make sure you stopped

777
00:39:07,630 --> 00:39:10,213
your fleetman-webapp container.

778
00:39:12,941 --> 00:39:14,665
Okay, and now I should be able

779
00:39:14,665 --> 00:39:17,590
to recall that command and run my Tomcat.

780
00:39:17,590 --> 00:39:20,026
So there we are, I have
a new container now,

781
00:39:20,026 --> 00:39:21,859
this one beginning c0.

782
00:39:23,060 --> 00:39:25,082
If I want to look at its logs,

783
00:39:25,082 --> 00:39:27,626
I can do docker container logs,

784
00:39:27,626 --> 00:39:30,123
I'll do a -f to follow those logs,

785
00:39:30,123 --> 00:39:32,797
and the ID of the container c0,

786
00:39:32,797 --> 00:39:35,264
and yeah, there we can see the logs,

787
00:39:35,264 --> 00:39:38,754
and it took about a second to start up.

788
00:39:38,754 --> 00:39:42,589
I'm back to my browser, if I
do a refresh on local host,

789
00:39:42,589 --> 00:39:44,256
I don't need a port,

790
00:39:45,140 --> 00:39:50,010
there we are, we have the
default Apache Tomcat homepage.

791
00:39:50,010 --> 00:39:52,423
Well again, I know I've
said this several times

792
00:39:52,423 --> 00:39:54,898
on this chapter, but it's worth repeating,

793
00:39:54,898 --> 00:39:58,158
that this image isn't really that useful

794
00:39:58,158 --> 00:40:01,136
because it doesn't have
any apps installed on it.

795
00:40:01,136 --> 00:40:04,637
And I could possibly
use the Manager app here

796
00:40:04,637 --> 00:40:07,907
to manually upload a
war file to this Tomcat,

797
00:40:07,907 --> 00:40:09,850
but we really don't want that.

798
00:40:09,850 --> 00:40:11,752
We want an image which has already

799
00:40:11,752 --> 00:40:13,821
got our application installed.

800
00:40:13,821 --> 00:40:15,182
And to do that, we're gonna have

801
00:40:15,182 --> 00:40:18,828
to learn how to make new
images based on old ones.

802
00:40:18,828 --> 00:40:22,495
So, we'll be doing that
in the next chapter.

1
00:00:00,548 --> 00:00:01,742
- [Instructor] Hello and welcome back.

2
00:00:01,742 --> 00:00:04,540
It's time now for things to come together.

3
00:00:04,540 --> 00:00:06,078
For the first time we're going to create

4
00:00:06,078 --> 00:00:08,954
our own image in Docker
and we'll be getting

5
00:00:08,954 --> 00:00:13,152
acquainted with very important Dockerfile.

6
00:00:13,152 --> 00:00:14,777
To get things started I'm going to set

7
00:00:14,777 --> 00:00:16,925
ourselves a quick objective.

8
00:00:16,925 --> 00:00:19,450
I'd like to create at a new image which

9
00:00:19,450 --> 00:00:24,171
contains a full Java
Development Kit preinstalled.

10
00:00:24,171 --> 00:00:26,858
Now, you've probably guessed
by now that there is an

11
00:00:26,858 --> 00:00:30,758
official image already on
Docker Hub which does exactly

12
00:00:30,758 --> 00:00:34,390
this, but just to give us a chance learn,

13
00:00:34,390 --> 00:00:37,183
let's pretend that image doesn't exist

14
00:00:37,183 --> 00:00:40,155
or maybe it's not quite what we need.

15
00:00:40,155 --> 00:00:42,974
We will be using that official
image I think in the next

16
00:00:42,974 --> 00:00:47,205
chapter, but for now let's
have a go at rolling our own.

17
00:00:47,205 --> 00:00:49,229
There are two ways to create an image.

18
00:00:49,229 --> 00:00:52,062
Firstly, although it's rarely done

19
00:00:53,000 --> 00:00:56,642
we can create an image
just by taking a snapshot

20
00:00:56,642 --> 00:00:58,559
of a running container.

21
00:00:59,625 --> 00:01:01,402
Let's do exactly that.

22
00:01:01,402 --> 00:01:04,399
So, the objective was we
want to create a container

23
00:01:04,399 --> 00:01:07,389
which is running the Java Development Kit.

24
00:01:07,389 --> 00:01:10,813
Well, before we do anything
we some kind of a base image

25
00:01:10,813 --> 00:01:14,465
and I think purely
because we use the ubuntu

26
00:01:14,465 --> 00:01:16,701
image in the previous chapter,

27
00:01:16,701 --> 00:01:18,934
we'll work from that.

28
00:01:18,934 --> 00:01:23,020
If I do a Docker image ls and hope you're

29
00:01:23,020 --> 00:01:25,867
following along and doing
the same kinds of things,

30
00:01:25,867 --> 00:01:29,565
we've already pulled this ubuntu image

31
00:01:29,565 --> 00:01:33,462
and we haven't really taken
much notice of the image IDs,

32
00:01:33,462 --> 00:01:37,129
but it's this image for
me beginning on 14f.

33
00:01:38,174 --> 00:01:42,075
Now we can create a running
container from that image.

34
00:01:42,075 --> 00:01:45,491
So, Docker container run and I want to

35
00:01:45,491 --> 00:01:49,973
run this image interactively
connected to a terminal so it's

36
00:01:49,973 --> 00:01:54,140
the dash i-t option and then
the name of the image, ubuntu.

37
00:01:57,997 --> 00:02:00,656
Great, so we're now on the
command line of this container

38
00:02:00,656 --> 00:02:02,645
and as you saw in the previous chapter,

39
00:02:02,645 --> 00:02:05,433
we can play around inside this container,

40
00:02:05,433 --> 00:02:08,170
but I kind of made the point
in the previous chapter that

41
00:02:08,170 --> 00:02:11,611
the changes we make if any in
this container are going to be

42
00:02:11,611 --> 00:02:15,255
transient when we stop
and remove that container,

43
00:02:15,255 --> 00:02:18,775
those changes are gone, but
actually you can as I say

44
00:02:18,775 --> 00:02:21,397
you can take a snapshot
of a running container.

45
00:02:21,397 --> 00:02:23,435
So, I think what I'll do then is instal

46
00:02:23,435 --> 00:02:24,724
Java into this container

47
00:02:24,724 --> 00:02:27,175
and then we'll take an
image from that container.

48
00:02:27,175 --> 00:02:29,317
I don't use ubuntu too often these days,

49
00:02:29,317 --> 00:02:33,613
but I know that the
package manager is apt-get

50
00:02:33,613 --> 00:02:36,863
and the first thing to do is an update,

51
00:02:38,416 --> 00:02:41,064
and then I do an apt-get instal

52
00:02:41,064 --> 00:02:42,953
of the Java Development Kit.

53
00:02:42,953 --> 00:02:45,906
Now, I genuinely can't remember
what the name of the package

54
00:02:45,906 --> 00:02:47,572
for the Java Development Kit is,

55
00:02:47,572 --> 00:02:51,739
so I can use apt-cache and
then I can do a search,

56
00:02:55,031 --> 00:02:58,037
and that's how we search
for packages in apt.

57
00:02:58,037 --> 00:03:02,583
I guess that the Java
Development Kit package must have

58
00:03:02,583 --> 00:03:05,916
the phrase jdk in it, so we'll try that.

59
00:03:07,309 --> 00:03:10,548
Okay, well that's listed
about a page full of options,

60
00:03:10,548 --> 00:03:12,264
so we can have a little hunt through here.

61
00:03:12,264 --> 00:03:15,079
Some of these are for jdk-9,

62
00:03:15,079 --> 00:03:17,590
and there's some headless versions,

63
00:03:17,590 --> 00:03:19,342
various different variations,

64
00:03:19,342 --> 00:03:22,592
but I think that the openjdk-8 dash jdk

65
00:03:24,388 --> 00:03:26,836
should be sufficient for what we want.

66
00:03:26,836 --> 00:03:30,295
So, we'll do an apt-get instal dash y

67
00:03:30,295 --> 00:03:32,628
so we don't have to confirm.

68
00:03:33,543 --> 00:03:37,710
Openjdk dash eight dash jdk.

69
00:03:41,512 --> 00:03:43,448
Great, well that took quite a long time,

70
00:03:43,448 --> 00:03:46,948
but I'll do a clear to tidy things up

71
00:03:46,948 --> 00:03:49,533
and we should be able to
confirm that if we run

72
00:03:49,533 --> 00:03:52,724
Java for example with Java
compiler, yeah there it is,

73
00:03:52,724 --> 00:03:55,322
available on the command line.

74
00:03:55,322 --> 00:03:59,323
So, I've effectively now
configured this container,

75
00:03:59,323 --> 00:04:03,354
and as you know now if I
exit from this container,

76
00:04:03,354 --> 00:04:05,802
that's gonna stop this container
because the bash command

77
00:04:05,802 --> 00:04:09,316
that's running this
container has now ended.

78
00:04:09,316 --> 00:04:11,566
I do a Docker container ls.

79
00:04:13,012 --> 00:04:15,680
The only container that I've
got running here is actually

80
00:04:15,680 --> 00:04:18,797
the tomcat container that I
was running as part of the

81
00:04:18,797 --> 00:04:22,076
previous chapter, so that's
not relevant to this work.

82
00:04:22,076 --> 00:04:25,743
If I do an ls dash a,
we should see in there

83
00:04:26,905 --> 00:04:30,959
this one here exited 36
seconds ago into the container

84
00:04:30,959 --> 00:04:34,023
beginning 5f.

85
00:04:34,023 --> 00:04:36,005
I've got another one there
that I was using to practise

86
00:04:36,005 --> 00:04:39,567
a little bit earlier on,
so the point of this then,

87
00:04:39,567 --> 00:04:41,338
is I want to show you how you can make

88
00:04:41,338 --> 00:04:43,429
an image from that container,

89
00:04:43,429 --> 00:04:45,820
and by the way, I should be
encouraging you to check out

90
00:04:45,820 --> 00:04:50,065
the documentation at
docs.docker.com and of course,

91
00:04:50,065 --> 00:04:52,751
you can find us using
any decent search engine

92
00:04:52,751 --> 00:04:57,656
and the command we're looking
for is Docker container commit

93
00:04:57,656 --> 00:05:01,509
which as the description here
says it creates a new image

94
00:05:01,509 --> 00:05:04,753
from a container's changes
and there's an example

95
00:05:04,753 --> 00:05:06,858
of its use and there are some options.

96
00:05:06,858 --> 00:05:10,848
For example, we can specify
the author of this image.

97
00:05:10,848 --> 00:05:12,659
So, let's do that then.

98
00:05:12,659 --> 00:05:14,431
Docker container commit.

99
00:05:14,431 --> 00:05:16,906
I'm going to specify an author.

100
00:05:16,906 --> 00:05:20,603
Of course, you'll substitute
your own name in here.

101
00:05:20,603 --> 00:05:24,020
It's usually a name and an email address.

102
00:05:30,814 --> 00:05:32,577
Well, as you've seen from previous work,

103
00:05:32,577 --> 00:05:35,129
the images unless they're official images

104
00:05:35,129 --> 00:05:37,061
we'll begin with the owner of the image

105
00:05:37,061 --> 00:05:38,992
followed by a forward slash,

106
00:05:38,992 --> 00:05:41,841
but let's just try just
to see what happens.

107
00:05:41,841 --> 00:05:44,745
We'll try giving this image a name

108
00:05:44,745 --> 00:05:48,328
like my jdkimage.

109
00:05:49,774 --> 00:05:52,428
I always forget tot do this
before the name of the image.

110
00:05:52,428 --> 00:05:55,122
You need to specify
the ID of the container

111
00:05:55,122 --> 00:05:57,755
that you're making the image from.

112
00:05:57,755 --> 00:05:59,672
For me that will be 5f.

113
00:06:02,043 --> 00:06:05,241
Well, as you can see there,
the command did run correctly

114
00:06:05,241 --> 00:06:08,460
and the reason for that is if
you're not going to publish

115
00:06:08,460 --> 00:06:12,353
your images on Docker Hub then it's fine

116
00:06:12,353 --> 00:06:14,803
for you to just give your image a label.

117
00:06:14,803 --> 00:06:18,093
Now, I would recommend you use
the forward slash notation,

118
00:06:18,093 --> 00:06:21,236
but the only reason I didn't
do that was I've realised that

119
00:06:21,236 --> 00:06:26,161
we haven't yet created for
you an account on Docker Hub.

120
00:06:26,161 --> 00:06:27,804
So, we'll come back and do that.

121
00:06:27,804 --> 00:06:30,912
For now just a basic name will do.

122
00:06:30,912 --> 00:06:34,662
So, if we do a Docker
image ls we can see now

123
00:06:36,740 --> 00:06:40,407
we have a new image in
our image repository.

124
00:06:42,111 --> 00:06:45,626
For me this one with the ID beginning 47,

125
00:06:45,626 --> 00:06:47,937
and of course we can create
a container from it now.

126
00:06:47,937 --> 00:06:51,990
I think before I do anything
else, I'll stop the container

127
00:06:51,990 --> 00:06:55,643
that I was running from
the previous chapter,

128
00:06:55,643 --> 00:06:58,674
that's the tomcat container
and I'm also going to do

129
00:06:58,674 --> 00:07:01,979
a Docker container prune which is going

130
00:07:01,979 --> 00:07:04,912
to remove all of the stopped containers,

131
00:07:04,912 --> 00:07:09,793
so Docker container ls dash
eight should give me nothing.

132
00:07:09,793 --> 00:07:12,755
So, a nice clean sheet to start from,

133
00:07:12,755 --> 00:07:16,123
but now I can do a
Docker container with run

134
00:07:16,123 --> 00:07:18,946
and I want to run this interactively again

135
00:07:18,946 --> 00:07:22,279
and this is going to be the myjdk image,

136
00:07:25,907 --> 00:07:29,124
and there we are on the
command line of our container

137
00:07:29,124 --> 00:07:31,032
and we should find if we run javac,

138
00:07:31,032 --> 00:07:35,254
yeah Java has successfully
been preconfigured.

139
00:07:35,254 --> 00:07:37,914
So, that's one way of creating
images and it's certainly

140
00:07:37,914 --> 00:07:40,981
quick and convenient, but I
must admit that I can't remember

141
00:07:40,981 --> 00:07:45,148
the last time I even thought
about doing a commit like that.

142
00:07:46,449 --> 00:07:50,234
I had to check the Docker
documentation to remind myself

143
00:07:50,234 --> 00:07:51,740
how to even do it.

144
00:07:51,740 --> 00:07:55,613
So, that should give you
an idea of how usual it is

145
00:07:55,613 --> 00:07:58,768
to want to create images from snapshots.

146
00:07:58,768 --> 00:08:02,398
The reason why it's not
a good idea generally,

147
00:08:02,398 --> 00:08:06,371
is that the image that we've
just created is not repeatable,

148
00:08:06,371 --> 00:08:10,426
and I have no way of looking
at that image in four year's

149
00:08:10,426 --> 00:08:12,798
time and getting any kind of understanding

150
00:08:12,798 --> 00:08:15,449
as to what's inside that image.

151
00:08:15,449 --> 00:08:19,795
I could've put anything in
there, so for that reason we

152
00:08:19,795 --> 00:08:23,962
almost always would create
images using a Dockerfile instead

153
00:08:26,595 --> 00:08:29,679
and I have onscreen right
now probably the most

154
00:08:29,679 --> 00:08:32,216
basic Dockerfile you can imagine,

155
00:08:32,216 --> 00:08:36,131
and really a Dockerfile is
not that difficult to explain.

156
00:08:36,131 --> 00:08:40,857
It's a text file describing
how an image should be built

157
00:08:40,857 --> 00:08:44,183
and the steps that we
just followed previously,

158
00:08:44,183 --> 00:08:47,035
manually on the command
line, have really just been

159
00:08:47,035 --> 00:08:50,286
captured right here in this text document.

160
00:08:50,286 --> 00:08:52,056
Let's go through it line by line.

161
00:08:52,056 --> 00:08:54,874
The first line is a really important line

162
00:08:54,874 --> 00:08:59,738
and this line is specifying
which image we are extending.

163
00:08:59,738 --> 00:09:02,879
I keep using that term
extending which I'm not sure

164
00:09:02,879 --> 00:09:05,484
is actually an official term in Docker.

165
00:09:05,484 --> 00:09:08,808
We're not really extending this image.

166
00:09:08,808 --> 00:09:12,385
We're taking this image
and we are adding to it

167
00:09:12,385 --> 00:09:15,637
and creating our own new image.

168
00:09:15,637 --> 00:09:17,214
It's important to remember that you

169
00:09:17,214 --> 00:09:19,631
can't change existing images.

170
00:09:21,086 --> 00:09:23,693
So, we know that there
is an image called ubuntu

171
00:09:23,693 --> 00:09:26,535
which publicly available
and even if we haven't

172
00:09:26,535 --> 00:09:29,839
pulled that image, it will
be automatically downloaded

173
00:09:29,839 --> 00:09:32,756
when we try to build our new image.

174
00:09:33,798 --> 00:09:36,041
I mentioned at the end
of the last chapter,

175
00:09:36,041 --> 00:09:37,761
you've might not have done that exercise,

176
00:09:37,761 --> 00:09:40,462
but I mentioned there are
these things called tags.

177
00:09:40,462 --> 00:09:43,031
So, the thing following the ubuntu,

178
00:09:43,031 --> 00:09:46,378
the colon, this latest is a tag.

179
00:09:46,378 --> 00:09:50,332
So, this is going to work
on the latest ubuntu image.

180
00:09:50,332 --> 00:09:53,863
I could've specified a specific tag here

181
00:09:53,863 --> 00:09:57,821
and you can get a full list
of those tags from Docker Hub.

182
00:09:57,821 --> 00:10:00,449
The second line is actually optional.

183
00:10:00,449 --> 00:10:04,718
It's a courtesy really to
future users of this image.

184
00:10:04,718 --> 00:10:09,258
The maintainer line is
saying who wrote this image,

185
00:10:09,258 --> 00:10:13,155
so, in that case it's me and
there's my email address.

186
00:10:13,155 --> 00:10:15,277
You can change that for yourself.

187
00:10:15,277 --> 00:10:19,462
Now, on that base image
we can execute commands

188
00:10:19,462 --> 00:10:22,784
and really all I'm doing
here is replicating exactly

189
00:10:22,784 --> 00:10:25,962
what I did when I did it
manually on the bash shell.

190
00:10:25,962 --> 00:10:30,610
The run command in a Dockerfile
is saying that Docker

191
00:10:30,610 --> 00:10:34,777
needs to run the following
commands inside the base image.

192
00:10:36,409 --> 00:10:40,062
So, all I've done here I've
copied the apt-get update

193
00:10:40,062 --> 00:10:42,062
and the apt-get instal.

194
00:10:43,013 --> 00:10:45,801
I don't know if you know,
but this double ampersand

195
00:10:45,801 --> 00:10:49,988
just allows us to chain
multiple commands together

196
00:10:49,988 --> 00:10:54,155
on a bash shell and usually the
final line in the Dockerfile

197
00:10:55,045 --> 00:10:56,919
is the CMD line.

198
00:10:56,919 --> 00:10:59,019
There are some alternatives actually,

199
00:10:59,019 --> 00:11:00,576
but I won't get hung up on that right now,

200
00:11:00,576 --> 00:11:04,840
and the command is what command
do we want this container

201
00:11:04,840 --> 00:11:07,840
to execute by default when it is run

202
00:11:09,443 --> 00:11:11,599
and we'll talk a lot more about that

203
00:11:11,599 --> 00:11:14,349
over the course of this
chapter, but for now,

204
00:11:14,349 --> 00:11:17,733
I'm just going to make is so
that it automatically runs

205
00:11:17,733 --> 00:11:22,574
a bash shell when a container
is run from this image.

206
00:11:22,574 --> 00:11:26,377
If you download the practicals
and code folder for this

207
00:11:26,377 --> 00:11:29,148
course which you'll find
on the course homepage

208
00:11:29,148 --> 00:11:31,434
at virtualpairprogrammers.com,

209
00:11:31,434 --> 00:11:34,330
I've supplied a folder called chapter six

210
00:11:34,330 --> 00:11:37,042
and inside there there are two files.

211
00:11:37,042 --> 00:11:39,614
There's a copy of the
Dockerfile that you've just seen

212
00:11:39,614 --> 00:11:41,772
and there's a Java jar file that we'll

213
00:11:41,772 --> 00:11:43,890
be using in a few moments.

214
00:11:43,890 --> 00:11:45,862
If you want to follow
along with me I'd like you

215
00:11:45,862 --> 00:11:49,383
to extract that folder
into a folder of its own.

216
00:11:49,383 --> 00:11:52,041
Now, for reasons that will
become apparent later.

217
00:11:52,041 --> 00:11:56,597
I recommend that you extract
the chapter six folder

218
00:11:56,597 --> 00:11:59,078
and put that somewhere on your hard drive.

219
00:11:59,078 --> 00:12:03,955
Don't just take the individual
files and drop them somewhere

220
00:12:03,955 --> 00:12:07,885
on your file system such
as the root at the c drive.

221
00:12:07,885 --> 00:12:10,088
I'll explain why that's important later,

222
00:12:10,088 --> 00:12:13,067
but if you just take that
folder and put that folder

223
00:12:13,067 --> 00:12:16,103
anywhere and then in the power shell

224
00:12:16,103 --> 00:12:18,633
you can navigate into that folder.

225
00:12:18,633 --> 00:12:21,162
So, here we have the Dockerfile

226
00:12:21,162 --> 00:12:25,195
and creating an image using the Dockerfile

227
00:12:25,195 --> 00:12:27,550
is really straight forward.

228
00:12:27,550 --> 00:12:30,644
It's going to be Docker image

229
00:12:30,644 --> 00:12:34,247
and then the new command is build.

230
00:12:34,247 --> 00:12:37,221
That will build an
image from a Dockerfile.

231
00:12:37,221 --> 00:12:39,471
We need the dash t argument

232
00:12:41,295 --> 00:12:44,021
and this allows us to tag the image.

233
00:12:44,021 --> 00:12:47,283
In fact it just means
give the image a name.

234
00:12:47,283 --> 00:12:50,918
So, we can actually reuse the
same name that we used before,

235
00:12:50,918 --> 00:12:54,378
but I forgotten what that name
is and I can't be bothered

236
00:12:54,378 --> 00:12:57,775
to go back and find it so,
I'm (chuckling) going to give

237
00:12:57,775 --> 00:13:00,696
this a deliberately clunky name.

238
00:13:00,696 --> 00:13:04,779
I'm going to call this
jdk-image from-dockerfile.

239
00:13:07,119 --> 00:13:10,421
Not a very realistic image
name, but it will do for now.

240
00:13:10,421 --> 00:13:13,373
It's a common mistake here to forget

241
00:13:13,373 --> 00:13:16,327
that you also need a dot on the end.

242
00:13:16,327 --> 00:13:20,723
If I leave the dot off I will
get an error that it requires

243
00:13:20,723 --> 00:13:22,898
exactly one argument.

244
00:13:22,898 --> 00:13:24,355
Looks a bit confusing.

245
00:13:24,355 --> 00:13:25,861
In fact the dash t

246
00:13:25,861 --> 00:13:29,294
and the label doesn't
qualify as an argument.

247
00:13:29,294 --> 00:13:32,446
The argument is what folder do we want

248
00:13:32,446 --> 00:13:35,004
the image creation to work from,

249
00:13:35,004 --> 00:13:36,822
and this is going to become relevant

250
00:13:36,822 --> 00:13:39,956
when we start to add files into our image.

251
00:13:39,956 --> 00:13:42,646
For now, we've just got the folder,

252
00:13:42,646 --> 00:13:45,383
this chapter six folder
with the Dockerfile in it.

253
00:13:45,383 --> 00:13:47,560
You just need a dot there to say

254
00:13:47,560 --> 00:13:50,143
we're working in this folder.

255
00:13:50,143 --> 00:13:51,976
Let's give that a try.

256
00:13:53,462 --> 00:13:55,800
So, we had a lot of output there,

257
00:13:55,800 --> 00:13:58,494
but actually most of that
output was the output

258
00:13:58,494 --> 00:14:01,359
from the apt-get instal running

259
00:14:01,359 --> 00:14:03,783
and we saw that kind of output before.

260
00:14:03,783 --> 00:14:06,108
Now, a lot of the
interesting Docker stuff has

261
00:14:06,108 --> 00:14:09,507
got somewhat lost in amongst all of that,

262
00:14:09,507 --> 00:14:12,340
but if I carefully scroll upwards,

263
00:14:14,164 --> 00:14:16,210
if it hadn't been for all of that logging,

264
00:14:16,210 --> 00:14:18,712
you'd have seen that for each of the lines

265
00:14:18,712 --> 00:14:22,202
in the Dockerfile is outputting a step,

266
00:14:22,202 --> 00:14:23,939
so we had four lines.

267
00:14:23,939 --> 00:14:25,916
So, we have the first line which

268
00:14:25,916 --> 00:14:29,042
is the base image from ubuntu latest

269
00:14:29,042 --> 00:14:33,209
and it's telling us it's
using the image beginning 14f.

270
00:14:34,914 --> 00:14:39,081
If I go back to the bottom
and do a Docker image ls,

271
00:14:40,800 --> 00:14:45,060
you'll see we actually do
have an image with the ID

272
00:14:45,060 --> 00:14:48,411
beginning 14f and it's
this ubuntu image here,

273
00:14:48,411 --> 00:14:52,418
it's actually the image
that we pulled earlier.

274
00:14:52,418 --> 00:14:54,775
So, going back to the top
what's basically happening is

275
00:14:54,775 --> 00:14:58,436
the build is saying actually
we've already got this image

276
00:14:58,436 --> 00:15:00,267
already in our local cache,

277
00:15:00,267 --> 00:15:01,882
so we won't bother downloading it.

278
00:15:01,882 --> 00:15:04,972
Now, of course if I'd used a
base image that we haven't yet

279
00:15:04,972 --> 00:15:08,557
pulled such as the alpine that
I mentioned earlier in the

280
00:15:08,557 --> 00:15:13,027
course, then it would have to
do a download at that point.

281
00:15:13,027 --> 00:15:16,551
Then what it's doing with
step two, now although it's

282
00:15:16,551 --> 00:15:20,489
a really boring step really,
it's just this definition of

283
00:15:20,489 --> 00:15:24,468
the maintainer because actually
starting a new container

284
00:15:24,468 --> 00:15:28,532
with that information built
in and it continues to do this

285
00:15:28,532 --> 00:15:32,587
with every step it
finds up a new container

286
00:15:32,587 --> 00:15:36,702
based on the previous one,
based on the previous image,

287
00:15:36,702 --> 00:15:39,004
it applies this change

288
00:15:39,004 --> 00:15:41,985
and then creates a new image from it.

289
00:15:41,985 --> 00:15:46,019
So, in this case it's
the image beginning 9c

290
00:15:46,019 --> 00:15:48,771
and it continues in this
way and each of these

291
00:15:48,771 --> 00:15:51,622
steps is actually called
a layer in Docker.

292
00:15:51,622 --> 00:15:54,311
Now to be honest it's a bit
of an intellectual nicety.

293
00:15:54,311 --> 00:15:57,661
We don't need to know about
these intermediate layers

294
00:15:57,661 --> 00:16:00,072
and we don't really need to
know about these intermediate

295
00:16:00,072 --> 00:16:03,559
images, it does actually
prove to be a very useful

296
00:16:03,559 --> 00:16:05,718
efficiency gain because we'll find that

297
00:16:05,718 --> 00:16:07,284
because of these intermediate steps

298
00:16:07,284 --> 00:16:09,934
it's often the case that
if we're making a change

299
00:16:09,934 --> 00:16:12,597
to an existing complicated image,

300
00:16:12,597 --> 00:16:15,352
Docker might not have to do much work.

301
00:16:15,352 --> 00:16:17,399
A good example would
be this step three here

302
00:16:17,399 --> 00:16:21,566
which was really big and heavy
and long and complicated.

303
00:16:23,712 --> 00:16:26,313
Now, it took quite a long time to do that,

304
00:16:26,313 --> 00:16:29,864
but because the work that was
done in step three has been

305
00:16:29,864 --> 00:16:34,040
stashed in an intermediate
image, if in the future

306
00:16:34,040 --> 00:16:35,885
we would to extend this Dockerfile

307
00:16:35,885 --> 00:16:39,944
and we added further
steps after step three,

308
00:16:39,944 --> 00:16:43,655
for example if we changed the
step for which is the running

309
00:16:43,655 --> 00:16:46,603
of the command, then when
we run that build again,

310
00:16:46,603 --> 00:16:50,042
it won't have to repeat any
steps that it already has

311
00:16:50,042 --> 00:16:52,376
and intermediate image for,

312
00:16:52,376 --> 00:16:55,838
and I could do a very basic
demonstration of that actually

313
00:16:55,838 --> 00:16:57,901
if we just rerun that build again.

314
00:16:57,901 --> 00:17:01,466
Docker image build dash t, et cetera,

315
00:17:01,466 --> 00:17:04,257
this time around can us
see that was instantaneous?

316
00:17:04,257 --> 00:17:08,208
And it was instantaneous
because on each of these steps,

317
00:17:08,208 --> 00:17:12,768
it already had the image
needed in the cache.

318
00:17:12,768 --> 00:17:14,900
So, that will give some
efficiency gains later

319
00:17:14,900 --> 00:17:17,258
and I'll return to that topic
a bit later in the course,

320
00:17:17,258 --> 00:17:19,520
but for now the big thing
we want outside do is run

321
00:17:19,520 --> 00:17:22,898
a container from that
image Docker container run

322
00:17:22,898 --> 00:17:25,716
and we're gonna run it interactively

323
00:17:25,716 --> 00:17:28,966
and it's the jdk-image-from-dockerfile,

324
00:17:35,248 --> 00:17:37,314
and we're in the bash
shell for that container

325
00:17:37,314 --> 00:17:40,231
and we should be able to run javac.

326
00:17:41,087 --> 00:17:42,170
That's great.

327
00:17:43,361 --> 00:17:44,870
So, that's all very well.

328
00:17:44,870 --> 00:17:48,159
I'll exit from that
container, but of course,

329
00:17:48,159 --> 00:17:51,171
building a container that
can run a Java compiler

330
00:17:51,171 --> 00:17:53,130
isn't particularly useful.

331
00:17:53,130 --> 00:17:55,145
What we really want to
do is we want to run

332
00:17:55,145 --> 00:17:59,886
some kind of application
inside that container.

333
00:17:59,886 --> 00:18:02,787
Now, the other file that I
gave you from the practicals

334
00:18:02,787 --> 00:18:06,956
and code folder was this jar
file called test program.jar

335
00:18:06,956 --> 00:18:09,658
and it's a really basic programme.

336
00:18:09,658 --> 00:18:13,491
You can run it using
java-jar test program.jar

337
00:18:16,376 --> 00:18:20,124
or at least you can assuming
you have a Java Development Kit

338
00:18:20,124 --> 00:18:24,752
installed in your host
environment and very basic this.

339
00:18:24,752 --> 00:18:28,919
It runs forever, so it's
simulating a demon type process

340
00:18:29,837 --> 00:18:34,094
and it's going to output
the current date and time

341
00:18:34,094 --> 00:18:37,011
every five seconds and it will keep

342
00:18:38,481 --> 00:18:41,563
doing that until you
cancel with control c.

343
00:18:41,563 --> 00:18:44,516
So, not very existing, but I
think it would be really good

344
00:18:44,516 --> 00:18:47,668
if we could somehow build a container

345
00:18:47,668 --> 00:18:51,001
that would run this service continually.

346
00:18:51,922 --> 00:18:55,817
Well, we've pretty much done
all of the work that we need.

347
00:18:55,817 --> 00:18:58,993
We've already defined the
container in our Dockerfile

348
00:18:58,993 --> 00:19:02,264
which has a Java Development
Kit fully installed.

349
00:19:02,264 --> 00:19:06,183
All we really need to do is
somehow get this jar file

350
00:19:06,183 --> 00:19:09,516
into that container and make it execute.

351
00:19:10,578 --> 00:19:12,222
How can we do that?

352
00:19:12,222 --> 00:19:13,988
It's actually pretty simple.

353
00:19:13,988 --> 00:19:17,231
If you open up your Dockerfile
in any decent text editor

354
00:19:17,231 --> 00:19:20,974
and the command what
we're looking for is copy

355
00:19:20,974 --> 00:19:23,843
and this will transfer local files from

356
00:19:23,843 --> 00:19:27,312
your host system into the container.

357
00:19:27,312 --> 00:19:29,400
The file that we're wanting to transfer

358
00:19:29,400 --> 00:19:33,233
is test-program.jar,

359
00:19:35,450 --> 00:19:37,766
and we can reference that directly.

360
00:19:37,766 --> 00:19:41,146
Now, we don't need any
kind of folder names

361
00:19:41,146 --> 00:19:43,459
or dot forward slashes and so on,

362
00:19:43,459 --> 00:19:46,357
and the reason for that
is if you remember back

363
00:19:46,357 --> 00:19:49,802
to when we run the build,
the very important parameter

364
00:19:49,802 --> 00:19:54,585
at the end is the dot which
means that the so called build

365
00:19:54,585 --> 00:19:57,049
context for this Dockerfile for this

366
00:19:57,049 --> 00:19:59,216
image is this folder here.

367
00:20:00,556 --> 00:20:04,956
What that means is that all
of the files in this folder

368
00:20:04,956 --> 00:20:09,123
and any sub folders are
visible to the Dockerfile.

369
00:20:10,409 --> 00:20:14,860
It's important to recognise
that no other files will be.

370
00:20:14,860 --> 00:20:16,708
It's no absolutely no
good thinking that in

371
00:20:16,708 --> 00:20:21,302
here you can do a forward
slash and reference some

372
00:20:21,302 --> 00:20:23,724
folder on your operating system.

373
00:20:23,724 --> 00:20:27,891
It's only files inside this
folder and any sub folders

374
00:20:29,448 --> 00:20:32,802
that will be visibile to the Docker build

375
00:20:32,802 --> 00:20:34,953
and then the second parameter is the,

376
00:20:34,953 --> 00:20:39,018
is a reference to in what
folder do want to put it on

377
00:20:39,018 --> 00:20:41,968
on the file system inside the container.

378
00:20:41,968 --> 00:20:44,816
Now, of course that's entirely
up to you where you put

379
00:20:44,816 --> 00:20:46,638
it in the container and
I think it would be worth

380
00:20:46,638 --> 00:20:50,542
thinking about where do we
want this jar file to live.

381
00:20:50,542 --> 00:20:52,935
We just downloaded this ubuntu image

382
00:20:52,935 --> 00:20:55,261
and I don't have a very good feel for

383
00:20:55,261 --> 00:20:57,678
what's actually inside that container.

384
00:20:57,678 --> 00:21:01,845
So, I suggest what we do is
do a Docker container run

385
00:21:03,229 --> 00:21:06,312
if I can recall the previous command.

386
00:21:09,041 --> 00:21:13,791
So, I'm running interactively
my image as it stands so far

387
00:21:13,791 --> 00:21:16,419
and that's going to drop
me into a bash shell.

388
00:21:16,419 --> 00:21:18,088
Now, if I print the working directory,

389
00:21:18,088 --> 00:21:21,328
you'll find that we're
actually in the root folder.

390
00:21:21,328 --> 00:21:25,074
If we do an ls, it's a
regular Linux file structure,

391
00:21:25,074 --> 00:21:28,786
but if go into the home
folder which is where the user

392
00:21:28,786 --> 00:21:31,889
accounts would be, you'll
find that there are actually

393
00:21:31,889 --> 00:21:35,239
no users already
configured on this system.

394
00:21:35,239 --> 00:21:38,279
So, it's a very bare file system

395
00:21:38,279 --> 00:21:40,489
and we can really do
anything we want with it.

396
00:21:40,489 --> 00:21:43,391
There's several places we
could but our jar file.

397
00:21:43,391 --> 00:21:45,029
We could place it under the opt folder

398
00:21:45,029 --> 00:21:47,923
which I think is for optional software.

399
00:21:47,923 --> 00:21:52,803
There's also the user folder
or the usr folder I should say

400
00:21:52,803 --> 00:21:56,803
which is for read only
system wide binary files.

401
00:21:58,222 --> 00:22:00,210
Now, if you think about
it what we're trying to do

402
00:22:00,210 --> 00:22:03,110
is we're trying to instal
this Java programme

403
00:22:03,110 --> 00:22:06,429
into this container kind of permanently.

404
00:22:06,429 --> 00:22:09,762
So, I think it feels like it makes sense

405
00:22:10,771 --> 00:22:14,238
for this to go into the usr folder.

406
00:22:14,238 --> 00:22:17,355
So, I'm already in there actually.

407
00:22:17,355 --> 00:22:21,215
So, if we look in there, there's a bin,

408
00:22:21,215 --> 00:22:24,311
so there's a bin folder
in there which has got

409
00:22:24,311 --> 00:22:26,228
all of the basic tools.

410
00:22:28,832 --> 00:22:33,518
There's a local folder which
itself has a bin directory.

411
00:22:33,518 --> 00:22:36,250
I think this is probably the
sensible place to put it.

412
00:22:36,250 --> 00:22:37,900
This is for local installations.

413
00:22:37,900 --> 00:22:41,634
In other words, binaries that
are not part of the standard

414
00:22:41,634 --> 00:22:45,801
Linux distribution, so I'm
going to put my Java file

415
00:22:46,835 --> 00:22:50,301
in slash usr slash local slash bin.

416
00:22:50,301 --> 00:22:51,884
So, I could simply,

417
00:22:55,724 --> 00:23:00,002
I could simply specify the
folder directly like that

418
00:23:00,002 --> 00:23:02,759
and I could if I wanted
to change the file name.

419
00:23:02,759 --> 00:23:03,985
Another way of doing it and this gives me

420
00:23:03,985 --> 00:23:05,303
a good opportunity to show you.

421
00:23:05,303 --> 00:23:08,688
There is a command called work d-i-r.

422
00:23:08,688 --> 00:23:11,985
This allows you to specify
the working directory.

423
00:23:11,985 --> 00:23:16,152
User local bin and the
benefit of that is that means

424
00:23:16,988 --> 00:23:20,553
any future commands
such as the copy command

425
00:23:20,553 --> 00:23:23,379
and some of the commands that
we're going to see later,

426
00:23:23,379 --> 00:23:27,067
will now all work relative
to that directory.

427
00:23:27,067 --> 00:23:29,052
So, that cleans things up a bit

428
00:23:29,052 --> 00:23:31,060
in a complicated Dockerfile.

429
00:23:31,060 --> 00:23:34,383
So, we can just put in now a dot to say

430
00:23:34,383 --> 00:23:37,680
that it's going outside go
in the working directory.

431
00:23:37,680 --> 00:23:40,491
So, we're almost there with
a working Dockerfile now.

432
00:23:40,491 --> 00:23:44,123
We're not actually
running the Java file yet,

433
00:23:44,123 --> 00:23:46,145
but I think it will be
worth trying to build this

434
00:23:46,145 --> 00:23:48,811
image and see what happens.

435
00:23:48,811 --> 00:23:52,599
So, I'll exit from the previous container

436
00:23:52,599 --> 00:23:55,410
and just rerun the Docker build.

437
00:23:55,410 --> 00:23:58,743
We should have it on or command history.

438
00:24:00,810 --> 00:24:04,099
So, can you see there
that many of these steps

439
00:24:04,099 --> 00:24:05,831
didn't need any work to be done

440
00:24:05,831 --> 00:24:09,232
because the layers were
already in the cache,

441
00:24:09,232 --> 00:24:11,360
but then we had this new instruction

442
00:24:11,360 --> 00:24:13,186
to set a work directory,

443
00:24:13,186 --> 00:24:16,702
it's been copied and that worked okay

444
00:24:16,702 --> 00:24:19,424
and it successful built an image.

445
00:24:19,424 --> 00:24:23,591
So, the big difference now is
if I recall the run command,

446
00:24:26,095 --> 00:24:27,100
that's looking fantastic.

447
00:24:27,100 --> 00:24:31,413
Do you notice that when we
run, when we now run this image

448
00:24:31,413 --> 00:24:32,314
we're not in the root anymore?

449
00:24:32,314 --> 00:24:36,693
We've been dropped directory
into that working directory

450
00:24:36,693 --> 00:24:39,110
and if I do an ls, fantastic,

451
00:24:40,640 --> 00:24:43,540
we have our Java file in place.

452
00:24:43,540 --> 00:24:45,578
I'll exit the container one more time.

453
00:24:45,578 --> 00:24:47,772
We want that programme
to run automatically when

454
00:24:47,772 --> 00:24:52,566
the container starts, and that's
where the CMD command comes

455
00:24:52,566 --> 00:24:57,286
in which not surprisingly
literally stands for command.

456
00:24:57,286 --> 00:24:59,099
Now this is the command that you

457
00:24:59,099 --> 00:25:03,467
want the container to
execute when it starts up.

458
00:25:03,467 --> 00:25:06,222
It's very common for a container

459
00:25:06,222 --> 00:25:08,722
to implement a single service.

460
00:25:09,599 --> 00:25:13,089
For example, you've seen
our Fleetman web app.

461
00:25:13,089 --> 00:25:17,268
The service that it's
running is a tomcat service

462
00:25:17,268 --> 00:25:20,531
which happens to be running
a particular wall file.

463
00:25:20,531 --> 00:25:24,311
It's very common and best
practise for a container to

464
00:25:24,311 --> 00:25:29,213
implement one single service,
and it's this command

465
00:25:29,213 --> 00:25:32,958
which is going to specify
what service is being

466
00:25:32,958 --> 00:25:34,921
offered by this container.

467
00:25:34,921 --> 00:25:39,088
So, if we were to run our jar
file through this command,

468
00:25:40,798 --> 00:25:43,549
then that's what's going
to automatically start up

469
00:25:43,549 --> 00:25:45,371
when we run that container,

470
00:25:45,371 --> 00:25:48,582
and we actually specify
each part of the command

471
00:25:48,582 --> 00:25:50,728
as separate parts.

472
00:25:50,728 --> 00:25:53,600
So, we know we're going
to be running Java,

473
00:25:53,600 --> 00:25:55,252
but then we're going to be passing

474
00:25:55,252 --> 00:25:57,044
in a command line argument,

475
00:25:57,044 --> 00:26:00,127
argument of dash jar and then finally

476
00:26:01,619 --> 00:26:05,786
we'll be passing in an
argument of test program.jar,

477
00:26:07,305 --> 00:26:08,726
and this is actually the preferred

478
00:26:08,726 --> 00:26:10,804
form of specifying this command.

479
00:26:10,804 --> 00:26:12,725
Actually you could've just done command

480
00:26:12,725 --> 00:26:15,171
Java dash jar test program.jar,

481
00:26:15,171 --> 00:26:17,132
but the Docker people recommend that

482
00:26:17,132 --> 00:26:21,097
you this form which is
called the exec form.

483
00:26:21,097 --> 00:26:24,091
I won't get hung up on
the reasons for why.

484
00:26:24,091 --> 00:26:25,706
It is a little bit technical

485
00:26:25,706 --> 00:26:28,308
and not very interesting either.

486
00:26:28,308 --> 00:26:32,488
So, this is going to run Java
dash jar test program.jar

487
00:26:32,488 --> 00:26:34,983
and importantly we don't
need any folders in here

488
00:26:34,983 --> 00:26:39,803
because we're still working
relative to that work dir.

489
00:26:39,803 --> 00:26:43,363
So, I think at last back on the shell

490
00:26:43,363 --> 00:26:45,544
if we rerun that image build,

491
00:26:45,544 --> 00:26:49,461
and then start a new
container from that image,

492
00:26:50,373 --> 00:26:52,588
the big difference this time,

493
00:26:52,588 --> 00:26:54,442
we're not dropped into the bash shell.

494
00:26:54,442 --> 00:26:57,568
It's actually immediately
doing something useful.

495
00:26:57,568 --> 00:27:00,036
Of course, this could be a web server,

496
00:27:00,036 --> 00:27:02,313
a spring boot application.

497
00:27:02,313 --> 00:27:06,798
We're going to look at how to
do that in the next chapters.

498
00:27:06,798 --> 00:27:09,916
That command will continue to execute

499
00:27:09,916 --> 00:27:14,711
until I press control c and
remember from previous work

500
00:27:14,711 --> 00:27:16,381
when we're running interactively,

501
00:27:16,381 --> 00:27:18,856
that will have now killed that container

502
00:27:18,856 --> 00:27:21,096
if we do a Docker container ls.

503
00:27:21,096 --> 00:27:23,137
There's no running container.

504
00:27:23,137 --> 00:27:25,552
It has been stopped.

505
00:27:25,552 --> 00:27:28,298
I've actually been rehearsing earlier,

506
00:27:28,298 --> 00:27:31,225
but this is the one
that I've just stopped.

507
00:27:31,225 --> 00:27:33,163
We can start it again, remember?

508
00:27:33,163 --> 00:27:34,996
Docker container start

509
00:27:36,814 --> 00:27:39,981
and it's the one for me beginning a-e.

510
00:27:41,633 --> 00:27:44,356
Oh, and because I've
not specified dash i-t,

511
00:27:44,356 --> 00:27:46,240
it's now running in the background.

512
00:27:46,240 --> 00:27:50,177
I wonder if you can remember
if we do Docker container logs

513
00:27:50,177 --> 00:27:53,791
we'll do a dash f on a-e, there you are.

514
00:27:53,791 --> 00:27:56,208
You can see the logs running.

515
00:27:57,285 --> 00:28:00,060
Now, I wanted to show you
that this is my implementation

516
00:28:00,060 --> 00:28:02,964
of this programme and it
really is doing nothing more

517
00:28:02,964 --> 00:28:04,716
than doing system.out.

518
00:28:04,716 --> 00:28:06,232
I'm not using log for j.

519
00:28:06,232 --> 00:28:09,324
I'm not using any kind of logging system,

520
00:28:09,324 --> 00:28:12,843
but that's okay because the
way that Docker works is

521
00:28:12,843 --> 00:28:17,811
it captures system.out
standard output in other words,

522
00:28:17,811 --> 00:28:21,644
and it considers that
the log of the container

523
00:28:23,257 --> 00:28:25,451
and it is best practise
when working in Docker

524
00:28:25,451 --> 00:28:28,718
that you don't direct all of the output to

525
00:28:28,718 --> 00:28:32,885
some kind of obscure file
hidden on the Unix file system.

526
00:28:33,741 --> 00:28:36,691
You make sure that your
application by default

527
00:28:36,691 --> 00:28:40,810
spits all of it's output
onto standard output.

528
00:28:40,810 --> 00:28:42,110
It doesn't mean you have to use

529
00:28:42,110 --> 00:28:43,903
system.out in your Java programmes.

530
00:28:43,903 --> 00:28:45,619
You can use log for j as normal,

531
00:28:45,619 --> 00:28:47,809
but you will configure log for j

532
00:28:47,809 --> 00:28:50,226
to output to standard output.

533
00:28:51,605 --> 00:28:53,732
Great, so this time if I do control c

534
00:28:53,732 --> 00:28:56,989
because this version is
running in the detached state,

535
00:28:56,989 --> 00:29:01,511
I think we'll find that the
container is still running,

536
00:29:01,511 --> 00:29:04,511
so I will have to manually stop this

537
00:29:05,399 --> 00:29:07,732
container to make it finish.

538
00:29:09,796 --> 00:29:11,464
So, we've reached a
good point we've now got

539
00:29:11,464 --> 00:29:14,875
a working image defined
by a proper Docker file.

540
00:29:14,875 --> 00:29:17,514
Before we move on to
the next chapter there's

541
00:29:17,514 --> 00:29:21,123
a couple of very minor points
that I want to address.

542
00:29:21,123 --> 00:29:23,472
There's a very common source of confusion

543
00:29:23,472 --> 00:29:25,718
about the difference between copy

544
00:29:25,718 --> 00:29:29,693
and the add command,
and in fact you'll find

545
00:29:29,693 --> 00:29:33,610
for most cases if I run
that image build again,

546
00:29:37,716 --> 00:29:40,363
yeah, that works absolutely
fine, but if I run that

547
00:29:40,363 --> 00:29:44,530
container and if run a container from it,

548
00:29:49,386 --> 00:29:50,910
that's working just fine.

549
00:29:50,910 --> 00:29:51,993
So, it's a bit confusing.

550
00:29:51,993 --> 00:29:53,612
What's the difference
between add and copy.

551
00:29:53,612 --> 00:29:55,544
The answer is there's
not a big difference,

552
00:29:55,544 --> 00:29:58,428
but I definitely should,
but I should be pointing you

553
00:29:58,428 --> 00:30:01,099
on this course to the
Dockerfile reference page

554
00:30:01,099 --> 00:30:03,833
which you can easily find
on the Docker docs page,

555
00:30:03,833 --> 00:30:06,013
and there is here a
complete list of all of

556
00:30:06,013 --> 00:30:09,821
the commands you can do in a Docker file.

557
00:30:09,821 --> 00:30:11,748
We've seen some of them already.

558
00:30:11,748 --> 00:30:14,876
We have the add command here

559
00:30:14,876 --> 00:30:17,709
and we have the copy command here.

560
00:30:19,356 --> 00:30:22,960
Now, though the Dockerfile
references generally very useful,

561
00:30:22,960 --> 00:30:26,310
in this case (chuckling)
it's quite difficult to see

562
00:30:26,310 --> 00:30:27,423
if you compare the two.

563
00:30:27,423 --> 00:30:29,840
They look very, very similar and they are.

564
00:30:29,840 --> 00:30:34,749
It's just that the add command
has some extra features.

565
00:30:34,749 --> 00:30:38,707
For example, add can work with remote URLs

566
00:30:38,707 --> 00:30:40,870
and it also does things like

567
00:30:40,870 --> 00:30:43,537
unzipping or unpacking archives.

568
00:30:44,725 --> 00:30:48,309
Now, therefore it looks like
add is generally more useful

569
00:30:48,309 --> 00:30:51,881
and flexible, but in fact
the Docker people seem to

570
00:30:51,881 --> 00:30:55,629
recommend that copy is preferred
because it's just simpler

571
00:30:55,629 --> 00:30:59,579
and it's more obvious
what copy is going to do.

572
00:30:59,579 --> 00:31:02,175
So, I think I'll follow
suit and I'll recommend

573
00:31:02,175 --> 00:31:04,579
that you should probably stick with copy.

574
00:31:04,579 --> 00:31:08,796
It's really not going to
hurt however, if you use add.

575
00:31:08,796 --> 00:31:11,243
I just wanted to mention it
on the course in case you

576
00:31:11,243 --> 00:31:14,179
think that we're missing
something by not using add.

577
00:31:14,179 --> 00:31:17,762
In a similar vein,
there is as well as CMD,

578
00:31:19,163 --> 00:31:20,544
which we've worked with,

579
00:31:20,544 --> 00:31:23,264
there's also a command
that you'll often see

580
00:31:23,264 --> 00:31:26,474
at the end of a Docker
file called Entrypoint.

581
00:31:26,474 --> 00:31:30,490
It looks very similar to the CMD command

582
00:31:30,490 --> 00:31:33,573
and we can try it if we do Entrypoint

583
00:31:37,677 --> 00:31:39,871
and run the build again and then run

584
00:31:39,871 --> 00:31:41,502
a container from it.

585
00:31:41,502 --> 00:31:45,241
Yeah, it's doing exactly the same thing

586
00:31:45,241 --> 00:31:46,745
as it was doing before,

587
00:31:46,745 --> 00:31:50,740
but the difference is and
this is quite a significant

588
00:31:50,740 --> 00:31:54,573
difference, is that
Entrypoint will always run

589
00:31:55,612 --> 00:31:58,112
whereas CMD is just a default.

590
00:32:00,420 --> 00:32:01,968
Let me illustrate that.

591
00:32:01,968 --> 00:32:05,530
If we switch back to the CMD version,

592
00:32:05,530 --> 00:32:07,594
we run the build again,

593
00:32:07,594 --> 00:32:09,241
and then run a container from it.

594
00:32:09,241 --> 00:32:13,408
Yeah, it works as usual, but
what I haven't mentioned yet

595
00:32:15,093 --> 00:32:18,601
if you're working with
an image that has a CMD,

596
00:32:18,601 --> 00:32:22,768
if you wish, you can change
the command that gets executed.

597
00:32:24,370 --> 00:32:27,944
So, I could instead of
running that Java service,

598
00:32:27,944 --> 00:32:30,258
I could just add on to
the Docker container run

599
00:32:30,258 --> 00:32:32,845
the name of a command.

600
00:32:32,845 --> 00:32:35,791
I'm going for, I don't think
I need the forward slash bin,

601
00:32:35,791 --> 00:32:39,068
but people often do
that so I'll follow suit

602
00:32:39,068 --> 00:32:42,057
and that's going to start
the container from the image,

603
00:32:42,057 --> 00:32:44,585
but it overrides that default command

604
00:32:44,585 --> 00:32:48,371
and as you can see I'm now
dropped on to the command line

605
00:32:48,371 --> 00:32:50,383
and I can start doing diagnostics

606
00:32:50,383 --> 00:32:53,079
or whatever I wanted to do.

607
00:32:53,079 --> 00:32:56,246
I can even manually run that jar file.

608
00:32:58,323 --> 00:33:00,879
So, that's useful if as
the designer of the image,

609
00:33:00,879 --> 00:33:03,849
you've decided that this
is just a default service

610
00:33:03,849 --> 00:33:05,782
that we want to offer from this container,

611
00:33:05,782 --> 00:33:09,322
but we will allow users
to easily override it.

612
00:33:09,322 --> 00:33:12,155
The same isn't true of Entrypoint.

613
00:33:16,255 --> 00:33:19,088
Now, this is a hard coded command.

614
00:33:20,074 --> 00:33:24,143
We rerun the build and then
run a container from it

615
00:33:24,143 --> 00:33:27,512
and notice I've got the bin bash on there,

616
00:33:27,512 --> 00:33:30,436
but this time that will get ignored

617
00:33:30,436 --> 00:33:34,016
and it will run that service regardless.

618
00:33:34,016 --> 00:33:37,120
So, just a few minor points
there on the Dockerfile.

619
00:33:37,120 --> 00:33:40,587
Now, check out the reference
manual on the Dockerfile

620
00:33:40,587 --> 00:33:43,664
and you will find there
are quite a few commands

621
00:33:43,664 --> 00:33:45,384
that we can add into a Dockerfile,

622
00:33:45,384 --> 00:33:47,578
but you'll find for a
lot of day-to-day use

623
00:33:47,578 --> 00:33:51,522
there isn't a lot more to
Dockerfiles than we've seen here.

624
00:33:51,522 --> 00:33:54,309
So, we'll leave it there
and in the next chapter,

625
00:33:54,309 --> 00:33:56,560
we'll move up a level again.

626
00:33:56,560 --> 00:33:59,874
We'll start to run a more
realistic Java application.

627
00:33:59,874 --> 00:34:02,717
This time one using tomcat.

628
00:34:02,717 --> 00:34:06,634
So, have a good break
and I will see you there.

1
00:00:00,878 --> 00:00:02,198
- [Instructor] Hello, and welcome back.

2
00:00:02,198 --> 00:00:04,482
We have a basic Dockerfile now written,

3
00:00:04,482 --> 00:00:07,048
and I hope you found all of
that quite straightforward.

4
00:00:07,048 --> 00:00:10,960
In this chapter, it's time for
things to come together now.

5
00:00:10,960 --> 00:00:14,479
We're going to see how to
run real Java applications

6
00:00:14,479 --> 00:00:16,312
in a Docker container.

7
00:00:17,603 --> 00:00:19,671
Once again, in the
Practicals and Code folder

8
00:00:19,671 --> 00:00:21,108
for this course, which you can find by

9
00:00:21,108 --> 00:00:24,598
downloading from the course page,

10
00:00:24,598 --> 00:00:28,016
there's a folder in
there called Chapter 7.

11
00:00:28,016 --> 00:00:30,084
And inside there I've
given you the Java project

12
00:00:30,084 --> 00:00:31,622
for Fleetman webapp.

13
00:00:31,622 --> 00:00:33,182
Now, many of you will
have already worked on

14
00:00:33,182 --> 00:00:34,680
Fleetman webapp on previous

15
00:00:34,680 --> 00:00:36,803
Virtual Pair Programmers courses.

16
00:00:36,803 --> 00:00:39,368
In fact, this is a refined version,

17
00:00:39,368 --> 00:00:41,411
which I've made a few changes to,

18
00:00:41,411 --> 00:00:43,813
so even if you're
familiar with this webapp

19
00:00:43,813 --> 00:00:46,860
then you will need to download it.

20
00:00:46,860 --> 00:00:49,400
So as usual, I will take
you through the steps

21
00:00:49,400 --> 00:00:50,820
of mounting this in Eclipse.

22
00:00:50,820 --> 00:00:52,103
I know it's straightforward,

23
00:00:52,103 --> 00:00:54,084
but I don't want any support calls.

24
00:00:54,084 --> 00:00:56,789
So copy the Fleetman webapp folder

25
00:00:56,789 --> 00:01:00,372
into a workspace folder
any way you'd like,

26
00:01:01,311 --> 00:01:05,375
and then open up the
workspace in Eclipse as usual.

27
00:01:05,375 --> 00:01:06,909
You can use your own
development environment

28
00:01:06,909 --> 00:01:11,076
if you prefer, there's no
specific reason for using Eclipse

29
00:01:11,923 --> 00:01:14,770
other than it's just
a good default for us.

30
00:01:14,770 --> 00:01:16,547
If you're looking at
Eclipse, it's a bit awkward

31
00:01:16,547 --> 00:01:19,126
to open an existing project.

32
00:01:19,126 --> 00:01:23,960
The easiest way, I find,
is File, New, Java Project,

33
00:01:23,960 --> 00:01:26,681
even though the project already exists,

34
00:01:26,681 --> 00:01:29,866
and the important thing
is to use exactly the same

35
00:01:29,866 --> 00:01:33,424
project name, Fleetman dash webapp,

36
00:01:33,424 --> 00:01:35,610
and as soon as you type
that last character there

37
00:01:35,610 --> 00:01:39,469
it will offer to automatically
configure the JRE

38
00:01:39,469 --> 00:01:41,527
and you'll be able to click Finish.

39
00:01:41,527 --> 00:01:43,762
If that doesn't happen,
check your spelling

40
00:01:43,762 --> 00:01:47,925
of Fleetman dash webapp,
and make sure that

41
00:01:47,925 --> 00:01:50,376
the workspace folder that you're using

42
00:01:50,376 --> 00:01:55,013
contains the folder called
Fleetman dash webapp.

43
00:01:55,013 --> 00:01:58,935
Click on Finish, and we're good to go.

44
00:01:58,935 --> 00:02:01,692
This is actually a standard
Spring Boot application.

45
00:02:01,692 --> 00:02:03,444
The first task we'll need to follow is

46
00:02:03,444 --> 00:02:06,611
to right-click on the pom.xml, Run As,

47
00:02:07,462 --> 00:02:11,629
Maven build, and then in the
Goals, eclipse colon eclipse.

48
00:02:14,303 --> 00:02:16,413
I realise, of course, you'll
be familiar with all of this

49
00:02:16,413 --> 00:02:18,318
if you worked on Spring Boot before,

50
00:02:18,318 --> 00:02:19,943
but I just want to be
careful and make sure

51
00:02:19,943 --> 00:02:23,042
that I've covered every step.

52
00:02:23,042 --> 00:02:25,926
Then once that's run,
right-click on your project,

53
00:02:25,926 --> 00:02:28,745
select Refresh, and you should now have

54
00:02:28,745 --> 00:02:31,589
a clean compile in Eclipse.

55
00:02:31,589 --> 00:02:32,845
And all we're going to do now

56
00:02:32,845 --> 00:02:35,129
is run this application locally.

57
00:02:35,129 --> 00:02:39,143
Now, this is part of a much
bigger microservice architecture

58
00:02:39,143 --> 00:02:41,545
that we've built in previous courses,

59
00:02:41,545 --> 00:02:44,730
and it does really depend
on other microservices

60
00:02:44,730 --> 00:02:46,483
being up and running.

61
00:02:46,483 --> 00:02:49,607
But the main tweaks I've
done with this project is

62
00:02:49,607 --> 00:02:53,721
I've given it a kind of
stand-alone mode in development,

63
00:02:53,721 --> 00:02:56,742
and the way that works,
just to fill you in,

64
00:02:56,742 --> 00:02:59,537
is if we look under source main java,

65
00:02:59,537 --> 00:03:02,126
under the Services package,

66
00:03:02,126 --> 00:03:05,293
I've provided a stub implementation of

67
00:03:06,304 --> 00:03:08,375
one of the microservices.

68
00:03:08,375 --> 00:03:11,462
So if we're running under
the profile of development

69
00:03:11,462 --> 00:03:15,629
or Docker demo, you'll see
why that's important shortly.

70
00:03:16,745 --> 00:03:19,767
Instead of going out to
some external service

71
00:03:19,767 --> 00:03:23,308
to get the data for the vehicles, instead,

72
00:03:23,308 --> 00:03:27,016
it just generates some
random data for the vehicles,

73
00:03:27,016 --> 00:03:29,403
and that's why you'll have
seen in earlier chapters

74
00:03:29,403 --> 00:03:33,416
those vehicles just bouncing
around in a very strange way.

75
00:03:33,416 --> 00:03:35,777
Now, I'm really looking
forward to the second module

76
00:03:35,777 --> 00:03:37,022
in this course.

77
00:03:37,022 --> 00:03:39,029
We're going to bring
all of the microservices

78
00:03:39,029 --> 00:03:41,329
together in Docker, and
then you're going to see

79
00:03:41,329 --> 00:03:45,215
lots of vehicles all
moving around properly.

80
00:03:45,215 --> 00:03:46,967
But for now, this will be enough.

81
00:03:46,967 --> 00:03:48,313
Now, the only problem with that is if

82
00:03:48,313 --> 00:03:50,356
you want to run the application,

83
00:03:50,356 --> 00:03:53,683
you can right-click, of course,
on Fleetman Application,

84
00:03:53,683 --> 00:03:55,683
Run As Java Application.

85
00:03:57,772 --> 00:03:59,663
But because we haven't set that profile

86
00:03:59,663 --> 00:04:02,546
and it's not the default profile,

87
00:04:02,546 --> 00:04:06,345
you will get a crash,
application failed to start

88
00:04:06,345 --> 00:04:08,325
because it can't find an implementation

89
00:04:08,325 --> 00:04:10,990
of that position tracker.

90
00:04:10,990 --> 00:04:13,532
So the solution to that is we need to

91
00:04:13,532 --> 00:04:17,449
Run As and then Run
Configurations dot dot dot.

92
00:04:19,221 --> 00:04:22,726
And then click on Java
Application and then

93
00:04:22,726 --> 00:04:26,267
the button here will create
a new launch configuration

94
00:04:26,267 --> 00:04:30,193
and then the key thing is under Arguments,

95
00:04:30,193 --> 00:04:33,022
importantly, under VM Arguments,

96
00:04:33,022 --> 00:04:36,939
dash capital D, spring
dot profiles dot active,

97
00:04:38,711 --> 00:04:40,294
equals development.

98
00:04:41,480 --> 00:04:44,273
I'm sure we've covered that on
previous Spring Boot courses,

99
00:04:44,273 --> 00:04:46,798
but that will just set an active profile

100
00:04:46,798 --> 00:04:49,378
and the difference now should be

101
00:04:49,378 --> 00:04:50,749
everything's up and running,

102
00:04:50,749 --> 00:04:53,151
it's running on port 8080,

103
00:04:53,151 --> 00:04:55,295
in your browser, the application that

104
00:04:55,295 --> 00:04:57,530
you are familiar with by now.

105
00:04:57,530 --> 00:04:59,433
So one of the objectives is to show you

106
00:04:59,433 --> 00:05:03,707
how to deploy WAR files
into a Docker container,

107
00:05:03,707 --> 00:05:06,983
probably a Docker
container running Tomcat.

108
00:05:06,983 --> 00:05:09,040
Now, slight difficulty here is that

109
00:05:09,040 --> 00:05:11,246
this is a Spring Boot application,

110
00:05:11,246 --> 00:05:13,877
and as you will know if you've
worked with Spring Boot,

111
00:05:13,877 --> 00:05:15,948
Spring Boot doesn't need WAR files

112
00:05:15,948 --> 00:05:19,032
and it doesn't need to
be deployed to Tomcat.

113
00:05:19,032 --> 00:05:21,062
So for that reason, I've
fiddled around a little bit

114
00:05:21,062 --> 00:05:24,899
and I've bent this application so that

115
00:05:24,899 --> 00:05:27,743
it can be run as a WAR file.

116
00:05:27,743 --> 00:05:29,279
There's full details on how to do this

117
00:05:29,279 --> 00:05:31,312
in the Spring Boot reference manual,

118
00:05:31,312 --> 00:05:34,615
but the basics of it are really that

119
00:05:34,615 --> 00:05:38,198
you need an application
class which extends

120
00:05:39,583 --> 00:05:42,744
Spring Boot Servlet Initializer.

121
00:05:42,744 --> 00:05:45,130
And it has this method inside it.

122
00:05:45,130 --> 00:05:46,934
It's just a little bit of magic, really,

123
00:05:46,934 --> 00:05:50,276
that you need to do according
to the reference manual.

124
00:05:50,276 --> 00:05:53,853
And I've made a change in the pom.xml.

125
00:05:53,853 --> 00:05:58,020
Looking all the way down
to the Spring Boot plugin,

126
00:05:59,935 --> 00:06:03,539
the Maven plugin here, you
have a configuration where

127
00:06:03,539 --> 00:06:05,114
the main class is pointing to

128
00:06:05,114 --> 00:06:07,944
that class that we've just seen.

129
00:06:07,944 --> 00:06:10,803
The line I've commented
out here is just in place

130
00:06:10,803 --> 00:06:13,531
for if we did want to
go back to running this

131
00:06:13,531 --> 00:06:15,614
as a standalone JAR file.

132
00:06:16,949 --> 00:06:19,525
So I've done that just so
if you're in the position

133
00:06:19,525 --> 00:06:21,505
of having a WAR file and you want to know

134
00:06:21,505 --> 00:06:25,736
how to deploy it to a
Tomcat-based Docker container,

135
00:06:25,736 --> 00:06:27,387
then I can show you how.

136
00:06:27,387 --> 00:06:30,434
Let's stop the running
application and we can

137
00:06:30,434 --> 00:06:34,295
right-click on the POM,
we'll run a Maven build,

138
00:06:34,295 --> 00:06:37,571
and this time we're going
to run the package goal,

139
00:06:37,571 --> 00:06:40,154
which will generate a WAR file.

140
00:06:41,304 --> 00:06:43,118
Well, I'm glad this has happened,

141
00:06:43,118 --> 00:06:45,594
because we do get some
support calls about this.

142
00:06:45,594 --> 00:06:49,620
By default, Eclipse is running
its own private Java runtime,

143
00:06:49,620 --> 00:06:51,996
and unless we do some configuration,

144
00:06:51,996 --> 00:06:56,163
Maven can't find the Java
compiler, hence the error here.

145
00:06:57,025 --> 00:06:59,296
So I'll keep this in the video,

146
00:06:59,296 --> 00:07:00,936
I know we've got it in other courses,

147
00:07:00,936 --> 00:07:04,212
but you need to go to Window Preferences

148
00:07:04,212 --> 00:07:07,045
and then find, under the Java tab,

149
00:07:08,225 --> 00:07:12,451
and I think that will be
on the Apple menu on a Mac.

150
00:07:12,451 --> 00:07:16,451
And then under the Java
tab, go to Intalled JREs

151
00:07:19,425 --> 00:07:22,902
an then click on Add, select Standard VM,

152
00:07:22,902 --> 00:07:25,860
and then on the directory button here

153
00:07:25,860 --> 00:07:28,777
browse to your installation of JDK,

154
00:07:31,242 --> 00:07:34,851
which will be under Programme Files, Java,

155
00:07:34,851 --> 00:07:37,964
and then whichever version
of Java you're working on.

156
00:07:37,964 --> 00:07:40,464
So I'll go for this JDK 1.8.0.

157
00:07:42,406 --> 00:07:45,710
Make sure this is a JDK and not a JRE.

158
00:07:45,710 --> 00:07:47,728
If you don't have one of
those, then you will need

159
00:07:47,728 --> 00:07:51,895
to go to the Oracle site to
download the JDK and instal it.

160
00:07:53,025 --> 00:07:55,778
Click on OK, click on Finish,

161
00:07:55,778 --> 00:08:00,172
and then click on the checkbox
here to switch the JDK,

162
00:08:00,172 --> 00:08:02,879
click on OK, and now
on the Run button here

163
00:08:02,879 --> 00:08:04,962
we can re-run that build.

164
00:08:08,542 --> 00:08:10,893
And all being well,
that will be a success,

165
00:08:10,893 --> 00:08:15,185
and you should now have, in
the projects target directory,

166
00:08:15,185 --> 00:08:18,244
a WAR file for your application.

167
00:08:18,244 --> 00:08:19,604
Well, we saw in the previous chapter

168
00:08:19,604 --> 00:08:21,368
how to write a Dockerfile.

169
00:08:21,368 --> 00:08:23,211
This was the very basic Dockerfile

170
00:08:23,211 --> 00:08:26,639
that we started with before,
and this one is presumably

171
00:08:26,639 --> 00:08:29,230
going to be quite a bit
more complicated than this,

172
00:08:29,230 --> 00:08:31,846
but the pattern's pretty much the same.

173
00:08:31,846 --> 00:08:34,233
We're going to start by
deciding which base image

174
00:08:34,233 --> 00:08:35,731
we should begin with.

175
00:08:35,731 --> 00:08:39,476
We'll add a line for the
maintainer, which will be yourself.

176
00:08:39,476 --> 00:08:41,776
And then we'll add in a run command for

177
00:08:41,776 --> 00:08:45,037
any extra commands that we
want to run in that container

178
00:08:45,037 --> 00:08:47,806
and then we need to think
about what the final command

179
00:08:47,806 --> 00:08:51,183
is going to be, the default
command that we want to run

180
00:08:51,183 --> 00:08:52,936
for this container.

181
00:08:52,936 --> 00:08:55,084
So let's start with the base image.

182
00:08:55,084 --> 00:08:56,938
And we could do what we did
in the previous chapter,

183
00:08:56,938 --> 00:08:59,807
we could start from something like Ubuntu

184
00:08:59,807 --> 00:09:03,681
or maybe even one of the
much smaller distributions

185
00:09:03,681 --> 00:09:08,087
like Alpine, and then we
could run lots of commands.

186
00:09:08,087 --> 00:09:11,211
We could instal the JDK,
we could instal Tomcat,

187
00:09:11,211 --> 00:09:13,232
and we could transfer config files across

188
00:09:13,232 --> 00:09:14,995
and all the rest of it.

189
00:09:14,995 --> 00:09:17,320
But I hope you've got the feeling by now

190
00:09:17,320 --> 00:09:20,100
that that's probably not necessary,

191
00:09:20,100 --> 00:09:22,015
because there's going to be some kind of

192
00:09:22,015 --> 00:09:25,941
pre-defined image that will
probably do the work for us.

193
00:09:25,941 --> 00:09:30,436
We know Tomcat is used the world
over for Java applications.

194
00:09:30,436 --> 00:09:33,039
I bet somebody's already done one.

195
00:09:33,039 --> 00:09:34,745
And many of you will have
done this as an exercise

196
00:09:34,745 --> 00:09:35,630
earlier in the course.

197
00:09:35,630 --> 00:09:38,714
If we search for Tomcat on Docker Hub,

198
00:09:38,714 --> 00:09:43,691
we will find there is an
official Tomcat image available.

199
00:09:43,691 --> 00:09:46,612
And clicking through to that,
the only complex thing is

200
00:09:46,612 --> 00:09:50,715
there are a lot of tags
associated with this image

201
00:09:50,715 --> 00:09:52,976
because there are so
many different versions.

202
00:09:52,976 --> 00:09:56,339
Now, just in case you didn't
do that Tomcat exercise,

203
00:09:56,339 --> 00:10:00,506
I just want to restate that it
is possible for every image,

204
00:10:01,814 --> 00:10:05,303
for every repository, to
have a collection of tags,

205
00:10:05,303 --> 00:10:08,910
which is really just different
images that are fulfilling

206
00:10:08,910 --> 00:10:12,085
the same goal but maybe in different ways.

207
00:10:12,085 --> 00:10:15,857
So clearly here it's
different versions of Tomcat,

208
00:10:15,857 --> 00:10:17,723
from six through to nine,

209
00:10:17,723 --> 00:10:20,890
combined with different Java versions.

210
00:10:23,095 --> 00:10:25,926
And also there are a few
versions which are tagged

211
00:10:25,926 --> 00:10:27,642
dash alpine.

212
00:10:27,642 --> 00:10:31,642
Alpine is a very cut down
distribution of Linux,

213
00:10:32,580 --> 00:10:35,007
very useful if you want
to keep your containers

214
00:10:35,007 --> 00:10:37,914
as small as possible, and you probably do,

215
00:10:37,914 --> 00:10:39,723
because we want to be able to

216
00:10:39,723 --> 00:10:42,074
easily transport these containers.

217
00:10:42,074 --> 00:10:44,538
So if you don't want much
in the way of Linux tooling

218
00:10:44,538 --> 00:10:47,001
in your container, then
why not just go for

219
00:10:47,001 --> 00:10:49,084
the Alpine distribution?

220
00:10:49,084 --> 00:10:51,724
I think we'll do that in this practical.

221
00:10:51,724 --> 00:10:55,329
So I don't want an old version of Tomcat,

222
00:10:55,329 --> 00:10:57,309
and at the time of recording,

223
00:10:57,309 --> 00:11:00,059
the version nines are milestones.

224
00:11:00,928 --> 00:11:02,987
They might be official by
the time you watch this.

225
00:11:02,987 --> 00:11:05,907
But I'm going to go for
the most recent version

226
00:11:05,907 --> 00:11:09,666
which is released, and
for me, that's the 8.5.

227
00:11:09,666 --> 00:11:12,373
Now, actually, it's 8.5.16,

228
00:11:12,373 --> 00:11:16,373
but all of these tags
here on this bullet point,

229
00:11:18,087 --> 00:11:21,613
all of those tags are
aliases for the same thing.

230
00:11:21,613 --> 00:11:24,917
While we could use Tomcat colon Alpine,

231
00:11:24,917 --> 00:11:29,182
I'm going to do Tomcat
colon eight dash Alpine,

232
00:11:29,182 --> 00:11:33,833
just to emphasise that we are
using version eight of Tomcat.

233
00:11:33,833 --> 00:11:36,434
It's just going to be
clearer to a maintainer.

234
00:11:36,434 --> 00:11:39,634
If you're interested, you
can follow the link here,

235
00:11:39,634 --> 00:11:42,138
and that will take you to the Dockerfile

236
00:11:42,138 --> 00:11:44,790
that was used to build this image.

237
00:11:44,790 --> 00:11:49,424
Now, this Dockerfile is
significantly more complicated

238
00:11:49,424 --> 00:11:52,837
than the Dockerfiles
that we've been using,

239
00:11:52,837 --> 00:11:54,414
but actually, if you look through it,

240
00:11:54,414 --> 00:11:57,044
there's some fairly complex shell commands

241
00:11:57,044 --> 00:11:59,941
that they used to get
Tomcat in a good state.

242
00:11:59,941 --> 00:12:02,734
Other than that, it's really nothing more

243
00:12:02,734 --> 00:12:05,274
than we've done on the previous chapter.

244
00:12:05,274 --> 00:12:08,104
Have a look at that if you're interested.

245
00:12:08,104 --> 00:12:10,034
So we're going to write
a new Dockerfile, then,

246
00:12:10,034 --> 00:12:11,598
and I hope you're following along with me.

247
00:12:11,598 --> 00:12:13,895
We need to think about
where to put the Dockerfile.

248
00:12:13,895 --> 00:12:16,576
It's not probably the
best place to put it,

249
00:12:16,576 --> 00:12:18,912
but for now it will do.

250
00:12:18,912 --> 00:12:23,289
I'm going to put the Dockerfile
in the root of the project.

251
00:12:23,289 --> 00:12:25,998
So this is just going to be New, File,

252
00:12:25,998 --> 00:12:29,665
and it's called Dockerfile
with a capital D.

253
00:12:34,060 --> 00:12:36,500
You'll see in a few moments
why this isn't really

254
00:12:36,500 --> 00:12:38,711
the best place to put that file,

255
00:12:38,711 --> 00:12:40,616
but I'll leave that for now.

256
00:12:40,616 --> 00:12:43,025
So then we are going to build an image

257
00:12:43,025 --> 00:12:45,608
from the standard Tomcat image,

258
00:12:47,127 --> 00:12:49,566
but this is going to be from the tag,

259
00:12:49,566 --> 00:12:51,573
so there's the colon.

260
00:12:51,573 --> 00:12:53,046
Well, actually, thinking about it,

261
00:12:53,046 --> 00:12:56,576
I'm going to use this
form, the very long form.

262
00:12:56,576 --> 00:13:00,322
Remember, these are all
aliases to the same image,

263
00:13:00,322 --> 00:13:04,474
but I just think putting
the full long version in

264
00:13:04,474 --> 00:13:07,166
is going to be better for
maintenance programmers.

265
00:13:07,166 --> 00:13:11,333
Another reason is if they
produce an 8.5.17 version,

266
00:13:12,703 --> 00:13:15,522
then they'll probably remove this label.

267
00:13:15,522 --> 00:13:18,950
We can still use it, but
they'll remove this label

268
00:13:18,950 --> 00:13:23,033
from here, but the 8.5
will be updated to 8.5.17.

269
00:13:26,404 --> 00:13:28,946
I would rather fix a version,
so that's another reason

270
00:13:28,946 --> 00:13:31,232
for being specific about which version

271
00:13:31,232 --> 00:13:33,746
of the image you're using.

272
00:13:33,746 --> 00:13:37,913
The other easy line is we need
a line for the maintainer.

273
00:13:39,772 --> 00:13:41,105
That will be me.

274
00:13:42,990 --> 00:13:45,386
Obviously, put your own details in there.

275
00:13:45,386 --> 00:13:47,369
Now, what do we need to
put in this Dockerfile?

276
00:13:47,369 --> 00:13:50,671
The answer is really just by
adding little bits and pieces

277
00:13:50,671 --> 00:13:53,554
and then try it, and then
building an image from it,

278
00:13:53,554 --> 00:13:56,942
seeing if it's what they
need, and then modifying.

279
00:13:56,942 --> 00:13:59,549
So I'm going to suggest
that we do nothing more

280
00:13:59,549 --> 00:14:02,299
than the final command statement.

281
00:14:03,609 --> 00:14:05,122
Well, the command we're
going to need in here

282
00:14:05,122 --> 00:14:08,296
is going to be the command to run Tomcat.

283
00:14:08,296 --> 00:14:11,649
Without that, this container
isn't going to do anything.

284
00:14:11,649 --> 00:14:14,467
And so there's two possibilities, really.

285
00:14:14,467 --> 00:14:16,930
Perhaps you're experienced with Tomcat

286
00:14:16,930 --> 00:14:19,943
and you know the command to run Tomcat,

287
00:14:19,943 --> 00:14:23,193
or, far more likely, I would suggest,

288
00:14:23,193 --> 00:14:26,924
look at the reference
information for this image.

289
00:14:26,924 --> 00:14:31,738
If you check in here, it's
pretty much the first line,

290
00:14:31,738 --> 00:14:33,301
how to use this image.

291
00:14:33,301 --> 00:14:37,441
The command you're looking
for is catalina.sh,

292
00:14:37,441 --> 00:14:40,689
with the command line argument of run.

293
00:14:40,689 --> 00:14:43,253
Now, I know many of you will
have run Tomcat locally,

294
00:14:43,253 --> 00:14:46,608
and you might be used to
using the startup script.

295
00:14:46,608 --> 00:14:49,414
Now, that would be fine, sort of,

296
00:14:49,414 --> 00:14:53,286
but the startup script
actually redirects output

297
00:14:53,286 --> 00:14:55,966
into a collection of log files.

298
00:14:55,966 --> 00:14:58,697
As I mentioned previously on the course,

299
00:14:58,697 --> 00:15:01,196
in a Docker container,
what you really want is

300
00:15:01,196 --> 00:15:04,209
the output to be output to standard output

301
00:15:04,209 --> 00:15:08,578
and then Docker can catch
that and treat it as a log.

302
00:15:08,578 --> 00:15:12,463
And it's why, for that
reason, we run catalina.sh,

303
00:15:12,463 --> 00:15:14,199
which is a low-level script, really,

304
00:15:14,199 --> 00:15:17,517
that directly runs Tomcat,
and all of the output

305
00:15:17,517 --> 00:15:19,767
will go to standard output.

306
00:15:20,793 --> 00:15:23,521
So that's exactly what we'll do.

307
00:15:23,521 --> 00:15:27,188
Catilina.sh and the
second parameter of run.

308
00:15:29,860 --> 00:15:31,395
Quite a bit more to do on this,

309
00:15:31,395 --> 00:15:34,152
but let's check that image
before we go any further.

310
00:15:34,152 --> 00:15:36,601
So in the PowerShell,
navigate to the folder

311
00:15:36,601 --> 00:15:39,990
you're working in, and
there's the Dockerfile

312
00:15:39,990 --> 00:15:41,365
that we're building.

313
00:15:41,365 --> 00:15:44,754
So this is going to be docker image build.

314
00:15:44,754 --> 00:15:48,233
We need to tag this image,
so I'm going to call this

315
00:15:48,233 --> 00:15:52,233
fleetman dash webapp, and
we need the full stop.

316
00:15:54,938 --> 00:15:58,074
Now, that's quite relevant here,
because remember that means

317
00:15:58,074 --> 00:16:01,236
that all of the files in this folder,

318
00:16:01,236 --> 00:16:04,534
so all of these and all of the subfolders,

319
00:16:04,534 --> 00:16:08,957
are going to be visible to
Docker when it builds this image.

320
00:16:08,957 --> 00:16:10,429
Now, what that means is,

321
00:16:10,429 --> 00:16:13,179
I hope the video will catch this.

322
00:16:14,845 --> 00:16:15,678
See this?

323
00:16:16,675 --> 00:16:19,460
Sending build context to Docker daemon.

324
00:16:19,460 --> 00:16:23,627
So what happened there was,
all of the code in my project

325
00:16:24,641 --> 00:16:29,416
was all kind of zipped up and
was sent across to Docker.

326
00:16:29,416 --> 00:16:32,843
Now, I don't mean sent
across over the internet.

327
00:16:32,843 --> 00:16:35,376
I actually just mean to the daemon process

328
00:16:35,376 --> 00:16:39,287
that we're running here locally
on the development machine.

329
00:16:39,287 --> 00:16:41,939
And it's not actually
that much of a problem.

330
00:16:41,939 --> 00:16:44,848
It just meant that I had to
wait three or four seconds

331
00:16:44,848 --> 00:16:48,049
while that happened, so
that was quite inefficient.

332
00:16:48,049 --> 00:16:50,752
We're gonna be constantly
rebuilding these images,

333
00:16:50,752 --> 00:16:52,917
so going forward, I think
we should think about

334
00:16:52,917 --> 00:16:57,300
moving this Dockerfile to
somewhere more sensible.

335
00:16:57,300 --> 00:16:59,977
But for now, it will be okay.

336
00:16:59,977 --> 00:17:03,304
Well, I see that we have an error already,

337
00:17:03,304 --> 00:17:04,992
an unknown instruction.

338
00:17:04,992 --> 00:17:09,159
I think it's just I should've
put a space after the cmd.

339
00:17:10,760 --> 00:17:11,593
Doh!

340
00:17:12,650 --> 00:17:13,983
Let's try again.

341
00:17:15,850 --> 00:17:17,476
So yeah.

342
00:17:17,476 --> 00:17:21,387
A bit of a pause, but
now, we're up and running.

343
00:17:21,387 --> 00:17:23,788
This is the first time
I've used the Alpine image

344
00:17:23,788 --> 00:17:26,404
on this machine, so this entire image

345
00:17:26,404 --> 00:17:28,780
needs to be downloaded.

346
00:17:28,780 --> 00:17:30,442
And great, that ran through okay.

347
00:17:30,442 --> 00:17:32,271
I think I'll try to run this.

348
00:17:32,271 --> 00:17:37,212
So docker container run
and we'll run interactively

349
00:17:37,212 --> 00:17:40,295
on the terminal fleetman dash webapp.

350
00:17:44,055 --> 00:17:45,797
Okay, well, the good thing here is

351
00:17:45,797 --> 00:17:48,260
that we're seeing lots of Tomcat logging.

352
00:17:48,260 --> 00:17:51,291
It took about one second to start up,

353
00:17:51,291 --> 00:17:54,047
so it's clearly doing something.

354
00:17:54,047 --> 00:17:58,150
Now, you can probably
spot my mistake, however.

355
00:17:58,150 --> 00:18:02,377
If I visit local host 8080,
I'm not seeing anything.

356
00:18:02,377 --> 00:18:04,942
Be careful, by the way, to make sure that

357
00:18:04,942 --> 00:18:08,106
you're not running the
Fleetman project locally,

358
00:18:08,106 --> 00:18:11,164
so make sure this has been stopped.

359
00:18:11,164 --> 00:18:14,273
You know exactly why
we're not seeing anything.

360
00:18:14,273 --> 00:18:17,463
If we cancel that, notice
because we're running

361
00:18:17,463 --> 00:18:20,155
interactively when we press Control C,

362
00:18:20,155 --> 00:18:23,903
the Tomcat container
here is being destroyed.

363
00:18:23,903 --> 00:18:26,671
And the reason is if I recall the command,

364
00:18:26,671 --> 00:18:28,841
we would need to publish the ports.

365
00:18:28,841 --> 00:18:33,008
We would need a dash p 8080
colon 8080, for example.

366
00:18:40,765 --> 00:18:43,672
And if we refresh that page, great.

367
00:18:43,672 --> 00:18:47,482
We are now seeing the
default Tomcat homepage.

368
00:18:47,482 --> 00:18:49,967
So that's a good start.

369
00:18:49,967 --> 00:18:52,206
Now, one thing that you will commonly see

370
00:18:52,206 --> 00:18:55,065
in Dockerfiles is a line like this.

371
00:18:55,065 --> 00:18:56,065
Expose 8080.

372
00:18:57,869 --> 00:18:59,469
And just by reading that, you can,

373
00:18:59,469 --> 00:19:02,364
I hope you can guess what it's saying.

374
00:19:02,364 --> 00:19:04,973
It's saying that this
container is going to

375
00:19:04,973 --> 00:19:06,390
expose port 8080.

376
00:19:07,872 --> 00:19:09,414
And you do need to do that.

377
00:19:09,414 --> 00:19:11,837
If you want to use a port in a container,

378
00:19:11,837 --> 00:19:14,722
you do need that expose line.

379
00:19:14,722 --> 00:19:19,228
But we didn't need it,
and the simple reason why

380
00:19:19,228 --> 00:19:21,731
we didn't need it is
all of the declarations

381
00:19:21,731 --> 00:19:25,731
from the base image are
inherited by this image.

382
00:19:26,785 --> 00:19:29,630
And if we go back to Docker Hub,

383
00:19:29,630 --> 00:19:33,047
and we'll go back up to the list of tags.

384
00:19:34,263 --> 00:19:36,066
So this is the one we're using here,

385
00:19:36,066 --> 00:19:39,407
and we can follow the
link into the Dockerfile.

386
00:19:39,407 --> 00:19:42,074
And somewhere in there, I think,

387
00:19:43,761 --> 00:19:46,617
yeah, it's near the bottom, it's line 90.

388
00:19:46,617 --> 00:19:50,934
They have the expose 8080 line in already.

389
00:19:50,934 --> 00:19:53,158
But if they didn't for any reason,

390
00:19:53,158 --> 00:19:56,902
then we would've needed
to include it for ourself.

391
00:19:56,902 --> 00:19:58,765
Now, my own personal practise is,

392
00:19:58,765 --> 00:20:01,139
I'm going to put that in anyway,

393
00:20:01,139 --> 00:20:04,060
just because I think it's good
for maintenance programmers

394
00:20:04,060 --> 00:20:06,929
looking at this image,
they can immediately see,

395
00:20:06,929 --> 00:20:11,096
this container has a service
inside it which uses port 8080.

396
00:20:12,734 --> 00:20:16,901
But I should stress, if
we go back to the console,

397
00:20:18,053 --> 00:20:22,136
and I'll run that build
again, rebuild the image.

398
00:20:26,906 --> 00:20:31,073
So we now have an additional
step, which is step three.

399
00:20:33,052 --> 00:20:36,859
I want to stress when we go
back to running the container,

400
00:20:36,859 --> 00:20:39,512
this is just the internal
port that's being used

401
00:20:39,512 --> 00:20:43,577
internally in the
container, this 8080 here.

402
00:20:43,577 --> 00:20:46,218
We can still absolutely,
no problem at all,

403
00:20:46,218 --> 00:20:50,385
map that to a public port
of port 80, for example.

404
00:20:54,472 --> 00:20:57,509
That's running okay,
and now on my browser,

405
00:20:57,509 --> 00:21:01,676
port 8080, if I refresh here,
is not going to be visible,

406
00:21:02,853 --> 00:21:07,017
but port 80, and of course,
I don't need the 80,

407
00:21:07,017 --> 00:21:10,233
it's the default, is
being forwarded correctly

408
00:21:10,233 --> 00:21:11,983
to the internal 8080.

409
00:21:13,457 --> 00:21:16,390
Well, that's a start, but of course,

410
00:21:16,390 --> 00:21:19,869
we need to deploy our
application to this Tomcat,

411
00:21:19,869 --> 00:21:21,520
and what we're seeing here on the root is

412
00:21:21,520 --> 00:21:24,108
definitely not what we need.

413
00:21:24,108 --> 00:21:26,690
Now, I don't know how much
you know about Tomcat.

414
00:21:26,690 --> 00:21:28,098
We will have covered this on previous

415
00:21:28,098 --> 00:21:30,550
Virtual Pair Programmers courses.

416
00:21:30,550 --> 00:21:31,922
I'll assume for simplicity that you're

417
00:21:31,922 --> 00:21:33,776
relatively new to Tomcat.

418
00:21:33,776 --> 00:21:36,239
What I'm going to do is,
back on the command line,

419
00:21:36,239 --> 00:21:38,779
if we cancel that temporary container.

420
00:21:38,779 --> 00:21:41,242
I'm going to, let's clear down.

421
00:21:41,242 --> 00:21:43,325
I'm going to run that container again,

422
00:21:43,325 --> 00:21:45,230
but I'll take out the dash it

423
00:21:45,230 --> 00:21:48,730
and we'll run it in detached mode instead.

424
00:21:49,812 --> 00:21:53,979
And the reason for that is I
can do a docker container logs,

425
00:21:57,379 --> 00:22:00,629
and the ID of that container begins 03.

426
00:22:01,556 --> 00:22:04,629
Yep, so it's started up successfully.

427
00:22:04,629 --> 00:22:07,053
But you'll remember from
previously that we can,

428
00:22:07,053 --> 00:22:09,201
if you like, connect
to a running container

429
00:22:09,201 --> 00:22:11,537
by using the exec command.

430
00:22:11,537 --> 00:22:14,291
So it's a bit of a mouthful, this one.

431
00:22:14,291 --> 00:22:16,791
Docker container exec dash it,

432
00:22:20,045 --> 00:22:22,102
followed by the ID of the container

433
00:22:22,102 --> 00:22:24,185
that we're connecting to.

434
00:22:26,215 --> 00:22:30,382
I'll just scroll up to remind
myself the ID began 03.

435
00:22:32,083 --> 00:22:34,227
And then the command
that we want to execute

436
00:22:34,227 --> 00:22:36,147
on that container.

437
00:22:36,147 --> 00:22:39,688
And if I do a bash here,
that will give me, oh,

438
00:22:39,688 --> 00:22:42,699
and I actually need the forward slash bin

439
00:22:42,699 --> 00:22:44,666
forward slash bash.

440
00:22:44,666 --> 00:22:48,794
And, oh, yes, I had
forgotten that in Alpine,

441
00:22:48,794 --> 00:22:50,369
it doesn't even ship with Bash.

442
00:22:50,369 --> 00:22:54,088
It is such a limited Linux distribution.

443
00:22:54,088 --> 00:22:58,255
In fact, Alpine ships with the
much more limited SH shell.

444
00:23:00,754 --> 00:23:05,752
So worth bearing that in mind
if you want to go for Alpine.

445
00:23:05,752 --> 00:23:09,919
And I must admit, I'm not very
proficient with the SH shell,

446
00:23:11,129 --> 00:23:12,907
but let's see what happens.

447
00:23:12,907 --> 00:23:15,664
Now, the reason I'm
doing this is, as before,

448
00:23:15,664 --> 00:23:17,758
we've been dropped into
the working directory

449
00:23:17,758 --> 00:23:21,023
for this image, which
is user local Tomcat.

450
00:23:21,023 --> 00:23:25,671
And you'll find in here a
regular Tomcat installation,

451
00:23:25,671 --> 00:23:29,582
and as always in Tomcat, the
applications installed to it

452
00:23:29,582 --> 00:23:32,749
you can find under the webapps folder.

453
00:23:35,332 --> 00:23:37,909
And this particular installation of Tomcat

454
00:23:37,909 --> 00:23:42,356
has already shipped
with, I think it's four,

455
00:23:42,356 --> 00:23:44,667
at least four applications.

456
00:23:44,667 --> 00:23:46,500
There's the root here,

457
00:23:47,375 --> 00:23:49,671
which is the page that you've just seen,

458
00:23:49,671 --> 00:23:51,205
this one here.

459
00:23:51,205 --> 00:23:54,253
And there's also a set of documentation,

460
00:23:54,253 --> 00:23:57,300
there's some examples, and
some management applications.

461
00:23:57,300 --> 00:24:00,159
Now, for a production
standard application,

462
00:24:00,159 --> 00:24:03,650
we absolutely do not want any of those

463
00:24:03,650 --> 00:24:05,925
to be exposed to the public.

464
00:24:05,925 --> 00:24:07,227
So what can we do?

465
00:24:07,227 --> 00:24:09,796
Well, we'll exit out of that container,

466
00:24:09,796 --> 00:24:11,918
and we'll deal with it in our Dockerfile.

467
00:24:11,918 --> 00:24:15,215
We can very simply run any
Linux command that we like

468
00:24:15,215 --> 00:24:19,290
using the Run command,
as long as the command

469
00:24:19,290 --> 00:24:21,931
that we're running is
part of the distribution

470
00:24:21,931 --> 00:24:23,545
that we're working with.

471
00:24:23,545 --> 00:24:26,274
Now, as we've seen, Alpine doesn't have

472
00:24:26,274 --> 00:24:28,890
a very rich set of tools,
but I'm sure it does have

473
00:24:28,890 --> 00:24:29,973
RM to remove.

474
00:24:31,265 --> 00:24:33,780
We're going to be removing some folders,

475
00:24:33,780 --> 00:24:37,697
so we will need rm dash
rf for recursive false.

476
00:24:38,896 --> 00:24:43,063
And we're wanting to remove
the contents of slash usr,

477
00:24:44,358 --> 00:24:47,775
slash local, slash tomcat, slash webapps,

478
00:24:48,698 --> 00:24:50,716
and we want to take
out the entire content,

479
00:24:50,716 --> 00:24:53,423
so we'll use a wild card there.

480
00:24:53,423 --> 00:24:55,378
Let's try that.

481
00:24:55,378 --> 00:24:58,128
So small steps, and then rebuild.

482
00:25:04,420 --> 00:25:08,447
Check the build works, and
then we'll run the container

483
00:25:08,447 --> 00:25:10,280
as a detached process.

484
00:25:11,963 --> 00:25:13,817
And of course, this is important.

485
00:25:13,817 --> 00:25:17,650
I've still left my
previous container running.

486
00:25:19,139 --> 00:25:20,775
So if I list the containers, yeah,

487
00:25:20,775 --> 00:25:24,942
that's the one from previously,
so I'll need to stop that.

488
00:25:27,429 --> 00:25:30,680
And then I'll recall the
docker container run,

489
00:25:30,680 --> 00:25:33,698
and we're running as detached,

490
00:25:33,698 --> 00:25:37,987
and I want to run detached so
I can recall my exec command

491
00:25:37,987 --> 00:25:40,856
and I'm going to run a shell against it.

492
00:25:40,856 --> 00:25:42,764
I'll need to change the container ID

493
00:25:42,764 --> 00:25:44,764
to the one beginning 90.

494
00:25:47,140 --> 00:25:50,166
No, it isn't beginning 90,
because that scrolled across.

495
00:25:50,166 --> 00:25:52,416
It's actually beginning BD.

496
00:25:55,601 --> 00:25:56,434
BD.

497
00:25:57,821 --> 00:26:01,904
Right, so now I should
find if I cd into webapps,

498
00:26:02,879 --> 00:26:04,361
that's fantastic.

499
00:26:04,361 --> 00:26:07,535
The webapps folder has
now been cleared away.

500
00:26:07,535 --> 00:26:09,785
Let's exit from that shell.

501
00:26:15,316 --> 00:26:17,149
And of course the
container's still running,

502
00:26:17,149 --> 00:26:19,482
so we'll stop the container.

503
00:26:22,688 --> 00:26:23,918
And we're getting very close now.

504
00:26:23,918 --> 00:26:28,185
Once we've removed the
contents of webapps,

505
00:26:28,185 --> 00:26:32,018
we need to send our WAR
file across to Tomcat.

506
00:26:33,667 --> 00:26:35,590
You've seen how to do
that from previously.

507
00:26:35,590 --> 00:26:37,556
We've just used the copy command.

508
00:26:37,556 --> 00:26:40,604
And as I mentioned, the copy
command for the source file

509
00:26:40,604 --> 00:26:44,515
will work relative to
where the docker file is.

510
00:26:44,515 --> 00:26:47,806
So for us, that's going to
be dot forward slash target

511
00:26:47,806 --> 00:26:51,209
and the name of the WAR file
that's being generated by Maven

512
00:26:51,209 --> 00:26:53,723
is fleetman dash webapp.

513
00:26:53,723 --> 00:26:55,628
Of course, I could alter this.

514
00:26:55,628 --> 00:26:58,803
Dash 0.0.1, because I'm still working with

515
00:26:58,803 --> 00:27:01,455
the default Maven settings.

516
00:27:01,455 --> 00:27:03,372
Dash snapshots dot war.

517
00:27:07,855 --> 00:27:12,161
As before, the second
parameter is the destination,

518
00:27:12,161 --> 00:27:14,752
so I need to send this to slash usr

519
00:27:14,752 --> 00:27:17,429
slash local slash tomcat.

520
00:27:17,429 --> 00:27:19,171
I didn't need to include that because

521
00:27:19,171 --> 00:27:20,934
it is the working directory,

522
00:27:20,934 --> 00:27:22,331
but again, I'll leave it in.

523
00:27:22,331 --> 00:27:26,104
Then forward slash webapps,
and I want it to become

524
00:27:26,104 --> 00:27:29,747
the root application, so
I'm going to rename this

525
00:27:29,747 --> 00:27:32,580
to ROOT, capital letters, dot war.

526
00:27:33,709 --> 00:27:38,269
So we've now installed our
application into this Tomcat.

527
00:27:38,269 --> 00:27:40,047
Will it work?

528
00:27:40,047 --> 00:27:42,380
I'll recall the image build.

529
00:27:46,574 --> 00:27:48,617
Well, for some reason, I
have an error in the copy

530
00:27:48,617 --> 00:27:51,867
that it's not able to see the WAR file,

531
00:27:55,666 --> 00:27:58,940
and that's, although we've
never seen this folder before,

532
00:27:58,940 --> 00:28:01,290
that's going to be the Docker context.

533
00:28:01,290 --> 00:28:02,763
That's the thing that's being transferred

534
00:28:02,763 --> 00:28:04,961
to the Docker daemon.

535
00:28:04,961 --> 00:28:07,780
Hmmm, I wonder why that's happened.

536
00:28:07,780 --> 00:28:10,066
I could have a typo,
maybe, in my WAR file.

537
00:28:10,066 --> 00:28:11,233
It looks okay.

538
00:28:12,199 --> 00:28:14,949
If I do a refresh on the project,

539
00:28:17,380 --> 00:28:21,297
and check under Target,
and yes, it was a typo.

540
00:28:22,318 --> 00:28:23,711
For some reason this Maven build

541
00:28:23,711 --> 00:28:25,772
doesn't build fleetman webapp,

542
00:28:25,772 --> 00:28:28,689
it just builds fleetman dash 0.0.1.

543
00:28:30,165 --> 00:28:32,644
So they're the kind of errors that

544
00:28:32,644 --> 00:28:34,955
you're going to have when
you're building up an image,

545
00:28:34,955 --> 00:28:37,205
and that's absolutely fine.

546
00:28:38,140 --> 00:28:39,473
We'll save that.

547
00:28:41,126 --> 00:28:41,959
Try again.

548
00:28:48,060 --> 00:28:50,650
Superb, this time the image built.

549
00:28:50,650 --> 00:28:55,196
And I'm going to go back now
to running this container

550
00:28:55,196 --> 00:28:57,821
interactively, just means I won't need

551
00:28:57,821 --> 00:28:59,587
to shut down the container.

552
00:28:59,587 --> 00:29:01,850
When I'm finished with it, I'll just,

553
00:29:01,850 --> 00:29:04,364
Control C will be sufficient.

554
00:29:04,364 --> 00:29:06,364
Let's see if this works.

555
00:29:09,545 --> 00:29:10,469
Well, this is good.

556
00:29:10,469 --> 00:29:14,200
We can see a Spring Boot
application going past.

557
00:29:14,200 --> 00:29:17,759
Ahh, but bad, I can see an exception.

558
00:29:17,759 --> 00:29:19,029
I'll go up this far.

559
00:29:19,029 --> 00:29:20,593
Application failed to start,

560
00:29:20,593 --> 00:29:22,701
and you may recognise this exception.

561
00:29:22,701 --> 00:29:24,972
It's exactly the same
exception that we had

562
00:29:24,972 --> 00:29:27,878
at the start of this session.

563
00:29:27,878 --> 00:29:30,305
It's simply the case that I haven't set

564
00:29:30,305 --> 00:29:33,273
the command line argument to tell Spring

565
00:29:33,273 --> 00:29:36,578
which profile we're running under.

566
00:29:36,578 --> 00:29:38,320
Just a quick reminder
that there is a class

567
00:29:38,320 --> 00:29:40,972
that provides the stub implementation

568
00:29:40,972 --> 00:29:44,135
of that remote microservice,
and it's only active

569
00:29:44,135 --> 00:29:46,193
when we're running under Development

570
00:29:46,193 --> 00:29:47,776
or the Docker Demo.

571
00:29:49,582 --> 00:29:51,425
Now, just to explain
what I've done here is

572
00:29:51,425 --> 00:29:54,128
I've created under Source, Main Resources,

573
00:29:54,128 --> 00:29:57,961
I've created a new profile
called Docker Demo.

574
00:30:01,137 --> 00:30:02,523
I've just set this aside so that

575
00:30:02,523 --> 00:30:06,318
we can have a play around
in here in future chapters

576
00:30:06,318 --> 00:30:10,625
and experiment without damaging
the development profile.

577
00:30:10,625 --> 00:30:13,749
So what that means is we
need to run our container

578
00:30:13,749 --> 00:30:15,917
using the Docker Demo.

579
00:30:15,917 --> 00:30:16,949
How do we do that?

580
00:30:16,949 --> 00:30:18,229
Well, back on the command line,

581
00:30:18,229 --> 00:30:21,562
I'll just Control C to kill that process

582
00:30:23,247 --> 00:30:25,671
and to stop that container,

583
00:30:25,671 --> 00:30:27,793
and then switching to the Docker file,

584
00:30:27,793 --> 00:30:29,963
I need to pass in an environment variable

585
00:30:29,963 --> 00:30:31,806
into the Java runtime, just like we did

586
00:30:31,806 --> 00:30:33,518
when we were running manually.

587
00:30:33,518 --> 00:30:36,325
Well, I needed to check
the Tomcat reference manual

588
00:30:36,325 --> 00:30:37,596
to do this.

589
00:30:37,596 --> 00:30:40,805
What we need to do to pass
in a virtual machine argument

590
00:30:40,805 --> 00:30:45,392
into Tomcat is we need to
set an environment variable

591
00:30:45,392 --> 00:30:47,642
called Java underscore Opt.

592
00:30:48,718 --> 00:30:50,447
It's just a Tomcat thing.

593
00:30:50,447 --> 00:30:54,267
And that's going to be set to the value,

594
00:30:54,267 --> 00:30:57,262
which is exactly the same
value that we supplied

595
00:30:57,262 --> 00:30:58,610
in Eclipse earlier.

596
00:30:58,610 --> 00:31:02,443
So that's Dash, capital
D, spring dot profiles

597
00:31:03,436 --> 00:31:07,103
dot active equals, and
while we could go for

598
00:31:08,733 --> 00:31:11,461
development or production,
but as you've seen,

599
00:31:11,461 --> 00:31:14,794
we have a special one, docker dash demo.

600
00:31:16,145 --> 00:31:19,653
Now, that's the environment
variable that we need to set,

601
00:31:19,653 --> 00:31:23,158
but in a Dockerfile, to set
an environment variable,

602
00:31:23,158 --> 00:31:24,741
you need to do ENV.

603
00:31:27,231 --> 00:31:31,398
Let's save that Dockerfile,
and back to the command line.

604
00:31:33,114 --> 00:31:35,447
Let's rerun the image build.

605
00:31:37,860 --> 00:31:38,929
That's looking good,

606
00:31:38,929 --> 00:31:41,762
and I'll recall the container run.

607
00:31:43,230 --> 00:31:44,647
Hold your breath.

608
00:31:50,013 --> 00:31:52,373
Well, this time it didn't
see any exceptions,

609
00:31:52,373 --> 00:31:56,656
and it took about 30 seconds
to start up that container.

610
00:31:56,656 --> 00:32:00,949
And back into the browser,
this is what we had before

611
00:32:00,949 --> 00:32:02,116
on local host.

612
00:32:03,132 --> 00:32:06,764
If we reload that page,
oh, that's fantastic.

613
00:32:06,764 --> 00:32:10,216
That's our image that we've
just built, our custom image,

614
00:32:10,216 --> 00:32:12,966
and it's running absolutely fine.

615
00:32:14,558 --> 00:32:15,552
So that's great.

616
00:32:15,552 --> 00:32:18,777
You've got quite a fairly
complex Tomcat application

617
00:32:18,777 --> 00:32:23,095
deployed into a container,
which you could now deploy

618
00:32:23,095 --> 00:32:26,066
to really any hardware in the world

619
00:32:26,066 --> 00:32:28,987
as long as Docker has been installed.

620
00:32:28,987 --> 00:32:31,882
So that's very powerful,
but many of you will know,

621
00:32:31,882 --> 00:32:34,243
if you're working on a
Spring Boot application,

622
00:32:34,243 --> 00:32:36,185
you don't really need Tomcat,

623
00:32:36,185 --> 00:32:38,612
because Tomcat's already built in.

624
00:32:38,612 --> 00:32:41,010
I must admit that I've
sort of bent the rules

625
00:32:41,010 --> 00:32:43,751
a little bit here to
make this into a WAR file

626
00:32:43,751 --> 00:32:47,512
just for illustration in case
you're working on a WAR file.

627
00:32:47,512 --> 00:32:50,890
So in the next chapter, we're
going to look at this again,

628
00:32:50,890 --> 00:32:52,808
but we're going to look at
how you would have done this

629
00:32:52,808 --> 00:32:55,791
if it were a regular Spring Boot app,

630
00:32:55,791 --> 00:32:58,735
and you're going to see that
everything is even simpler

631
00:32:58,735 --> 00:33:00,629
than what we have here.

632
00:33:00,629 --> 00:33:04,296
So have a good break,
and I'll see you then.

1
00:00:00,180 --> 00:00:01,244
- [Narrator] Hello and welcome back.

2
00:00:01,244 --> 00:00:04,002
In the previous chapter,
we saw how to build

3
00:00:04,002 --> 00:00:08,169
a full Tomcat-based WAR
file application in Docker.

4
00:00:09,568 --> 00:00:12,274
I know many of you, however,
will be using Spring Boot.

5
00:00:12,274 --> 00:00:13,676
So in this chapter, we'll have a look

6
00:00:13,676 --> 00:00:15,861
at how things are different with Boot.

7
00:00:15,861 --> 00:00:17,838
And you guys will discover that things

8
00:00:17,838 --> 00:00:20,712
are actually really straightforward.

9
00:00:20,712 --> 00:00:23,750
So it was definitely
useful to build an image

10
00:00:23,750 --> 00:00:26,699
featuring a full Tomcat installation

11
00:00:26,699 --> 00:00:29,286
that we deployed a WAR file to.

12
00:00:29,286 --> 00:00:30,639
But if you're working in Spring Boot,

13
00:00:30,639 --> 00:00:33,655
you will know that there isn't
really any reason to do that

14
00:00:33,655 --> 00:00:37,133
because Spring Boot embeds Tomcat.

15
00:00:37,133 --> 00:00:41,158
And you can run a Spring
Boot application directly

16
00:00:41,158 --> 00:00:43,136
as a JAR file.

17
00:00:43,136 --> 00:00:46,525
Well actually, you can even
run it directly as a WAR file.

18
00:00:46,525 --> 00:00:48,848
Just in case you haven't
worked with Spring Boot,

19
00:00:48,848 --> 00:00:51,841
and I strongly recommend our
Spring Boot training courses

20
00:00:51,841 --> 00:00:53,790
at Virtual Pair Programmers,

21
00:00:53,790 --> 00:00:55,883
I can demonstrate this
by on the command line

22
00:00:55,883 --> 00:00:58,550
if I go to the target directory,

23
00:01:00,251 --> 00:01:05,023
this is the WAR file here, the
fleetman blah blah WAR file

24
00:01:05,023 --> 00:01:07,690
that we built in the previous chapter.

25
00:01:07,690 --> 00:01:10,734
I can run that as a standalone application

26
00:01:10,734 --> 00:01:13,540
by just doing java dash jar,

27
00:01:13,540 --> 00:01:17,055
and then passing in that
WAR file as a parameter.

28
00:01:17,055 --> 00:01:21,558
Also, you'll more commonly
see a Spring Boot application

29
00:01:21,558 --> 00:01:25,730
deployed as a JAR file,
and that's absolutely fine.

30
00:01:25,730 --> 00:01:27,787
The only reason to have a WAR file

31
00:01:27,787 --> 00:01:30,204
is if you have any JSP pages.

32
00:01:31,433 --> 00:01:34,024
Now, actually this Spring Boot application

33
00:01:34,024 --> 00:01:36,447
has been ported across the Thymeleaf,

34
00:01:36,447 --> 00:01:38,209
again we've got a great
course on Thymeleaf,

35
00:01:38,209 --> 00:01:40,609
check that out if you're interested.

36
00:01:40,609 --> 00:01:42,510
And the Thymeleaf replaces JSP.

37
00:01:42,510 --> 00:01:44,524
So in fact, in this application,

38
00:01:44,524 --> 00:01:47,071
I could convert it to a JAR.

39
00:01:47,071 --> 00:01:49,376
And I think I might do that, in fact.

40
00:01:49,376 --> 00:01:53,870
But for now, it's fine
to run the WAR directly.

41
00:01:53,870 --> 00:01:58,671
And you'll see, I hope, the
familiar logging onscreen.

42
00:01:58,671 --> 00:02:00,819
And there we are, the application ran.

43
00:02:00,819 --> 00:02:03,301
Now it is falling over,
but for the same reasons

44
00:02:03,301 --> 00:02:05,637
that we've seen early
that we do need to pass in

45
00:02:05,637 --> 00:02:08,819
that command line argument
to specify the profile

46
00:02:08,819 --> 00:02:10,240
that we're running under.

47
00:02:10,240 --> 00:02:11,455
But I'll not bother doing that here

48
00:02:11,455 --> 00:02:13,393
because I think I've proved the point

49
00:02:13,393 --> 00:02:16,064
that that application will run just fine

50
00:02:16,064 --> 00:02:18,814
as a standalone Java application.

51
00:02:19,896 --> 00:02:22,020
I think it is worth going into the POM,

52
00:02:22,020 --> 00:02:24,589
and I think right at the top of the POM

53
00:02:24,589 --> 00:02:28,389
we have the packaging
type here, on line nine.

54
00:02:28,389 --> 00:02:32,139
If you change that to
JAR, and run the build.

55
00:02:34,858 --> 00:02:38,095
And you'll be running the package goal.

56
00:02:38,095 --> 00:02:39,520
While that's running, I'll just remind you

57
00:02:39,520 --> 00:02:43,687
that it won't work as a JAR
file if you have any JSPs.

58
00:02:44,969 --> 00:02:47,589
But I have converted to
Thymeleaf so that will be okay,

59
00:02:47,589 --> 00:02:48,728
but if you're in the position

60
00:02:48,728 --> 00:02:50,223
where you have a Spring Boot app

61
00:02:50,223 --> 00:02:52,054
that you want to run standalone,

62
00:02:52,054 --> 00:02:54,499
and you do have JSP in, no problem.

63
00:02:54,499 --> 00:02:58,052
Just build it as a WAR, and
just run it as we did before.

64
00:02:58,052 --> 00:02:59,465
I do want to double check that that works

65
00:02:59,465 --> 00:03:02,149
on the command line, so we'll do a Java.

66
00:03:02,149 --> 00:03:04,976
And before we run the
JAR, we've got to pass in

67
00:03:04,976 --> 00:03:06,516
that command line argument.

68
00:03:06,516 --> 00:03:10,197
Now, I've discovered that,
on my shell at least,

69
00:03:10,197 --> 00:03:11,975
this might not be the case for you.

70
00:03:11,975 --> 00:03:16,142
If I just do dash
Dspring.profiles.active, as usual,

71
00:03:19,694 --> 00:03:23,705
and I'm going to pass in =development,

72
00:03:23,705 --> 00:03:27,872
and then dash jar, and then
the name of the JAR file,

73
00:03:29,948 --> 00:03:32,306
I've discovered that
doesn't work on the shell.

74
00:03:32,306 --> 00:03:35,624
For some reason, it's not
parsing the property there,

75
00:03:35,624 --> 00:03:37,368
spring.profiles.

76
00:03:37,368 --> 00:03:40,695
I think it seems to think
that that's a class.

77
00:03:40,695 --> 00:03:42,751
So, if that doesn't work for you,

78
00:03:42,751 --> 00:03:44,984
it's not really important
to do this right now.

79
00:03:44,984 --> 00:03:47,747
But just think as you want to do it.

80
00:03:47,747 --> 00:03:50,695
I've discovered that if
you wrap the property name

81
00:03:50,695 --> 00:03:54,862
in quote marks, like so,
then things seem to work.

82
00:03:56,451 --> 00:03:59,116
I must admit, I very rarely
use the Windows Power Shells,

83
00:03:59,116 --> 00:04:01,803
so I'm a little bit hazy on that,

84
00:04:01,803 --> 00:04:04,105
but it seems to run okay.

85
00:04:04,105 --> 00:04:05,698
And yeah, that's started.

86
00:04:05,698 --> 00:04:08,865
And it's responding okay in a browser.

87
00:04:09,907 --> 00:04:13,434
So I'll cancel that, and
let's get back into Eclipse

88
00:04:13,434 --> 00:04:16,119
and at last get to the
point of this session.

89
00:04:16,119 --> 00:04:17,776
And the point that I'm getting towards

90
00:04:17,776 --> 00:04:21,146
is that when you're running
a Spring Boot app directly

91
00:04:21,146 --> 00:04:25,654
without Tomcat, then things
get a lot simpler and cleaner.

92
00:04:25,654 --> 00:04:28,790
For one thing, we don't
need Tomcat anymore

93
00:04:28,790 --> 00:04:30,867
as a base image.

94
00:04:30,867 --> 00:04:34,491
What you could do instead
is use something like just

95
00:04:34,491 --> 00:04:38,658
Pure Alpine, or Ubuntu, or
actually any of the distributions

96
00:04:40,100 --> 00:04:42,589
that you're happy and comfortable with.

97
00:04:42,589 --> 00:04:45,317
Then you could instal the jdk,

98
00:04:45,317 --> 00:04:48,295
and then you can just
simply run the application

99
00:04:48,295 --> 00:04:49,795
as a Java command.

100
00:04:50,634 --> 00:04:52,414
But, it's even easier than that

101
00:04:52,414 --> 00:04:55,264
because as you might well have guessed,

102
00:04:55,264 --> 00:04:58,735
here in Docker Hub, there is an image.

103
00:04:58,735 --> 00:05:01,010
I'll search for Java first of all

104
00:05:01,010 --> 00:05:03,546
to show you that the top results,

105
00:05:03,546 --> 00:05:06,401
the official Java, that
looks like the one we want,

106
00:05:06,401 --> 00:05:08,602
it's certainly very popular.

107
00:05:08,602 --> 00:05:10,753
But it is telling us here that this image

108
00:05:10,753 --> 00:05:15,408
is now deprecated in favour
of the openjdk image.

109
00:05:15,408 --> 00:05:18,075
So we can follow the link there,

110
00:05:19,334 --> 00:05:22,336
and yes this is the
up-to-date image that we need.

111
00:05:22,336 --> 00:05:24,084
A little as with the Tomcat,

112
00:05:24,084 --> 00:05:28,167
there is a long and
bewildering choice of images.

113
00:05:29,265 --> 00:05:31,920
As usual, it's the version of Java

114
00:05:31,920 --> 00:05:36,548
and what kind of distribution
do you want to run it on?

115
00:05:36,548 --> 00:05:39,565
So, I'm going to go, you can
make your own choice really,

116
00:05:39,565 --> 00:05:42,507
but I'm going to go for a Java 8,

117
00:05:42,507 --> 00:05:45,590
and I want a recent version of Java 8

118
00:05:46,585 --> 00:05:50,047
so I'll look for the most
recent version of the jdk.

119
00:05:50,047 --> 00:05:53,148
I do notice that if you want Alpine

120
00:05:53,148 --> 00:05:57,315
at the time of recording,
it's the Java 8 update 131

121
00:05:59,921 --> 00:06:01,698
that ships with Alpine.

122
00:06:01,698 --> 00:06:04,487
But I noticed it looks like
they may have switched,

123
00:06:04,487 --> 00:06:08,654
because in the update 141,
it's now called jdk-slim.

124
00:06:12,235 --> 00:06:13,831
And I wonder if they've changed,

125
00:06:13,831 --> 00:06:15,275
they've moved away from Alpine

126
00:06:15,275 --> 00:06:17,620
and they're using a different approach.

127
00:06:17,620 --> 00:06:20,048
I'll let you investigate that
if you're really interested,

128
00:06:20,048 --> 00:06:23,888
but I think I will just have a
quick look at the docker file

129
00:06:23,888 --> 00:06:25,721
for this slim version.

130
00:06:26,771 --> 00:06:28,838
And we can see that
they're basing their image

131
00:06:28,838 --> 00:06:32,588
on something called
stretch-slim from Debian.

132
00:06:33,466 --> 00:06:34,683
I've no idea what's going on there,

133
00:06:34,683 --> 00:06:37,006
but I wonder if it's a long-term move

134
00:06:37,006 --> 00:06:40,250
across to a different distribution.

135
00:06:40,250 --> 00:06:43,244
So as usual, I'm going to use
the full version of the label

136
00:06:43,244 --> 00:06:45,118
that you can see here.

137
00:06:45,118 --> 00:06:47,503
So, the fact that we are basing this

138
00:06:47,503 --> 00:06:50,155
on a pre-configured jdk image

139
00:06:50,155 --> 00:06:53,281
means we don't have to do any installing.

140
00:06:53,281 --> 00:06:55,761
We will need to expose port 88,

141
00:06:55,761 --> 00:06:58,308
because we won't be getting
that for free anymore

142
00:06:58,308 --> 00:06:59,975
from the base image.

143
00:07:00,878 --> 00:07:03,284
But the great thing about this
is we can remove a lot of it.

144
00:07:03,284 --> 00:07:07,864
We don't need to do any
modification to Tomcat's directory,

145
00:07:07,864 --> 00:07:10,364
so we can remove that removal.

146
00:07:11,831 --> 00:07:14,648
We are, of course, going
to need to do a copy.

147
00:07:14,648 --> 00:07:16,123
So we'll need to modify this line,

148
00:07:16,123 --> 00:07:18,077
and instead of copying the WAR file,

149
00:07:18,077 --> 00:07:20,749
we'll now be copying the JAR file.

150
00:07:20,749 --> 00:07:23,388
And actually, just as
we did two chapters ago

151
00:07:23,388 --> 00:07:27,714
when we were deploying that
very basic Java service,

152
00:07:27,714 --> 00:07:30,854
we need to decide in
which folder to instal it.

153
00:07:30,854 --> 00:07:33,155
And I think we went for,

154
00:07:33,155 --> 00:07:37,356
we went for user/local/bin.

155
00:07:37,356 --> 00:07:39,928
And I would suggest renaming this JAR file

156
00:07:39,928 --> 00:07:42,594
because this name is
a little bit unwieldy,

157
00:07:42,594 --> 00:07:46,196
so I'm just going to call it webapp.jar.

158
00:07:46,196 --> 00:07:50,088
If we want to though, we
could specify a work directory

159
00:07:50,088 --> 00:07:51,489
just as we did previously.

160
00:07:51,489 --> 00:07:56,045
So we'll make the user/local/bin directory

161
00:07:56,045 --> 00:07:58,074
be our work directory,

162
00:07:58,074 --> 00:08:01,428
and therefore we don't need
to specify that path anymore.

163
00:08:01,428 --> 00:08:03,942
Now, this line here was
for Tomcat specifically.

164
00:08:03,942 --> 00:08:08,461
This was how we passed in
the profile name into Tomcat.

165
00:08:08,461 --> 00:08:10,190
So, we need to change that.

166
00:08:10,190 --> 00:08:13,885
I suggest you cut what you
have there in the quote marks,

167
00:08:13,885 --> 00:08:17,205
and we can lose that line
because all we need to do

168
00:08:17,205 --> 00:08:21,424
on the command, of course,
is run the Java application.

169
00:08:21,424 --> 00:08:23,589
So we just need to copy across the command

170
00:08:23,589 --> 00:08:26,488
exactly as we had it on
the command line, really.

171
00:08:26,488 --> 00:08:30,155
Java, paste in the
profiles line into there,

172
00:08:31,031 --> 00:08:34,948
and then as a third
parameter, we'll have -jar.

173
00:08:35,910 --> 00:08:38,298
And then a fourth parameter
is the name of the JAR

174
00:08:38,298 --> 00:08:40,881
that we're running, webapp.jar.

175
00:08:41,735 --> 00:08:43,404
Now I've just realised before we go on,

176
00:08:43,404 --> 00:08:45,979
I'm sorry if I confused you earlier.

177
00:08:45,979 --> 00:08:47,516
On the FROM line,

178
00:08:47,516 --> 00:08:51,588
I've just gone in and
pasted the tag there.

179
00:08:51,588 --> 00:08:54,491
But of course, I also need
the name of the repository,

180
00:08:54,491 --> 00:08:55,908
which is OpenJDK.

181
00:08:58,358 --> 00:08:59,388
So I'm glad I spotted that

182
00:08:59,388 --> 00:09:01,450
before I tried building the image.

183
00:09:01,450 --> 00:09:02,700
Openjdk, colon.

184
00:09:04,166 --> 00:09:06,800
I'm sure there's probably
some further areas in here,

185
00:09:06,800 --> 00:09:09,141
but let's try it and see.

186
00:09:09,141 --> 00:09:11,338
So I think the first
thing to do is just check

187
00:09:11,338 --> 00:09:14,381
you don't have any
containers already running.

188
00:09:14,381 --> 00:09:18,381
And I'm sure I've probably
got the build command

189
00:09:21,641 --> 00:09:22,638
on my history.

190
00:09:22,638 --> 00:09:25,491
So again, we're just doing
a Docket image build,

191
00:09:25,491 --> 00:09:27,734
dash t, the name of the...

192
00:09:27,734 --> 00:09:30,482
To tag the image as fleetman-webapp,

193
00:09:30,482 --> 00:09:32,671
and we're running in the current folder.

194
00:09:32,671 --> 00:09:34,504
Let's give that a run.

195
00:09:35,791 --> 00:09:37,114
And it would help, I think,

196
00:09:37,114 --> 00:09:38,553
if I was in the correct directory.

197
00:09:38,553 --> 00:09:41,087
I'm currently in the target directory.

198
00:09:41,087 --> 00:09:42,842
Of course, I need to be in the same folder

199
00:09:42,842 --> 00:09:45,603
that the Docker file is in.

200
00:09:45,603 --> 00:09:46,936
Let's try again.

201
00:09:50,850 --> 00:09:54,873
So brand new image, which
will need to be downloaded.

202
00:09:54,873 --> 00:09:56,555
Okay, well to my absolute surprise,

203
00:09:56,555 --> 00:09:59,736
that ran through without any errors.

204
00:09:59,736 --> 00:10:02,203
So the next thing, let's do a clear.

205
00:10:02,203 --> 00:10:05,946
And I think I may as
well do this longhand.

206
00:10:05,946 --> 00:10:07,817
We're going to run a container,

207
00:10:07,817 --> 00:10:10,257
we're going to publish the port 80,

208
00:10:10,257 --> 00:10:14,110
which we will map onto the internal 8080.

209
00:10:14,110 --> 00:10:17,009
I want to run this interactively,

210
00:10:17,009 --> 00:10:20,909
just to test that it's
working, with dash IT.

211
00:10:20,909 --> 00:10:24,659
And the name of the
image is fleetman-webapp.

212
00:10:27,446 --> 00:10:29,279
That should be enough.

213
00:10:34,657 --> 00:10:36,555
Well, it certainly seemed to start okay,

214
00:10:36,555 --> 00:10:39,089
so back to the browser.

215
00:10:39,089 --> 00:10:41,204
And don't forget, before you refresh,

216
00:10:41,204 --> 00:10:44,591
that we were testing
this on port 8080 before,

217
00:10:44,591 --> 00:10:47,649
but now we've published
it as a Docker container,

218
00:10:47,649 --> 00:10:50,271
we're running on port 80.

219
00:10:50,271 --> 00:10:54,000
So, fantastic, we now have this running

220
00:10:54,000 --> 00:10:57,523
as, if you like, a native
Spring Boot application

221
00:10:57,523 --> 00:11:00,065
with no need to instal Tomcat.

222
00:11:00,065 --> 00:11:01,235
And really, what I've shown you there

223
00:11:01,235 --> 00:11:03,202
isn't really a feature
of Docker or search,

224
00:11:03,202 --> 00:11:06,426
it's just a very good
feature of Spring Boot.

225
00:11:06,426 --> 00:11:08,638
And it's clear that the Spring Boot team

226
00:11:08,638 --> 00:11:12,422
are very much focused
on the modern practise

227
00:11:12,422 --> 00:11:14,780
of development, and
they're working really hard

228
00:11:14,780 --> 00:11:16,718
to make it as easy as possible

229
00:11:16,718 --> 00:11:19,675
to deploy your Spring Boot applications.

230
00:11:19,675 --> 00:11:24,167
So installing a Tomcat image
is absolutely fine and dandy,

231
00:11:24,167 --> 00:11:25,759
and you might need to do that.

232
00:11:25,759 --> 00:11:27,073
But if you're in the lucky situation

233
00:11:27,073 --> 00:11:28,430
of working with Spring Boot,

234
00:11:28,430 --> 00:11:32,018
then things are quite a bit easier.

235
00:11:32,018 --> 00:11:34,402
Well, I think we'll leave
it there for Spring Boot,

236
00:11:34,402 --> 00:11:38,192
and we've just got one last
short chapter on this course

237
00:11:38,192 --> 00:11:40,768
where I'm going to show you
how to publish your image

238
00:11:40,768 --> 00:11:43,888
onto Docker Hub, which is
actually very straightforward.

239
00:11:43,888 --> 00:11:45,700
But I'll also give you a preview

240
00:11:45,700 --> 00:11:48,624
as to what's coming in the
next module on this course,

241
00:11:48,624 --> 00:11:52,154
which I'll be producing
immediately after this one.

242
00:11:52,154 --> 00:11:53,259
Basically, we're going to get

243
00:11:53,259 --> 00:11:55,034
a lot more production standard.

244
00:11:55,034 --> 00:11:57,260
We're going to be deploying
a lot more containers.

245
00:11:57,260 --> 00:11:58,560
But if you've got this far,

246
00:11:58,560 --> 00:12:00,233
it's been a great start in Docker.

247
00:12:00,233 --> 00:12:03,400
So I'll see you for the last chapter.

1
00:00:00,404 --> 00:00:01,318
- [Narrator] Hello and welcome back.

2
00:00:01,318 --> 00:00:02,966
A very short chapter this one.

3
00:00:02,966 --> 00:00:04,352
We're going to look at how to

4
00:00:04,352 --> 00:00:07,102
publish your images on DockerHub.

5
00:00:08,055 --> 00:00:10,286
So the point we got to is that

6
00:00:10,286 --> 00:00:13,859
you should by now have built an image.

7
00:00:13,859 --> 00:00:16,327
I'll do a docker image ls.

8
00:00:16,327 --> 00:00:18,844
And we've got a lot of
these intermediate images,

9
00:00:18,844 --> 00:00:23,348
but the important one
is the fleetman-webapp.

10
00:00:23,348 --> 00:00:25,369
Now I'm sure many of
you will be interested

11
00:00:25,369 --> 00:00:27,401
to know how we actually publish that

12
00:00:27,401 --> 00:00:30,068
to the public DockerHub website.

13
00:00:31,192 --> 00:00:32,252
And it's actually pretty simple.

14
00:00:32,252 --> 00:00:35,651
You will need to create
an account on DockerHub

15
00:00:35,651 --> 00:00:39,869
and you can do that through
the new to Docker link here.

16
00:00:39,869 --> 00:00:41,847
Of course that will be
our user name on Docker,

17
00:00:41,847 --> 00:00:44,521
but more importantly that
label is going to become

18
00:00:44,521 --> 00:00:47,688
the owner of any images that you push.

19
00:00:48,754 --> 00:00:51,760
You don't need to pay to
have a Docker account.

20
00:00:51,760 --> 00:00:54,573
You will need to pay Docker if you want

21
00:00:54,573 --> 00:00:57,365
to have more than one private repository.

22
00:00:57,365 --> 00:01:01,645
So obviously if you're storing
any secret data inside any

23
00:01:01,645 --> 00:01:05,428
of your images then you
would need a private account,

24
00:01:05,428 --> 00:01:09,093
but in that case you would probably

25
00:01:09,093 --> 00:01:10,959
rather than publish them on DockerHub

26
00:01:10,959 --> 00:01:13,856
if you want to keep them
private then probably

27
00:01:13,856 --> 00:01:16,694
the better way to go
would be to host your own

28
00:01:16,694 --> 00:01:19,832
repositories on your own hardware.

29
00:01:19,832 --> 00:01:21,398
It's pretty easy to do that

30
00:01:21,398 --> 00:01:23,027
and I will be showing you how to do that

31
00:01:23,027 --> 00:01:24,452
in the next module,

32
00:01:24,452 --> 00:01:28,020
but for now if you want to
push your fleetman image

33
00:01:28,020 --> 00:01:31,102
then just create yourself an account.

34
00:01:31,102 --> 00:01:32,939
And once you've signed in you'll have

35
00:01:32,939 --> 00:01:35,759
an empty repositories list.

36
00:01:35,759 --> 00:01:38,073
Now to push your image
there is one problem.

37
00:01:38,073 --> 00:01:42,422
We have tagged the image
without using an owner's name.

38
00:01:42,422 --> 00:01:44,839
And what that means is if we,

39
00:01:44,839 --> 00:01:46,723
by the way I should
cut to the chase really

40
00:01:46,723 --> 00:01:50,290
and tell you the command to
push your image is very simple

41
00:01:50,290 --> 00:01:54,624
docker image push followed
by the name of the image

42
00:01:54,624 --> 00:01:58,791
that you're pushing, which for
us has been fleetman-webapp.

43
00:02:00,783 --> 00:02:04,690
And you will certainly
find that you get an error

44
00:02:04,690 --> 00:02:08,043
requested access to
the resource is denied.

45
00:02:08,043 --> 00:02:09,609
Now you might think
that's because we haven't

46
00:02:09,609 --> 00:02:12,918
logged in to the DockerHub at all

47
00:02:12,918 --> 00:02:16,225
and it's true that you do
need to log in to DockerHub,

48
00:02:16,225 --> 00:02:17,968
but actually if this operation should have

49
00:02:17,968 --> 00:02:19,583
asked you to do so.

50
00:02:19,583 --> 00:02:21,560
But just while I'm here I will show you

51
00:02:21,560 --> 00:02:23,973
that there is command
for you to explicitly

52
00:02:23,973 --> 00:02:27,890
log in to DockerHub which
is just docker login.

53
00:02:29,083 --> 00:02:31,398
It will prompt you for your user name,

54
00:02:31,398 --> 00:02:32,727
which is your Docker ID.

55
00:02:32,727 --> 00:02:35,696
For me, virtual pair programmers

56
00:02:35,696 --> 00:02:39,863
and then your password, which
I managed to type in wrong.

57
00:02:43,891 --> 00:02:48,451
It's the end of a very
long recording session.

58
00:02:48,451 --> 00:02:50,021
So that login is succeeded.

59
00:02:50,021 --> 00:02:54,567
Now I think we'll find if
we repeat that push command,

60
00:02:54,567 --> 00:02:57,527
yeah we have exactly the same error.

61
00:02:57,527 --> 00:03:00,781
Now what's happening here
is as you know by now

62
00:03:00,781 --> 00:03:04,948
all images have an owner,
forward slash, image name.

63
00:03:07,199 --> 00:03:11,366
Only the official images
published by Docker themselves

64
00:03:12,349 --> 00:03:14,932
are allowed to have just a name

65
00:03:16,719 --> 00:03:18,685
so that's what's happening here.

66
00:03:18,685 --> 00:03:20,840
We need to rename this image

67
00:03:20,840 --> 00:03:22,880
and the way that we do that.

68
00:03:22,880 --> 00:03:27,555
Well we don't really rename
it, we just apply a tag to it.

69
00:03:27,555 --> 00:03:30,472
We'll do that with docker image tag

70
00:03:32,486 --> 00:03:35,667
and the first parameter
is the ID of the image

71
00:03:35,667 --> 00:03:37,526
that we're wanting it to tag.

72
00:03:37,526 --> 00:03:38,995
You can actually use the name,

73
00:03:38,995 --> 00:03:43,162
but I'm going to use the
image which is 05c for me.

74
00:03:44,080 --> 00:03:46,065
It may be different for you.

75
00:03:46,065 --> 00:03:49,728
And then we supply the
tag that we want to give.

76
00:03:49,728 --> 00:03:51,971
So that's going to be your DockerId,

77
00:03:51,971 --> 00:03:54,638
for me virtual pair programmers,

78
00:03:55,848 --> 00:03:57,594
followed by a forward slash,

79
00:03:57,594 --> 00:04:00,703
followed by what you want
the image to be called.

80
00:04:00,703 --> 00:04:04,025
Now I'm not going to call
this one fleetman-webapp

81
00:04:04,025 --> 00:04:07,529
because actually I've
already got that image

82
00:04:07,529 --> 00:04:09,343
and I don't want to touch that image

83
00:04:09,343 --> 00:04:12,110
because that's the one that you downloaded

84
00:04:12,110 --> 00:04:13,571
at the start of this course

85
00:04:13,571 --> 00:04:16,704
and I don't want to ruin
that for other people

86
00:04:16,704 --> 00:04:18,076
doing the course.

87
00:04:18,076 --> 00:04:20,292
So I'm just going to
make a test image here

88
00:04:20,292 --> 00:04:22,169
so I'm going to call it test,

89
00:04:22,169 --> 00:04:25,397
but you can call this anything you want.

90
00:04:25,397 --> 00:04:27,564
I suggest fleetman-webapp.

91
00:04:28,647 --> 00:04:32,061
So if we run that, it
doesn't take very long at all

92
00:04:32,061 --> 00:04:34,935
and we repeat the docker image ls

93
00:04:34,935 --> 00:04:39,158
what we've got now is
effectively two images

94
00:04:39,158 --> 00:04:43,325
or what appears to be two
images with different names,

95
00:04:44,759 --> 00:04:47,346
but if you look on the image ID,

96
00:04:47,346 --> 00:04:49,990
but in fact it is the same image.

97
00:04:49,990 --> 00:04:53,149
So it's a little bit like having an alias.

98
00:04:53,149 --> 00:04:55,262
If you wanted to, if you
found that confusing,

99
00:04:55,262 --> 00:04:59,133
you could remove the image
with the original name.

100
00:04:59,133 --> 00:05:00,248
I'm just going to leave it there.

101
00:05:00,248 --> 00:05:02,772
I have no problem with that at all.

102
00:05:02,772 --> 00:05:06,939
So now what we can do is we
can do a docker image push

103
00:05:08,321 --> 00:05:10,868
and that's going to be virtual
pair programmers for me,

104
00:05:10,868 --> 00:05:12,884
that will be our docker ID

105
00:05:12,884 --> 00:05:15,467
and then the name of the image.

106
00:05:19,115 --> 00:05:21,698
And this looks a lot healthier.

107
00:05:27,016 --> 00:05:29,630
Well that's pushed and we can confirm that

108
00:05:29,630 --> 00:05:31,791
here on the DockerHub page.

109
00:05:31,791 --> 00:05:34,080
I'll need to refresh it of course

110
00:05:34,080 --> 00:05:36,555
and somewhere in here and there it is

111
00:05:36,555 --> 00:05:38,722
my brand new public image.

112
00:05:39,678 --> 00:05:40,800
I'm going to delete that image

113
00:05:40,800 --> 00:05:43,439
because I don't need it
for anything right now,

114
00:05:43,439 --> 00:05:44,969
but I think it's a really good feeling

115
00:05:44,969 --> 00:05:49,491
when you get first repositories
pushed to DockerHub.

116
00:05:49,491 --> 00:05:50,984
So that wasn't too painful.

117
00:05:50,984 --> 00:05:53,790
Just one thing I'll
very quickly mention is

118
00:05:53,790 --> 00:05:55,932
instead of doing this image tag,

119
00:05:55,932 --> 00:05:59,034
if you had just built the image again

120
00:05:59,034 --> 00:06:02,284
and when you ran the docker image build

121
00:06:03,515 --> 00:06:06,422
you could have just specified a dash t

122
00:06:06,422 --> 00:06:09,218
and use your Docker ID, forward slash

123
00:06:09,218 --> 00:06:10,776
whatever the new name is.

124
00:06:10,776 --> 00:06:13,256
That would have worked
absolutely fine as well.

125
00:06:13,256 --> 00:06:15,918
So that's really it for
the basics in Docker.

126
00:06:15,918 --> 00:06:17,636
I've just got one more
chapter on this course

127
00:06:17,636 --> 00:06:20,638
where I'll give you a
preview as to what's coming

128
00:06:20,638 --> 00:06:23,097
on module two of this course,

129
00:06:23,097 --> 00:06:27,264
where things get quite a bit
more production standard.

1
00:00:01,214 --> 00:00:02,896
- [Narrator] Well, that's
the end of this first

2
00:00:02,896 --> 00:00:06,749
module on Docker, and I
hope you found it useful.

3
00:00:06,749 --> 00:00:10,312
There are a lot of Docker
tutorials available,

4
00:00:10,312 --> 00:00:12,868
not least on the Docker site itself.

5
00:00:12,868 --> 00:00:15,303
So I needed to work quite hard

6
00:00:15,303 --> 00:00:18,998
to make it relevant to
you as a JVM developer.

7
00:00:18,998 --> 00:00:22,049
So it was probably just as much Java,

8
00:00:22,049 --> 00:00:25,289
Spring, and Boots in this
course then there was Docker.

9
00:00:25,289 --> 00:00:27,208
But I hope you've got a good taste

10
00:00:27,208 --> 00:00:29,125
of what Docker can do for you.

11
00:00:29,125 --> 00:00:31,384
And instead of handing over walls

12
00:00:31,384 --> 00:00:34,022
and jobs at the end of your build process,

13
00:00:34,022 --> 00:00:36,564
which are quite difficult to deploy,

14
00:00:36,564 --> 00:00:39,280
because they need environments to run in,

15
00:00:39,280 --> 00:00:42,077
you can now deploy images.

16
00:00:42,077 --> 00:00:45,173
And the images lead to containers.

17
00:00:45,173 --> 00:00:47,907
Which are self contained, easy to run,

18
00:00:47,907 --> 00:00:50,115
and easy to manage.

19
00:00:50,115 --> 00:00:53,487
However, this course was just a start

20
00:00:53,487 --> 00:00:55,204
and was intended as a quick,

21
00:00:55,204 --> 00:00:57,787
get your feet wet type session.

22
00:00:59,272 --> 00:01:02,187
But the next module, we're
going to go much further.

23
00:01:02,187 --> 00:01:06,736
We'll be basically, moving into
multi container deployments.

24
00:01:06,736 --> 00:01:08,021
We're going to be seeing how we can

25
00:01:08,021 --> 00:01:12,086
incorporate Docker into
your full build process.

26
00:01:12,086 --> 00:01:14,151
So we'll see how Docker can be integrated

27
00:01:14,151 --> 00:01:16,484
with Maven and with Jenkins.

28
00:01:18,279 --> 00:01:20,245
We'll be seeing how you can set up

29
00:01:20,245 --> 00:01:24,412
private networks between
multiple Docker containers.

30
00:01:25,301 --> 00:01:28,324
We'll see how we can
start multiple containers,

31
00:01:28,324 --> 00:01:32,407
perhaps a full complex
micro service architecture

32
00:01:33,253 --> 00:01:37,780
with just a simple command
called Docker Compose.

33
00:01:37,780 --> 00:01:39,640
We're going to learn how you can push

34
00:01:39,640 --> 00:01:43,757
the deployments onto a
cluster of instances.

35
00:01:43,757 --> 00:01:47,924
All managed via a very powerful
tool call Docker Swarm.

36
00:01:49,514 --> 00:01:51,615
We'll also find out about the power

37
00:01:51,615 --> 00:01:54,448
of something called Docker Stacks.

38
00:01:55,958 --> 00:01:59,524
So, all of the basics
that we've learned here,

39
00:01:59,524 --> 00:02:02,247
we're going to be quite
easily, pushing on to

40
00:02:02,247 --> 00:02:04,442
full production standard.

41
00:02:04,442 --> 00:02:07,744
And we will get that Fleetman application

42
00:02:07,744 --> 00:02:11,297
working with properly, realistic data.

43
00:02:11,297 --> 00:02:12,948
So all of that's coming soon.

44
00:02:12,948 --> 00:02:15,483
It's planned for August 2017.

45
00:02:15,483 --> 00:02:18,026
So, depending on when
you've watched this video,

46
00:02:18,026 --> 00:02:20,151
it might be available now.

47
00:02:20,151 --> 00:02:22,874
But if it's not available
then don't panic,

48
00:02:22,874 --> 00:02:24,208
it's nearly ready.

49
00:02:24,208 --> 00:02:27,089
Because as I've been recording this video,

50
00:02:27,089 --> 00:02:31,443
that second module has
actually been written.

51
00:02:31,443 --> 00:02:33,581
There's just a small matter of going away

52
00:02:33,581 --> 00:02:35,462
and recording it.

53
00:02:35,462 --> 00:02:37,395
So do check out the news page of

54
00:02:37,395 --> 00:02:39,484
virtualpairprogrammers.com, where we

55
00:02:39,484 --> 00:02:41,692
announce all new courses,

56
00:02:41,692 --> 00:02:44,052
the second they're released.

57
00:02:44,052 --> 00:02:46,393
And we also now run a podcast

58
00:02:46,393 --> 00:02:48,854
linked from that news page.

59
00:02:48,854 --> 00:02:51,233
And every two weeks or so we talk about

60
00:02:51,233 --> 00:02:54,066
industry news and all things Java.

61
00:02:55,573 --> 00:02:57,649
And at the end of every episode,

62
00:02:57,649 --> 00:02:59,221
myself and my colleagues talk about

63
00:02:59,221 --> 00:03:01,900
the progress we're making
on cost development.

64
00:03:01,900 --> 00:03:03,556
So that's probably the best place to

65
00:03:03,556 --> 00:03:06,940
find out what I'm up to right now.

66
00:03:06,940 --> 00:03:10,107
In the meantime, it's been
great to be with you again.

67
00:03:10,107 --> 00:03:12,208
From me, Richard Chesterwood and the team

68
00:03:12,208 --> 00:03:14,188
at Virtual Pair Programmers.

69
00:03:14,188 --> 00:03:16,829
Thanks again for subscribing and watching.

70
00:03:16,829 --> 00:03:20,079
And I'll see you for Docker module two.

1
00:00:00,468 --> 00:00:03,185
[Narrator] - A very warm
welcome to module two

2
00:00:03,185 --> 00:00:06,268
of Docker for Java or JVM Developers.

3
00:00:07,447 --> 00:00:10,388
In this module we cover
the basics of Docker.

4
00:00:10,388 --> 00:00:12,983
How to build images, run containers

5
00:00:12,983 --> 00:00:15,731
and how to work with Docker Hub.

6
00:00:15,731 --> 00:00:19,122
In this advanced module we're
going to apply those basics

7
00:00:19,122 --> 00:00:23,660
and we'll move on to run
multi container systems.

8
00:00:23,660 --> 00:00:26,647
We're going to be networking
containers together.

9
00:00:26,647 --> 00:00:29,265
We'll be mounting volumes.

10
00:00:29,265 --> 00:00:31,391
We'll see how to use a plugin too

11
00:00:31,391 --> 00:00:34,340
into great your maven builds with Docker.

12
00:00:34,340 --> 00:00:37,216
And then, how you can
run multiple containers

13
00:00:37,216 --> 00:00:41,530
with a single command
using Docker compose.

14
00:00:41,530 --> 00:00:42,982
And then for the fun stuff.

15
00:00:42,982 --> 00:00:45,166
We'll be using the Docker swarm to run

16
00:00:45,166 --> 00:00:48,959
your containers across
a cluster of instances.

17
00:00:48,959 --> 00:00:52,752
And then we'll see the
power of a Docker stack.

18
00:00:52,752 --> 00:00:56,919
An entire distribute system
defined in a single text file.

19
00:00:58,284 --> 00:00:59,978
Throughout the course, I will be using

20
00:00:59,978 --> 00:01:04,778
as an example a very simple
multi container system.

21
00:01:04,778 --> 00:01:06,726
The simplest I could think of really.

22
00:01:06,726 --> 00:01:09,969
We'll have a spring boot based container

23
00:01:09,969 --> 00:01:13,422
which connects to a mysql container.

24
00:01:13,422 --> 00:01:15,919
That will mean we can
focus on the key concepts

25
00:01:15,919 --> 00:01:19,507
without getting bogged
down in nasty details.

26
00:01:19,507 --> 00:01:20,608
And it means that really

27
00:01:20,608 --> 00:01:23,546
any job developer can follow this course,

28
00:01:23,546 --> 00:01:25,850
regardless of whether
your building web apps,

29
00:01:25,850 --> 00:01:27,207
enterprise systems

30
00:01:27,207 --> 00:01:30,985
or full micro service architectures.

31
00:01:30,985 --> 00:01:33,373
But I know that many of
you will be on this course

32
00:01:33,373 --> 00:01:34,364
because you've already done

33
00:01:34,364 --> 00:01:37,772
our series of micro service courses.

34
00:01:37,772 --> 00:01:38,930
So if you are,

35
00:01:38,930 --> 00:01:42,142
then the last chapters on
the course are for you.

36
00:01:42,142 --> 00:01:43,698
We'll take all of the concepts

37
00:01:43,698 --> 00:01:45,428
that we've learned in this module

38
00:01:45,428 --> 00:01:47,352
and we'll see how we can apply them

39
00:01:47,352 --> 00:01:51,102
to a more serious micro
service architecture.

40
00:01:52,036 --> 00:01:55,235
On our previous micro
service deployment course

41
00:01:55,235 --> 00:01:57,781
we had to work so hard

42
00:01:57,781 --> 00:02:01,948
to get the system deployed
to Amazonaws EC2 hardware.

43
00:02:03,637 --> 00:02:05,830
The end results of this course

44
00:02:05,830 --> 00:02:09,317
is that we'll be spinning
out the entire system

45
00:02:09,317 --> 00:02:11,916
to a cluster of EC2 instances

46
00:02:11,916 --> 00:02:13,916
with very little effort.

47
00:02:14,974 --> 00:02:18,359
And that's payoff from using Docker.

48
00:02:18,359 --> 00:02:19,976
Well I hope you enjoy the course.

49
00:02:19,976 --> 00:02:21,171
Docker is great fun

50
00:02:21,171 --> 00:02:23,476
but there's plenty of traps along the way.

51
00:02:23,476 --> 00:02:27,476
I've worked hard to negotiate
you around those traps.

52
00:02:27,476 --> 00:02:29,871
So let's start with Docker networking

53
00:02:29,871 --> 00:02:32,305
which is simple to use but really elegant

54
00:02:32,305 --> 00:02:33,908
and it's the key to getting

55
00:02:33,908 --> 00:02:36,275
a multi container system working.

56
00:02:36,275 --> 00:02:39,358
I'll see you for that in chapter two.

1
00:00:00,870 --> 00:00:01,828
- [Instructor] To start the course,

2
00:00:01,828 --> 00:00:04,813
we're going to look at Docker networking.

3
00:00:04,813 --> 00:00:07,034
And while there's nothing very complicated

4
00:00:07,034 --> 00:00:08,772
coming up in this chapter,

5
00:00:08,772 --> 00:00:11,445
being able to network together containers

6
00:00:11,445 --> 00:00:12,778
is so important.

7
00:00:13,866 --> 00:00:16,103
But you're going to find, I hope,

8
00:00:16,103 --> 00:00:18,766
it's pretty easy to do.

9
00:00:18,766 --> 00:00:20,159
Now, I'm assuming that
most of you will have

10
00:00:20,159 --> 00:00:24,556
already followed Module One
in this series of courses,

11
00:00:24,556 --> 00:00:27,890
and that was where we went
through the basic commands,

12
00:00:27,890 --> 00:00:29,973
basic concepts in Docker.

13
00:00:30,826 --> 00:00:32,373
I know that some of you maybe have

14
00:00:32,373 --> 00:00:34,991
already got that knowledge and might have

15
00:00:34,991 --> 00:00:37,892
come straight to this
module, in which case,

16
00:00:37,892 --> 00:00:41,202
it will be worthwhile
reviewing, very briefly,

17
00:00:41,202 --> 00:00:44,250
what we did in that previous course.

18
00:00:44,250 --> 00:00:47,029
On the course page at
virtualpairprogrammers.com,

19
00:00:47,029 --> 00:00:50,116
you will find a link to
download all of the code

20
00:00:50,116 --> 00:00:54,517
needed for this course, and
one of the folders inside there

21
00:00:54,517 --> 00:00:57,463
is called Starting Workspace.

22
00:00:57,463 --> 00:01:00,199
And you have in there,
I just have one project

23
00:01:00,199 --> 00:01:02,509
on screen at the moment,
but you might find

24
00:01:02,509 --> 00:01:04,487
several projects in there by the time

25
00:01:04,487 --> 00:01:07,542
you watch this video,
because we are going to be

26
00:01:07,542 --> 00:01:10,242
working on some other
projects on this course.

27
00:01:10,242 --> 00:01:12,643
But there will be at
least one folder in there,

28
00:01:12,643 --> 00:01:16,446
one of which will be called
fleetman dash webapp.

29
00:01:16,446 --> 00:01:19,439
Now, I know I've shown you
100 times on previous courses

30
00:01:19,439 --> 00:01:23,952
how to launch these projects
in Eclipse, but again,

31
00:01:23,952 --> 00:01:25,719
just in case you've come
straight to this course

32
00:01:25,719 --> 00:01:27,366
and this is the first course you've done

33
00:01:27,366 --> 00:01:29,855
with Virtual Pair Programmers,
I'll very quickly run through

34
00:01:29,855 --> 00:01:32,993
how to open this in Eclipse.

35
00:01:32,993 --> 00:01:34,673
And the starting point
is, make sure you've

36
00:01:34,673 --> 00:01:38,254
extracted this folder into another folder,

37
00:01:38,254 --> 00:01:42,296
the parent folder will
be your workspace folder.

38
00:01:42,296 --> 00:01:44,186
And as on Module One in this course,

39
00:01:44,186 --> 00:01:45,754
I'll assume you're working in Eclipse,

40
00:01:45,754 --> 00:01:48,616
but really you can work in
any development environment

41
00:01:48,616 --> 00:01:51,258
you like as long as you are competent in

42
00:01:51,258 --> 00:01:53,214
that development environment.

43
00:01:53,214 --> 00:01:54,900
But if you're following along with me,

44
00:01:54,900 --> 00:01:56,998
then you'll need to open the project,

45
00:01:56,998 --> 00:01:59,799
and the easiest way, once
you've opened the workspace,

46
00:01:59,799 --> 00:02:03,966
is to File, New, Java Project,
and for the project name,

47
00:02:05,524 --> 00:02:08,044
we need exactly the
same name as the folder

48
00:02:08,044 --> 00:02:10,335
that we've just extracted,

49
00:02:10,335 --> 00:02:13,782
so that will be fleetman dash webapp,

50
00:02:13,782 --> 00:02:16,430
and then when you click Finish,

51
00:02:16,430 --> 00:02:19,104
it will open up as an existing project.

52
00:02:19,104 --> 00:02:21,110
Because it is a Maven project,

53
00:02:21,110 --> 00:02:22,591
we won't have the build path

54
00:02:22,591 --> 00:02:24,730
correctly configured immediately,

55
00:02:24,730 --> 00:02:27,897
so right-click on the pom.xml, Run As,

56
00:02:29,118 --> 00:02:32,618
Maven Build dot dot dot, and for the goal,

57
00:02:33,850 --> 00:02:37,350
this is going to be eclipse colon eclipse,

58
00:02:38,413 --> 00:02:39,875
and once that's run you should be able to

59
00:02:39,875 --> 00:02:43,292
right-click on the project, do a refresh,

60
00:02:46,552 --> 00:02:50,019
and everything should be
compiling without any errors.

61
00:02:50,019 --> 00:02:52,791
If you have done the previous module,

62
00:02:52,791 --> 00:02:55,189
then you're good to go at this point.

63
00:02:55,189 --> 00:02:57,754
But if you are brand-new to this project,

64
00:02:57,754 --> 00:03:00,031
then there is one further
step you will need to do,

65
00:03:00,031 --> 00:03:04,162
which is to build the JAR
file for this project.

66
00:03:04,162 --> 00:03:06,251
Now, coming up later on this module,

67
00:03:06,251 --> 00:03:09,720
I am going to show you how to
integrate the Docker process

68
00:03:09,720 --> 00:03:12,532
into Maven, but for now,
we're kind of doing things

69
00:03:12,532 --> 00:03:16,161
manually by hand just
to get things started.

70
00:03:16,161 --> 00:03:18,684
So you will need to build this JAR,

71
00:03:18,684 --> 00:03:20,651
so right-click on the POM,

72
00:03:20,651 --> 00:03:23,518
we're going to Run As a Maven build,

73
00:03:23,518 --> 00:03:26,842
and this time the goal is package,

74
00:03:26,842 --> 00:03:29,259
to build a JAR or a WAR file.

75
00:03:30,418 --> 00:03:32,327
And the main file that we worked on

76
00:03:32,327 --> 00:03:34,400
on the previous module of the course was

77
00:03:34,400 --> 00:03:38,172
the Docker file, which
is defining an image.

78
00:03:38,172 --> 00:03:39,815
And we're building an image here from

79
00:03:39,815 --> 00:03:42,413
the standard open JDK images.

80
00:03:42,413 --> 00:03:44,782
I chose on the previous module to use

81
00:03:44,782 --> 00:03:48,693
the Alpine distribution to
keep things small and simple.

82
00:03:48,693 --> 00:03:51,353
That will be relevant
a little bit later on.

83
00:03:51,353 --> 00:03:54,618
But this is a standard
Spring Boot application,

84
00:03:54,618 --> 00:03:57,304
and the command that we're
running in this Docker file

85
00:03:57,304 --> 00:04:00,807
is to run that Spring
Boot application using

86
00:04:00,807 --> 00:04:03,373
the standard Java comand.

87
00:04:03,373 --> 00:04:05,114
I'm assuming for this
module that you already

88
00:04:05,114 --> 00:04:07,384
have Docker installed and working.

89
00:04:07,384 --> 00:04:10,222
If not, check out Module One for details.

90
00:04:10,222 --> 00:04:12,488
But we regularly, on the previous module,

91
00:04:12,488 --> 00:04:14,155
built Docker images.

92
00:04:15,118 --> 00:04:19,035
Docker image build, we
were tagging the images,

93
00:04:20,486 --> 00:04:23,873
and I'm going to go for
a fleetman-webapp tag

94
00:04:23,873 --> 00:04:25,473
for this image.

95
00:04:25,473 --> 00:04:27,607
Now, on the previous
module, I showed you how

96
00:04:27,607 --> 00:04:30,008
to distribute these
images through Docker Hub,

97
00:04:30,008 --> 00:04:33,575
in which case you would have
a username and a forward slash

98
00:04:33,575 --> 00:04:35,429
before that image name.

99
00:04:35,429 --> 00:04:37,319
But when we're working
locally, it's fine to have

100
00:04:37,319 --> 00:04:40,736
just a friendly tag name, and then a dot,

101
00:04:42,638 --> 00:04:46,030
and then you'll have a
local copy of that image.

102
00:04:46,030 --> 00:04:48,982
Okay, and we should be able to
run an instance of that image

103
00:04:48,982 --> 00:04:51,482
now with docker container run.

104
00:04:52,510 --> 00:04:54,745
I'm going to run this one interactively,

105
00:04:54,745 --> 00:04:56,560
because I'm going to
kill it pretty quickly.

106
00:04:56,560 --> 00:04:59,560
So dash it, I'll publish to port 80,

107
00:05:01,595 --> 00:05:05,523
which will map to the container port 8080,

108
00:05:05,523 --> 00:05:09,326
and that's probably enough for
now, so fleetman dash webapp

109
00:05:09,326 --> 00:05:11,457
for the name of the image.

110
00:05:11,457 --> 00:05:13,404
And you should now be
able to test this app by

111
00:05:13,404 --> 00:05:15,071
visiting local host.

112
00:05:16,826 --> 00:05:20,153
Now, this web application is a small part

113
00:05:20,153 --> 00:05:22,859
of a full microservice architecture,

114
00:05:22,859 --> 00:05:27,238
and the way things are set up
is that if it's not running

115
00:05:27,238 --> 00:05:29,811
in the context of the full architecture

116
00:05:29,811 --> 00:05:32,125
and it's just running standalone,

117
00:05:32,125 --> 00:05:36,292
then these vehicle positions
are just random and chaotic.

118
00:05:37,744 --> 00:05:39,561
The end goal of this course, really,

119
00:05:39,561 --> 00:05:42,157
is to build things up
so that we're getting

120
00:05:42,157 --> 00:05:46,477
real live position data
appearing on this webpage.

121
00:05:46,477 --> 00:05:48,405
But for now, if you're
seeing this kind of thing,

122
00:05:48,405 --> 00:05:50,959
then you're good to go.

123
00:05:50,959 --> 00:05:52,762
Now, our presence in this application,

124
00:05:52,762 --> 00:05:55,338
if we check under Source Main Resources,

125
00:05:55,338 --> 00:05:57,011
the profile that we're running under

126
00:05:57,011 --> 00:06:00,187
is this one right here called Docker Demo.

127
00:06:00,187 --> 00:06:03,266
And inside the application is a database

128
00:06:03,266 --> 00:06:05,035
where it's storing the local copy of

129
00:06:05,035 --> 00:06:07,790
all of the vehicle data.

130
00:06:07,790 --> 00:06:10,575
And it uses that to populate the screen.

131
00:06:10,575 --> 00:06:13,399
At present, according to line eight,

132
00:06:13,399 --> 00:06:18,046
what we're using here is an
embedded database in memory.

133
00:06:18,046 --> 00:06:20,309
And I must admit, that's
working absolutely fine,

134
00:06:20,309 --> 00:06:23,884
there's no particular reason
to have a proper database

135
00:06:23,884 --> 00:06:27,212
in this application,
because we don't really need

136
00:06:27,212 --> 00:06:30,647
to modify any data while
the system is running.

137
00:06:30,647 --> 00:06:33,263
However, it will be a
great demonstration to

138
00:06:33,263 --> 00:06:37,410
upgrade the system to
use a proper database.

139
00:06:37,410 --> 00:06:41,121
Now, I'm gonna go for MySQL
for the demonstration here,

140
00:06:41,121 --> 00:06:42,743
but really everything I'm about to say

141
00:06:42,743 --> 00:06:45,791
would apply equally
well to a NoSQL database

142
00:06:45,791 --> 00:06:49,041
like MongoDB or Cassandra, for example.

143
00:06:50,500 --> 00:06:52,913
So how can we upgrade the system so that

144
00:06:52,913 --> 00:06:56,213
we're using a MySQL database instead?

145
00:06:56,213 --> 00:06:59,469
Now, you might think that
all that we need to do here

146
00:06:59,469 --> 00:07:01,838
is take our existing container,

147
00:07:01,838 --> 00:07:04,116
I should say our image, really,

148
00:07:04,116 --> 00:07:07,243
and that we're going to
add in an installation

149
00:07:07,243 --> 00:07:09,243
of MySQL into our image.

150
00:07:10,516 --> 00:07:13,806
So for that we might go
into our Docker file,

151
00:07:13,806 --> 00:07:16,604
somehow add in some commands into here

152
00:07:16,604 --> 00:07:20,320
to instal MySQL, we'd probably
need a few more commands

153
00:07:20,320 --> 00:07:24,022
to configure it, and then
somehow we would have to

154
00:07:24,022 --> 00:07:26,939
start up MySQL as a daemon process.

155
00:07:28,782 --> 00:07:32,269
Or maybe instal it as
some kind of a service.

156
00:07:32,269 --> 00:07:35,125
That would really depend
on what Linux distribution

157
00:07:35,125 --> 00:07:37,222
you're working on.

158
00:07:37,222 --> 00:07:39,623
Or you might think it would
be possible to go onto

159
00:07:39,623 --> 00:07:43,790
this line here, line 11, and
add in a further command,

160
00:07:45,681 --> 00:07:49,288
and this command would be running MySQL.

161
00:07:49,288 --> 00:07:51,051
Now, I must admit that in my early days

162
00:07:51,051 --> 00:07:53,907
of working with Docker,
I would often find myself

163
00:07:53,907 --> 00:07:57,270
thinking like this and
would often ask myself

164
00:07:57,270 --> 00:08:00,620
the question, how do I
instal an additional service

165
00:08:00,620 --> 00:08:02,527
into my container?

166
00:08:02,527 --> 00:08:06,199
Well, I know better now,
and I want to be clear

167
00:08:06,199 --> 00:08:09,932
on this course that by design, really,

168
00:08:09,932 --> 00:08:12,062
the whole thinking behind Docker,

169
00:08:12,062 --> 00:08:15,371
is that containers are
supposed to be exposing

170
00:08:15,371 --> 00:08:16,788
one service only.

171
00:08:19,010 --> 00:08:22,544
Now, I haven't defined the term service,

172
00:08:22,544 --> 00:08:25,363
and actually service will
be a keyword coming up

173
00:08:25,363 --> 00:08:28,483
a bit later on on the Docker command line.

174
00:08:28,483 --> 00:08:31,980
But really I'm using the
term service generally here,

175
00:08:31,980 --> 00:08:35,063
and really the service is the command

176
00:08:36,320 --> 00:08:40,445
that you are issuing here at
the end of your Docker file.

177
00:08:40,445 --> 00:08:45,288
So in our case, the service
is the Spring Boot application

178
00:08:45,288 --> 00:08:49,199
which is going to be
running our web application.

179
00:08:49,199 --> 00:08:51,446
If you look around on
the web, you'll find that

180
00:08:51,446 --> 00:08:56,231
it is possible to add multiple
services to a container,

181
00:08:56,231 --> 00:08:58,197
and I have an example here.

182
00:08:58,197 --> 00:09:01,118
This is just a random search,
really, on stack overflow,

183
00:09:01,118 --> 00:09:04,067
and I must admit it is
quite an old question

184
00:09:04,067 --> 00:09:07,347
at the time of recording, this
is about three years old now,

185
00:09:07,347 --> 00:09:11,824
and Docker has moved on
immensely since then.

186
00:09:11,824 --> 00:09:15,391
But this questioner is
asking, how could I instal,

187
00:09:15,391 --> 00:09:18,808
I think in this case it's the SSH service

188
00:09:19,868 --> 00:09:24,795
into their container, and
have the RabbitMQ service

189
00:09:24,795 --> 00:09:25,988
in the container.

190
00:09:25,988 --> 00:09:28,974
So RabbitMQ, just a message broker.

191
00:09:28,974 --> 00:09:31,094
And they did get three answers.

192
00:09:31,094 --> 00:09:34,844
And as stated here,
there can only be one CMD

193
00:09:37,860 --> 00:09:39,796
in your Docker file.

194
00:09:39,796 --> 00:09:41,106
Now, that's not quite true,

195
00:09:41,106 --> 00:09:43,607
you can have multiple CMD commands,

196
00:09:43,607 --> 00:09:47,774
but only, well, I think it's
the last one, will apply.

197
00:09:48,975 --> 00:09:50,383
Well, I'm a bit unsure about that.

198
00:09:50,383 --> 00:09:53,522
The important thing is only
one of them will be respected

199
00:09:53,522 --> 00:09:57,219
and it doesn't really
matter which one it is,

200
00:09:57,219 --> 00:09:58,587
because you really should not have

201
00:09:58,587 --> 00:10:00,742
multiple CMD instructions.

202
00:10:00,742 --> 00:10:03,666
That would just be so confusing.

203
00:10:03,666 --> 00:10:06,544
Now, there are workarounds
that enable you to have

204
00:10:06,544 --> 00:10:10,544
multiple services, and
the upshot of this answer

205
00:10:11,502 --> 00:10:15,427
is saying, well, you would
add a supervising service,

206
00:10:15,427 --> 00:10:18,017
and that supervising
service would be able to

207
00:10:18,017 --> 00:10:21,061
manage multiple services for you.

208
00:10:21,061 --> 00:10:25,901
So it is possible to add
multiple services to a container,

209
00:10:25,901 --> 00:10:29,634
but I would recommend in
almost all circumstances

210
00:10:29,634 --> 00:10:31,340
that you don't do that.

211
00:10:31,340 --> 00:10:35,507
It's best practise to make a
container do one thing only.

212
00:10:37,319 --> 00:10:41,059
If you have multiple services
exposed by your container,

213
00:10:41,059 --> 00:10:44,642
like this one here, I
have a Tomcat service

214
00:10:45,889 --> 00:10:48,410
which will be reading from this WAR file,

215
00:10:48,410 --> 00:10:52,116
and I also have this
MySQL service in here.

216
00:10:52,116 --> 00:10:54,154
Then it's going to be very difficult for

217
00:10:54,154 --> 00:10:58,321
the container itself to know
if the service has died.

218
00:11:00,231 --> 00:11:02,272
Now, this is going to be
important as we go forward

219
00:11:02,272 --> 00:11:03,891
on this course.

220
00:11:03,891 --> 00:11:06,546
We need an easy way of
knowing if a container

221
00:11:06,546 --> 00:11:08,046
is healthy or not.

222
00:11:09,246 --> 00:11:13,462
For instance, if Tomcat were
to die inside this container,

223
00:11:13,462 --> 00:11:16,267
then we wanna be able to monitor that,

224
00:11:16,267 --> 00:11:19,046
and we want to be able to
kill the entire container

225
00:11:19,046 --> 00:11:21,807
and start a brand-new container.

226
00:11:21,807 --> 00:11:23,903
Now, that's all coming later
on, but if you think about it,

227
00:11:23,903 --> 00:11:27,768
if you've got two big
services inside a container,

228
00:11:27,768 --> 00:11:31,552
it's going to be much harder
to look at this container

229
00:11:31,552 --> 00:11:33,733
and tell whether it's healthy or not.

230
00:11:33,733 --> 00:11:36,114
Now, those answers on stack overflow

231
00:11:36,114 --> 00:11:38,685
were basically saying you
would wrap the two services

232
00:11:38,685 --> 00:11:41,491
into a single one, and then, okay,

233
00:11:41,491 --> 00:11:43,177
you'd be able to monitor that.

234
00:11:43,177 --> 00:11:45,663
But that's really kind
of a technical answer,

235
00:11:45,663 --> 00:11:48,760
and the real answer is
that it's just really

236
00:11:48,760 --> 00:11:50,828
by Docker's design.

237
00:11:50,828 --> 00:11:53,779
It's best to think of a container not as

238
00:11:53,779 --> 00:11:56,392
being a virtual machine or as some kind of

239
00:11:56,392 --> 00:12:01,187
virtual Linux distribution
that you instal software onto.

240
00:12:01,187 --> 00:12:04,379
It's much better to
think of each container

241
00:12:04,379 --> 00:12:07,379
as being a service in its own right.

242
00:12:08,639 --> 00:12:11,060
Now, on this course, we're aiming to build

243
00:12:11,060 --> 00:12:13,007
a microservice architecture,

244
00:12:13,007 --> 00:12:16,167
so I hope that just makes sense.

245
00:12:16,167 --> 00:12:20,506
Just as a microservice
should do one thing only,

246
00:12:20,506 --> 00:12:25,012
it's exactly the same for the
containers on which they run.

247
00:12:25,012 --> 00:12:29,179
A container should expose just
a single service to clients.

248
00:12:31,739 --> 00:12:33,187
But even if you're not working in

249
00:12:33,187 --> 00:12:35,146
a microservice architecture,

250
00:12:35,146 --> 00:12:37,862
this rule of thumb still applies.

251
00:12:37,862 --> 00:12:39,329
Whatever you're doing with Docker,

252
00:12:39,329 --> 00:12:43,229
it makes good sense to keep
each container cohesive

253
00:12:43,229 --> 00:12:46,646
with each one providing a single service.

254
00:12:47,594 --> 00:12:51,783
And that service is the
command instruction,

255
00:12:51,783 --> 00:12:54,248
or it could be the entry point that we saw

256
00:12:54,248 --> 00:12:55,518
on the previous course,

257
00:12:55,518 --> 00:12:57,709
there's no big difference between the two.

258
00:12:57,709 --> 00:13:00,807
Whatever you're declaring
here is the service

259
00:13:00,807 --> 00:13:02,941
that this container is offering,

260
00:13:02,941 --> 00:13:05,234
and the fact that we're
only offering one service

261
00:13:05,234 --> 00:13:07,868
makes the container easy to understand,

262
00:13:07,868 --> 00:13:12,755
easy to maintain, and easy
to manage at run time.

263
00:13:12,755 --> 00:13:16,702
We know that if this process
here fails for any reason,

264
00:13:16,702 --> 00:13:20,369
then the container
itself is basically dead.

265
00:13:21,593 --> 00:13:25,138
So to summarise on that, then,
it is technically possible

266
00:13:25,138 --> 00:13:28,084
to run more than one
service in a container,

267
00:13:28,084 --> 00:13:31,284
but I would think of that
as something to consider

268
00:13:31,284 --> 00:13:34,617
only if you're absolutely 100% sure

269
00:13:35,735 --> 00:13:37,930
that that's what's needed.

270
00:13:37,930 --> 00:13:40,521
One instal is a better way
to do things in Docker,

271
00:13:40,521 --> 00:13:43,623
and if I can just briefly
return to this question,

272
00:13:43,623 --> 00:13:45,161
it is quite an old question,

273
00:13:45,161 --> 00:13:46,609
but clearly what they're trying to do is

274
00:13:46,609 --> 00:13:50,059
they want to build a
container that offers RabbitMQ

275
00:13:50,059 --> 00:13:53,139
as a service, but
they've also decided, oh,

276
00:13:53,139 --> 00:13:55,835
I'd also like to be able to
connect to this container

277
00:13:55,835 --> 00:14:00,002
so I can manage it, so
they're trying to instal SSH

278
00:14:01,506 --> 00:14:05,087
so that they can SSH into that container.

279
00:14:05,087 --> 00:14:09,789
And as you saw from the previous
module, you don't need SSH.

280
00:14:09,789 --> 00:14:14,476
You can do an exec command
to connect to the container.

281
00:14:14,476 --> 00:14:16,958
There's one specific example where

282
00:14:16,958 --> 00:14:20,469
what they're trying to do
here is the wrong thing.

283
00:14:20,469 --> 00:14:22,705
Now, I can't remember
three years ago in Docker,

284
00:14:22,705 --> 00:14:25,606
it's possible that at
that time it was difficult

285
00:14:25,606 --> 00:14:27,980
to do the equivalent of the exec command,

286
00:14:27,980 --> 00:14:30,226
so this was something of a workaround.

287
00:14:30,226 --> 00:14:32,936
But it's certainly not needed today.

288
00:14:32,936 --> 00:14:35,794
But in our example, we
do need both services.

289
00:14:35,794 --> 00:14:39,757
We need our Java webapp,
and we need MySQL.

290
00:14:39,757 --> 00:14:41,756
So that's where all of this is leading.

291
00:14:41,756 --> 00:14:45,043
We're simply going to
have multiple containers,

292
00:14:45,043 --> 00:14:48,686
and each container will
provide a single service.

293
00:14:48,686 --> 00:14:51,168
Now, obviously, we've
got to be able to have

294
00:14:51,168 --> 00:14:55,231
these containers talking
to each other somehow,

295
00:14:55,231 --> 00:14:58,490
and that's what this chapter's all about.

296
00:14:58,490 --> 00:15:02,657
It's really easy to network
these two containers together.

297
00:15:03,790 --> 00:15:06,685
Now, the network
connection that you can see

298
00:15:06,685 --> 00:15:08,220
between these two containers,

299
00:15:08,220 --> 00:15:10,215
it's really important to
point out that this is

300
00:15:10,215 --> 00:15:14,298
just a container to
container network connection.

301
00:15:16,078 --> 00:15:20,097
In fact, the containers are
on their own private network.

302
00:15:20,097 --> 00:15:23,309
Now, all that means is
that any computers outside

303
00:15:23,309 --> 00:15:26,752
of our Docker system
are not going to be able

304
00:15:26,752 --> 00:15:29,085
to see this MySQL container.

305
00:15:30,232 --> 00:15:31,640
All right, well, that's enough talk,

306
00:15:31,640 --> 00:15:34,118
let's get Docker networking into practise.

307
00:15:34,118 --> 00:15:37,203
I'm back in my Docker shell,
and I'll do a Control C

308
00:15:37,203 --> 00:15:41,468
to stop the container
that I was running before.

309
00:15:41,468 --> 00:15:43,075
Now, before we do anything else,

310
00:15:43,075 --> 00:15:46,527
we need to set up a MySQL container.

311
00:15:46,527 --> 00:15:49,394
As usual, as on the previous course,

312
00:15:49,394 --> 00:15:50,716
we could do that manually,

313
00:15:50,716 --> 00:15:54,533
but we'll probably find that
there's a predefined image

314
00:15:54,533 --> 00:15:56,996
available on Docker Hub.

315
00:15:56,996 --> 00:16:00,929
And if we do a search
on Docker Hub for MySQL,

316
00:16:00,929 --> 00:16:02,921
you're not going to be
surprised to discover

317
00:16:02,921 --> 00:16:06,433
that there is an official image for MySQL,

318
00:16:06,433 --> 00:16:08,022
and I'm pleased to say that it does have

319
00:16:08,022 --> 00:16:10,740
a pretty good reference guide.

320
00:16:10,740 --> 00:16:13,127
So several tags available
at the time of recording.

321
00:16:13,127 --> 00:16:16,425
There is a series of version eight tags.

322
00:16:16,425 --> 00:16:18,504
However, just going back into the project,

323
00:16:18,504 --> 00:16:22,644
now we actually wrote this
system quite a long time ago now

324
00:16:22,644 --> 00:16:26,515
on our original Spring
Boot training course.

325
00:16:26,515 --> 00:16:29,688
So it's a year or two old, this project,

326
00:16:29,688 --> 00:16:33,310
and if I have a look inside the pom.xml,

327
00:16:33,310 --> 00:16:35,477
we happen to already have,

328
00:16:36,851 --> 00:16:39,202
and this is just from some previous work,

329
00:16:39,202 --> 00:16:43,170
here on line 136, we do have a declaration

330
00:16:43,170 --> 00:16:44,920
for the MySQL driver.

331
00:16:46,031 --> 00:16:49,622
And we happen to use version 5.1.6.

332
00:16:49,622 --> 00:16:54,320
Now, it is important that
the database that we're using

333
00:16:54,320 --> 00:16:57,684
is consistent with the
version that you see here.

334
00:16:57,684 --> 00:17:01,922
So I could change this to
be version 8.something,

335
00:17:01,922 --> 00:17:06,537
and then I could use one of
these 8.something images.

336
00:17:06,537 --> 00:17:09,150
However, I've decided
to keep things simple.

337
00:17:09,150 --> 00:17:12,305
I'm going to use one of
the version five images,

338
00:17:12,305 --> 00:17:15,440
and then I won't need
to change my Maven POM.

339
00:17:15,440 --> 00:17:18,125
It's up to you which
way around you do that.

340
00:17:18,125 --> 00:17:20,211
So we're going to be
using one of these images,

341
00:17:20,211 --> 00:17:23,444
and a little further
down, there's some blurb,

342
00:17:23,444 --> 00:17:24,917
and there's an example about how to

343
00:17:24,917 --> 00:17:27,377
run a container from this image.

344
00:17:27,377 --> 00:17:29,557
And the only big deal here,

345
00:17:29,557 --> 00:17:31,843
and something that we
haven't covered so far,

346
00:17:31,843 --> 00:17:36,010
is that you can pass environment
variables to a container

347
00:17:36,858 --> 00:17:39,025
using the dash e argument,

348
00:17:40,231 --> 00:17:43,065
and then it's just key value pairs.

349
00:17:43,065 --> 00:17:45,198
Now, in order to start this database,

350
00:17:45,198 --> 00:17:46,990
you do have to give, at the very least,

351
00:17:46,990 --> 00:17:48,907
a MySQL route password.

352
00:17:50,876 --> 00:17:52,391
So on your document command line,

353
00:17:52,391 --> 00:17:55,364
we can do a Docker container run,

354
00:17:55,364 --> 00:17:59,531
and so we need that dash e,
and it's MySQL underscore ROOT

355
00:18:01,818 --> 00:18:04,717
underscore PASSWORD equals,

356
00:18:04,717 --> 00:18:06,774
and I'm going to be very insecure here,

357
00:18:06,774 --> 00:18:09,348
just because we're doing
quick and basic tests,

358
00:18:09,348 --> 00:18:12,626
I'll use the password of password.

359
00:18:12,626 --> 00:18:16,962
And I want to run this as a
detached process, so dash d,

360
00:18:16,962 --> 00:18:20,163
and then the name of the image is mysql,

361
00:18:20,163 --> 00:18:21,816
and as I said, importantly,

362
00:18:21,816 --> 00:18:25,205
we're going for one of
the version five releases,

363
00:18:25,205 --> 00:18:28,372
so colon five will do for this course.

364
00:18:29,240 --> 00:18:30,997
Okay, so I hope that
worked for you as well,

365
00:18:30,997 --> 00:18:32,752
we should now have a new container.

366
00:18:32,752 --> 00:18:34,631
And of course we can check
the logs for that container

367
00:18:34,631 --> 00:18:38,491
using the usual Docker
container logs command.

368
00:18:38,491 --> 00:18:40,024
I'm using here the first two characters

369
00:18:40,024 --> 00:18:42,435
of the ID of the container.

370
00:18:42,435 --> 00:18:44,525
I'll talk about the
names of these containers

371
00:18:44,525 --> 00:18:46,332
in a few moments, because
that's going to become

372
00:18:46,332 --> 00:18:48,313
really important.

373
00:18:48,313 --> 00:18:50,899
But I don't routinely look at MySQL logs,

374
00:18:50,899 --> 00:18:54,934
but that kind of thing,
yep, that looks okay to me.

375
00:18:54,934 --> 00:18:57,590
Before we go any further,
I would like to check that

376
00:18:57,590 --> 00:19:01,853
this is actually working
as a MySQL container.

377
00:19:01,853 --> 00:19:03,097
So how can I do that?

378
00:19:03,097 --> 00:19:06,644
Well, as I mentioned, we can
do the equivalent of an SSH

379
00:19:06,644 --> 00:19:10,567
using the Docker container exec command.

380
00:19:10,567 --> 00:19:13,614
We'll need dash it for interactive.

381
00:19:13,614 --> 00:19:17,171
The ID of the container
for me was beginning 4f,

382
00:19:17,171 --> 00:19:19,888
and we can run the bash
command to get a command line.

383
00:19:19,888 --> 00:19:22,950
And I'm not sure this is really necessary,

384
00:19:22,950 --> 00:19:26,292
but because we're now
in that MySQL container,

385
00:19:26,292 --> 00:19:29,960
the MySQL container will have
the client tools as well.

386
00:19:29,960 --> 00:19:33,043
So I could do MySQL dash uroot dash p

387
00:19:36,603 --> 00:19:38,735
whatever you used for your password,

388
00:19:38,735 --> 00:19:41,674
and that should be enough to get you

389
00:19:41,674 --> 00:19:43,326
on the MySQL command line.

390
00:19:43,326 --> 00:19:44,850
We would have had an error there if

391
00:19:44,850 --> 00:19:47,150
there was anything wrong,
but I can do a basic

392
00:19:47,150 --> 00:19:51,067
show databases to check
that everything's okay.

393
00:19:52,577 --> 00:19:54,660
So that's good, but we will
need to have a database

394
00:19:54,660 --> 00:19:57,494
for us to store our
data in, and by default,

395
00:19:57,494 --> 00:20:01,263
MySQL comes with four predefined schemas,

396
00:20:01,263 --> 00:20:04,158
as they call them, but
they're really databases.

397
00:20:04,158 --> 00:20:06,991
Now, we need our own
custom database in here.

398
00:20:06,991 --> 00:20:10,090
Now, we could create that
on the command line here,

399
00:20:10,090 --> 00:20:11,701
but of course that's no use because

400
00:20:11,701 --> 00:20:13,606
we're going to destroy this container

401
00:20:13,606 --> 00:20:15,702
and we'll want to create a new container

402
00:20:15,702 --> 00:20:17,499
at some point in the future.

403
00:20:17,499 --> 00:20:19,556
So we can very easily do this.

404
00:20:19,556 --> 00:20:23,057
If we exit out of that MySQL command line

405
00:20:23,057 --> 00:20:26,341
and then exit out of the Bash shell,

406
00:20:26,341 --> 00:20:30,508
remember, the container we
created is still running.

407
00:20:32,031 --> 00:20:35,031
So I'm going to stop that container.

408
00:20:37,137 --> 00:20:41,678
And I'll recall the command
I used to run that container.

409
00:20:41,678 --> 00:20:45,868
And we can add a further
environment variable into here.

410
00:20:45,868 --> 00:20:48,368
I'm really working from
that little reference guide

411
00:20:48,368 --> 00:20:50,581
on Docker Hub here that there is another

412
00:20:50,581 --> 00:20:54,748
environment variable called
mysql underscore database.

413
00:20:58,810 --> 00:21:00,511
And if we set that equal to,

414
00:21:00,511 --> 00:21:02,793
I'm going to call the database Fleetman,

415
00:21:02,793 --> 00:21:05,435
then when the container starts,

416
00:21:05,435 --> 00:21:09,487
a new database will automatically
be created with that name.

417
00:21:09,487 --> 00:21:11,374
Let's try that.

418
00:21:11,374 --> 00:21:14,556
So my new container is
this one beginning d3,

419
00:21:14,556 --> 00:21:17,556
and if I go back to the exec command

420
00:21:19,044 --> 00:21:21,420
and change that for a d3,

421
00:21:21,420 --> 00:21:25,921
I should be able to
repeat my mysql dash uroot

422
00:21:25,921 --> 00:21:29,088
dash p password, and this time around,

423
00:21:31,002 --> 00:21:33,835
if I do show databases, and great,

424
00:21:35,377 --> 00:21:37,813
we have a default database called Fleetman

425
00:21:37,813 --> 00:21:40,404
that we can start to do some work in.

426
00:21:40,404 --> 00:21:42,180
So we have two containers, then,

427
00:21:42,180 --> 00:21:45,620
one with our web application
and one with our database,

428
00:21:45,620 --> 00:21:47,528
and what we need to do is to be able to

429
00:21:47,528 --> 00:21:50,231
network these two containers together.

430
00:21:50,231 --> 00:21:52,472
The scheme that Docker networking uses

431
00:21:52,472 --> 00:21:53,996
is very clever.

432
00:21:53,996 --> 00:21:57,163
It takes the name of the container and

433
00:21:57,999 --> 00:22:01,832
it adds that container
name to the DNS service

434
00:22:02,755 --> 00:22:05,756
that each container is using.

435
00:22:05,756 --> 00:22:08,136
And what that means, it's
very straightforward,

436
00:22:08,136 --> 00:22:11,584
is if we're on any container,
then we can network

437
00:22:11,584 --> 00:22:15,251
to another container by simply using

438
00:22:15,251 --> 00:22:18,906
the container's name as a domain name,

439
00:22:18,906 --> 00:22:22,076
so we don't need to deal
with any IP addresses.

440
00:22:22,076 --> 00:22:25,805
And Docker uses some
really clever techniques,

441
00:22:25,805 --> 00:22:29,704
such that when we start
a brand new container

442
00:22:29,704 --> 00:22:31,970
with a brand new name, then automatically

443
00:22:31,970 --> 00:22:35,021
all of the existing
containers in the network

444
00:22:35,021 --> 00:22:37,854
are propagated with that new name.

445
00:22:39,141 --> 00:22:42,048
Now, I could do a complicated
picture to describe this,

446
00:22:42,048 --> 00:22:44,236
but I think it's best
if we just go straight

447
00:22:44,236 --> 00:22:47,203
to the command line and try this out.

448
00:22:47,203 --> 00:22:48,739
Well, I previously left things inside

449
00:22:48,739 --> 00:22:51,844
the MySQL command line,
so I will exit from that,

450
00:22:51,844 --> 00:22:55,610
and exit from the Bash shell as well.

451
00:22:55,610 --> 00:22:58,005
So I'm back on my host's command line.

452
00:22:58,005 --> 00:23:00,740
Now, if we do a Docker container ls,

453
00:23:00,740 --> 00:23:03,004
we've got just the one
container running at the moment

454
00:23:03,004 --> 00:23:05,417
which is the database container.

455
00:23:05,417 --> 00:23:08,338
On my screen, I'll need to
scroll across to the right.

456
00:23:08,338 --> 00:23:12,024
Now, up until now, on
this series of courses,

457
00:23:12,024 --> 00:23:14,847
I haven't really talked very much about

458
00:23:14,847 --> 00:23:16,889
the name of the container.

459
00:23:16,889 --> 00:23:18,805
By default, I've been kind of working with

460
00:23:18,805 --> 00:23:22,179
the ID of the container, but
we can give every container

461
00:23:22,179 --> 00:23:23,679
one or more names.

462
00:23:25,724 --> 00:23:28,655
And the names are really
intended to be friendly names

463
00:23:28,655 --> 00:23:31,362
that we recognise that container by.

464
00:23:31,362 --> 00:23:33,478
Now, you must admit, every
time I've been having to

465
00:23:33,478 --> 00:23:36,626
use that container ID,
you might have found that

466
00:23:36,626 --> 00:23:39,709
quite awkward in that
it's just a long string

467
00:23:39,709 --> 00:23:42,060
of nasty characters.

468
00:23:42,060 --> 00:23:43,567
Now, so far, I haven't bothered giving

469
00:23:43,567 --> 00:23:46,019
any of our containers names,

470
00:23:46,019 --> 00:23:48,414
so we've been having these
strange default names

471
00:23:48,414 --> 00:23:50,268
generated for us.

472
00:23:50,268 --> 00:23:53,646
So it's an adjective
followed by the surname

473
00:23:53,646 --> 00:23:55,830
of some notable person.

474
00:23:55,830 --> 00:23:59,101
So obviously in my case,
this one is Steve Wozniak.

475
00:23:59,101 --> 00:24:01,337
I wonder if they've put Jobs in that list?

476
00:24:01,337 --> 00:24:03,619
I'm not sure, but anyway.

477
00:24:03,619 --> 00:24:07,175
What I've told you so
far is that therefore,

478
00:24:07,175 --> 00:24:10,382
this container will now be addressable

479
00:24:10,382 --> 00:24:14,549
via the domain name of
quizzical underscore wozniak.

480
00:24:16,030 --> 00:24:19,155
But actually, there is one
thing that you need to do

481
00:24:19,155 --> 00:24:22,302
to make this whole thing work.

482
00:24:22,302 --> 00:24:24,554
Now, I'm going to be a little
bit long-winded about this,

483
00:24:24,554 --> 00:24:27,697
and I'm being long-winded
purely because I always forget

484
00:24:27,697 --> 00:24:31,030
that you have to take some
steps to make this work.

485
00:24:31,030 --> 00:24:32,463
So I know this might be boring for you,

486
00:24:32,463 --> 00:24:33,794
but I'm going to show you first of all

487
00:24:33,794 --> 00:24:36,127
that this isn't yet working.

488
00:24:36,987 --> 00:24:38,914
And to do that, I think I'll just recall

489
00:24:38,914 --> 00:24:42,440
my previous command, it'll
be quite a way back now,

490
00:24:42,440 --> 00:24:45,773
where I started up the webapp container.

491
00:24:47,245 --> 00:24:51,479
And here it is, docker
container run dash it.

492
00:24:51,479 --> 00:24:55,189
Well, this time I'm going
to do it in detached mode,

493
00:24:55,189 --> 00:24:57,109
and I'm publishing the port,

494
00:24:57,109 --> 00:24:59,532
and this is going to be the webapp.

495
00:24:59,532 --> 00:25:03,556
So I now have two containers,
one of which is the webapp,

496
00:25:03,556 --> 00:25:06,110
and for me it's called pensive_cori.

497
00:25:06,110 --> 00:25:11,037
And I have my database, which
is called quizzical_wozniak.

498
00:25:11,037 --> 00:25:13,204
Now, in theory, if I log on,

499
00:25:13,204 --> 00:25:16,138
or I should say do an exec to get access

500
00:25:16,138 --> 00:25:19,476
to this pensive_cori container,

501
00:25:19,476 --> 00:25:23,583
I should be able to
ping quizzical_wozniak.

502
00:25:23,583 --> 00:25:25,267
Let's try that.

503
00:25:25,267 --> 00:25:28,184
So I'll do a docker container exec,

504
00:25:29,080 --> 00:25:33,011
dash it, and the container
ID I am connecting to

505
00:25:33,011 --> 00:25:36,261
is this one beginning, confusingly, db.

506
00:25:37,294 --> 00:25:41,150
I'll put dbe there because
it's not a database,

507
00:25:41,150 --> 00:25:43,248
this one is the web application.

508
00:25:43,248 --> 00:25:46,810
And the command I'm running,
actually, Bash won't run,

509
00:25:46,810 --> 00:25:48,719
I'll just demonstrate that.

510
00:25:48,719 --> 00:25:51,257
Bash isn't going to
work because the webapp

511
00:25:51,257 --> 00:25:54,026
is built on an Alpine container,

512
00:25:54,026 --> 00:25:56,073
which doesn't have Bash installed.

513
00:25:56,073 --> 00:25:58,240
It does have SH installed.

514
00:25:59,806 --> 00:26:02,252
And now I'm on the command line.

515
00:26:02,252 --> 00:26:05,372
We can use ping, and just to demonstrate,

516
00:26:05,372 --> 00:26:07,789
I'll do a ping on google.com.

517
00:26:10,042 --> 00:26:13,339
Assuming by the time you watch
this that google.com exists,

518
00:26:13,339 --> 00:26:16,279
you should see output like this.

519
00:26:16,279 --> 00:26:19,228
So these are successful
pings to that server.

520
00:26:19,228 --> 00:26:20,911
But I've been promising you,

521
00:26:20,911 --> 00:26:22,663
so I just did a Control C there.

522
00:26:22,663 --> 00:26:24,884
But I've been promising
you that we should be able

523
00:26:24,884 --> 00:26:28,467
to ping the name of
the database container.

524
00:26:30,032 --> 00:26:32,557
Now, of course, it will
be different for you.

525
00:26:32,557 --> 00:26:35,640
For me, quizzical underscore wozniak.

526
00:26:36,484 --> 00:26:39,317
Well, I hope I spell it correctly.

527
00:26:41,734 --> 00:26:45,067
Now, I am getting the error bad address,

528
00:26:46,332 --> 00:26:48,866
and I have double-checked
and triple-checked,

529
00:26:48,866 --> 00:26:50,741
my spelling is correct.

530
00:26:50,741 --> 00:26:52,788
Now, I wanted to do that, as I say,

531
00:26:52,788 --> 00:26:55,913
just because I have lost
count of the number of times

532
00:26:55,913 --> 00:26:59,650
on a real project that
I've started networking

533
00:26:59,650 --> 00:27:02,957
and I think there's
something horribly wrong,

534
00:27:02,957 --> 00:27:07,195
I've got some terrible
misconfiguration, and we haven't.

535
00:27:07,195 --> 00:27:10,892
The reason for this is we
do need to create a network

536
00:27:10,892 --> 00:27:14,258
before we can start
using Docker networking,

537
00:27:14,258 --> 00:27:16,926
and that gives me the
opportunity for the first time

538
00:27:16,926 --> 00:27:21,025
to show you the network
commands in Docker.

539
00:27:21,025 --> 00:27:22,525
Let's start again.

540
00:27:23,478 --> 00:27:25,812
If we exit that container,

541
00:27:25,812 --> 00:27:28,395
we have two containers running,

542
00:27:30,415 --> 00:27:32,748
I'm going to stop them both.

543
00:27:36,982 --> 00:27:39,363
And I'll do a clear as
well to tidy things up.

544
00:27:39,363 --> 00:27:43,788
Now, there are a series of
management commands in Docker

545
00:27:43,788 --> 00:27:46,038
which begin docker network.

546
00:27:47,951 --> 00:27:51,280
We've seen docker
container and docker image,

547
00:27:51,280 --> 00:27:54,571
and you'll know that for
both of those we can do an ls

548
00:27:54,571 --> 00:27:57,731
to list the containers
and list the images.

549
00:27:57,731 --> 00:28:00,510
Well, we can do the same for networks.

550
00:28:00,510 --> 00:28:04,367
A docker network ls will
show us all of the networks

551
00:28:04,367 --> 00:28:07,505
that we have in our Docker installation.

552
00:28:07,505 --> 00:28:11,139
You'll probably be seeing
three results here.

553
00:28:11,139 --> 00:28:12,895
Now, we don't really need to worry about

554
00:28:12,895 --> 00:28:15,147
what these networks are.

555
00:28:15,147 --> 00:28:19,070
But I'll go for this one
here, which is called bridge.

556
00:28:19,070 --> 00:28:20,456
I'll be talking later on in the course

557
00:28:20,456 --> 00:28:22,906
what these drivers are all about,

558
00:28:22,906 --> 00:28:25,965
but the network called bridge is in fact

559
00:28:25,965 --> 00:28:27,626
the default network.

560
00:28:27,626 --> 00:28:29,756
It's the network that
all of our containers

561
00:28:29,756 --> 00:28:31,741
have been connecting to.

562
00:28:31,741 --> 00:28:34,248
And what that bridge
network will give you is

563
00:28:34,248 --> 00:28:35,581
outward traffic.

564
00:28:36,661 --> 00:28:39,882
In other words, it's acting like a nat.

565
00:28:39,882 --> 00:28:41,747
If you're not sure what
nats are all about,

566
00:28:41,747 --> 00:28:45,830
then we have a course
called How to Secure a VPC.

567
00:28:46,932 --> 00:28:49,100
And we talk a lot about nats.

568
00:28:49,100 --> 00:28:51,691
A nat allows for outbound traffic,

569
00:28:51,691 --> 00:28:53,073
and that was the reason why,

570
00:28:53,073 --> 00:28:55,696
when we were in our
container a few moments ago,

571
00:28:55,696 --> 00:28:58,129
we could ping google.com.

572
00:28:58,129 --> 00:29:01,831
It's because it was using
this bridge network.

573
00:29:01,831 --> 00:29:05,184
But unfortunately, the
bridge network does not allow

574
00:29:05,184 --> 00:29:08,017
container to container networking.

575
00:29:09,653 --> 00:29:12,393
If we want container to
container networking,

576
00:29:12,393 --> 00:29:15,023
then we have to create our own network

577
00:29:15,023 --> 00:29:18,164
and add it to this list,
which is really simple to do,

578
00:29:18,164 --> 00:29:19,294
so don't worry if you think there's

579
00:29:19,294 --> 00:29:21,347
something nasty coming up.

580
00:29:21,347 --> 00:29:23,785
The other two networks here
we don't need to worry about

581
00:29:23,785 --> 00:29:26,064
at all on this course.

582
00:29:26,064 --> 00:29:30,407
The host network here is
the network that your host

583
00:29:30,407 --> 00:29:33,215
is connected to, so
that is your connection

584
00:29:33,215 --> 00:29:35,382
to your router, basically.

585
00:29:36,310 --> 00:29:39,154
So if you were to connect
your container to this,

586
00:29:39,154 --> 00:29:41,768
then it would be visible
to the outside world.

587
00:29:41,768 --> 00:29:43,765
I've never used this host network,

588
00:29:43,765 --> 00:29:45,300
but I guess it does have some uses.

589
00:29:45,300 --> 00:29:48,609
And there is a none network as well,

590
00:29:48,609 --> 00:29:50,525
which would simply mean
your container would have

591
00:29:50,525 --> 00:29:53,612
no networking at all,
nothing would be able

592
00:29:53,612 --> 00:29:56,286
to connect to it, but crucially,

593
00:29:56,286 --> 00:29:59,432
it wouldn't be able to
connect outwards either.

594
00:29:59,432 --> 00:30:01,137
So I guess you could use that if

595
00:30:01,137 --> 00:30:03,147
you really genuinely
don't want your container

596
00:30:03,147 --> 00:30:05,193
to be outward-facing.

597
00:30:05,193 --> 00:30:06,884
The default, then, is bridge.

598
00:30:06,884 --> 00:30:10,846
We need our own network,
and it's really simple.

599
00:30:10,846 --> 00:30:14,467
Docker network create,
followed by the name

600
00:30:14,467 --> 00:30:16,484
of the network that you want to create.

601
00:30:16,484 --> 00:30:18,802
This is just going to be a friendly name.

602
00:30:18,802 --> 00:30:22,869
I'm going to go on this
course for my dash network,

603
00:30:22,869 --> 00:30:24,353
you can use your own label there

604
00:30:24,353 --> 00:30:27,013
as long as you remember what it is.

605
00:30:27,013 --> 00:30:30,574
It will respond with
another one of these GUIDs.

606
00:30:30,574 --> 00:30:32,994
You don't need to
remember that GUID at all,

607
00:30:32,994 --> 00:30:35,161
because if we do a docker network ls,

608
00:30:35,161 --> 00:30:39,328
you can now see you have your
network appearing in the list.

609
00:30:40,271 --> 00:30:43,319
Notice that on the driver column,

610
00:30:43,319 --> 00:30:45,353
exactly as the default network,

611
00:30:45,353 --> 00:30:48,803
you will be seeing a
driver name of bridge.

612
00:30:48,803 --> 00:30:50,854
More information about that later.

613
00:30:50,854 --> 00:30:53,168
For now, you've got a network.

614
00:30:53,168 --> 00:30:58,015
And so I'm going to go back
to the command that I ran

615
00:30:58,015 --> 00:31:01,313
to start the database container.

616
00:31:01,313 --> 00:31:05,286
So we're passing in the
two environment variables,

617
00:31:05,286 --> 00:31:07,666
and we're running in detached mode.

618
00:31:07,666 --> 00:31:10,457
But what we can do now is
we can tell this container

619
00:31:10,457 --> 00:31:14,624
that it needs to be attached
to the network we just created.

620
00:31:15,847 --> 00:31:19,180
Very straightforward, dash dash network.

621
00:31:20,201 --> 00:31:22,487
By the way, there's no
short command for this.

622
00:31:22,487 --> 00:31:24,544
You can't just do dash n.

623
00:31:24,544 --> 00:31:27,007
You do need the full dash dash network,

624
00:31:27,007 --> 00:31:31,090
followed by the name of
your network, my-network.

625
00:31:32,558 --> 00:31:35,628
Now, before we run this, as you've seen,

626
00:31:35,628 --> 00:31:38,243
all of this works on the container names,

627
00:31:38,243 --> 00:31:39,941
and we don't want to be having these

628
00:31:39,941 --> 00:31:43,486
automatically generated
container names any more.

629
00:31:43,486 --> 00:31:47,775
So it's also very easy on
the command line to specify

630
00:31:47,775 --> 00:31:50,525
with dash dash name the name that

631
00:31:51,374 --> 00:31:53,801
you want to apply to this container.

632
00:31:53,801 --> 00:31:55,941
And this name is so important
because it's going to become

633
00:31:55,941 --> 00:31:59,301
the name by which all
of the other containers

634
00:31:59,301 --> 00:32:02,994
are able to find this
container over the network.

635
00:32:02,994 --> 00:32:04,370
So we need a good name here.

636
00:32:04,370 --> 00:32:07,037
I suggest just database will do.

637
00:32:09,093 --> 00:32:10,666
So it's become quite a long command, this,

638
00:32:10,666 --> 00:32:12,663
so I'll just move across to the right

639
00:32:12,663 --> 00:32:14,702
so you can see the whole command.

640
00:32:14,702 --> 00:32:16,770
The important things are
we're going to attach

641
00:32:16,770 --> 00:32:21,294
to our private network, and
we're going to give it the name

642
00:32:21,294 --> 00:32:24,674
of database, and that's going
to be the container name,

643
00:32:24,674 --> 00:32:27,891
but it's also going to be the DNS name

644
00:32:27,891 --> 00:32:32,676
by which other containers
can look up this instance.

645
00:32:32,676 --> 00:32:34,414
Let's give that a try.

646
00:32:34,414 --> 00:32:37,375
Okay, well, I have a new container.

647
00:32:37,375 --> 00:32:39,033
Now we need to do the same process

648
00:32:39,033 --> 00:32:43,200
for the web application as
well, so I'll go backwards.

649
00:32:44,841 --> 00:32:46,993
Here it was, docker container run,

650
00:32:46,993 --> 00:32:49,807
I'm running detached,
I'm publishing ports,

651
00:32:49,807 --> 00:32:51,927
and that's the name of my image.

652
00:32:51,927 --> 00:32:54,354
So I need some further commands in here.

653
00:32:54,354 --> 00:32:58,521
Dash dash network is going to
be, again, my dash network,

654
00:33:00,388 --> 00:33:03,316
and again, it would be useful
if we gave this a name.

655
00:33:03,316 --> 00:33:07,020
So dash dash name, and from
this point onwards on the course

656
00:33:07,020 --> 00:33:08,906
I'm going to be consistent.

657
00:33:08,906 --> 00:33:11,345
Whatever the name of the service is,

658
00:33:11,345 --> 00:33:13,843
I'm also going to name
the container after it.

659
00:33:13,843 --> 00:33:16,926
So this will be fleetman dash webapp.

660
00:33:18,448 --> 00:33:20,589
Okay, and that appears to be running.

661
00:33:20,589 --> 00:33:23,920
If I now go to the command
line of this webapp container,

662
00:33:23,920 --> 00:33:28,376
I should have network visibility
of the database container.

663
00:33:28,376 --> 00:33:30,080
Let's try that.

664
00:33:30,080 --> 00:33:30,980
You know how to do this.

665
00:33:30,980 --> 00:33:35,548
I want to get onto the command
line of the webapp container,

666
00:33:35,548 --> 00:33:39,548
so this will be a docker
container exec dash it,

667
00:33:40,604 --> 00:33:42,289
and now for the first time,

668
00:33:42,289 --> 00:33:44,966
instead of using the ID of the container,

669
00:33:44,966 --> 00:33:46,926
I can use the name of the container.

670
00:33:46,926 --> 00:33:50,238
And that's true wherever
we've been using the IDs,

671
00:33:50,238 --> 00:33:52,451
we can also use the names.

672
00:33:52,451 --> 00:33:56,391
So I can connect to fleetman dash webapp.

673
00:33:56,391 --> 00:33:59,033
And remember, there's no
Bash shell on this container,

674
00:33:59,033 --> 00:34:01,366
so you will need to do a sh.

675
00:34:02,968 --> 00:34:04,914
So here I am on the command line,

676
00:34:04,914 --> 00:34:08,664
and I can do a ping of
google.com, as before.

677
00:34:09,507 --> 00:34:10,955
That's working.

678
00:34:10,955 --> 00:34:13,491
But now the real big deal
is I should be able to

679
00:34:13,491 --> 00:34:15,741
do a ping of just database.

680
00:34:18,534 --> 00:34:21,480
And I hope you're seeing a similar result.

681
00:34:21,480 --> 00:34:24,215
Because Docker is automatically managing

682
00:34:24,215 --> 00:34:27,125
a domain name server, in this instance,

683
00:34:27,125 --> 00:34:29,055
when we issue the ping command,

684
00:34:29,055 --> 00:34:31,784
it's consulting the domain name server

685
00:34:31,784 --> 00:34:33,916
and it's discovering that the IP address

686
00:34:33,916 --> 00:34:36,428
of the target container, for me,

687
00:34:36,428 --> 00:34:39,428
happens to be this here, 172.18.0.2.

688
00:34:42,621 --> 00:34:46,314
And I can assure you that
this address beginning 172

689
00:34:46,314 --> 00:34:49,380
is an IP address from the private range,

690
00:34:49,380 --> 00:34:53,342
so this is not a publicly
available IP address.

691
00:34:53,342 --> 00:34:57,092
Nobody can get access
to this database except

692
00:34:58,408 --> 00:35:01,298
for the containers that are connected

693
00:35:01,298 --> 00:35:03,652
to this private network.

694
00:35:03,652 --> 00:35:04,962
I'll do a Control C there,

695
00:35:04,962 --> 00:35:07,136
we've proved the principle of networking.

696
00:35:07,136 --> 00:35:09,516
It's now time to update our code

697
00:35:09,516 --> 00:35:13,616
so that we really are
using this MySQL database.

698
00:35:13,616 --> 00:35:15,404
So back into the code
for this project, then,

699
00:35:15,404 --> 00:35:17,933
under Source Main Resources,

700
00:35:17,933 --> 00:35:22,196
we have a profile application-docker-demo.

701
00:35:22,196 --> 00:35:25,622
This is the profile that is
being used by the container.

702
00:35:25,622 --> 00:35:28,535
So this is pure Spring Boot territory now.

703
00:35:28,535 --> 00:35:31,876
We're currently on line
eight, pointing it to

704
00:35:31,876 --> 00:35:34,543
a local self-contained database.

705
00:35:35,595 --> 00:35:37,958
I'd like to upgrade this now to reference

706
00:35:37,958 --> 00:35:40,783
our new MySQL container.

707
00:35:40,783 --> 00:35:43,537
So this is going to be a simple case of

708
00:35:43,537 --> 00:35:47,287
for our URL, the URL
will be jdbc colon mysql

709
00:35:49,215 --> 00:35:53,506
colon forward slash
forward slash, and now for

710
00:35:53,506 --> 00:35:57,673
the IP address of the container
containing our database.

711
00:35:58,967 --> 00:36:00,879
We know now it's not the IP address,

712
00:36:00,879 --> 00:36:04,395
it's simply the name of the container,

713
00:36:04,395 --> 00:36:08,562
and the DNS service will
automatically find that IP address.

714
00:36:09,489 --> 00:36:13,003
We can do a colon 3306 here if you want,

715
00:36:13,003 --> 00:36:15,076
I think that's the default anyway.

716
00:36:15,076 --> 00:36:16,701
And then a forward slash,

717
00:36:16,701 --> 00:36:19,778
and then the name of the
schema inside the database.

718
00:36:19,778 --> 00:36:21,803
We created that a short while ago,

719
00:36:21,803 --> 00:36:24,847
that's going to be fleetman.

720
00:36:24,847 --> 00:36:28,711
We also need to specify
which spring dot datasource

721
00:36:28,711 --> 00:36:32,378
dot username, I haven't
configured any users

722
00:36:33,333 --> 00:36:36,330
on this database so
that's going to be root,

723
00:36:36,330 --> 00:36:39,997
and then spring dot
datasource dot password,

724
00:36:41,206 --> 00:36:44,373
my very insecure password of password.

725
00:36:46,522 --> 00:36:49,413
Bear in mind that this database container

726
00:36:49,413 --> 00:36:51,894
is not exposed to the outside world,

727
00:36:51,894 --> 00:36:55,831
so although this looks
completely insecure,

728
00:36:55,831 --> 00:36:58,142
well, nobody can connect
to this database anyway,

729
00:36:58,142 --> 00:37:00,968
so it's not as bad as it looks.

730
00:37:00,968 --> 00:37:04,161
I probably still would have a
much better password than that

731
00:37:04,161 --> 00:37:05,244
in real life.

732
00:37:06,993 --> 00:37:08,937
So we changed the code, I
will need to remember to

733
00:37:08,937 --> 00:37:10,687
rebuild the JAR file.

734
00:37:14,091 --> 00:37:16,965
So we'll run Maven and
then the package goal.

735
00:37:16,965 --> 00:37:19,377
Coming up, full details on how to

736
00:37:19,377 --> 00:37:22,419
integrate Docker with Maven.

737
00:37:22,419 --> 00:37:24,224
Okay, that worked.

738
00:37:24,224 --> 00:37:25,255
I'm back to the command line.

739
00:37:25,255 --> 00:37:28,799
I will need to exit the
container that I was in before.

740
00:37:28,799 --> 00:37:32,667
Just to remind ourselves where we are,

741
00:37:32,667 --> 00:37:34,405
we've got two containers running,

742
00:37:34,405 --> 00:37:37,315
we've got the database and the webapp.

743
00:37:37,315 --> 00:37:40,053
Well, we need to take the
webapp out of service,

744
00:37:40,053 --> 00:37:43,636
so I'm going to do a
docker container stop,

745
00:37:44,531 --> 00:37:48,698
don't need the ID this
time, fleetman dash webapp.

746
00:37:49,996 --> 00:37:51,579
Okay, that stopped.

747
00:37:52,640 --> 00:37:54,973
And we'll rebuild the image.

748
00:38:02,690 --> 00:38:06,546
This step won't be necessary
once we've upgraded Maven.

749
00:38:06,546 --> 00:38:09,344
One thing I just want to
bring your attention to is

750
00:38:09,344 --> 00:38:12,214
when you're rebuilding
an image, as you know,

751
00:38:12,214 --> 00:38:15,214
any step that has already been done,

752
00:38:16,368 --> 00:38:18,225
it will use the cache.

753
00:38:18,225 --> 00:38:21,465
But it is a common mistake to maybe forget

754
00:38:21,465 --> 00:38:25,264
to rebuild the JAR file, in which case,

755
00:38:25,264 --> 00:38:27,248
it will have just run through all the way

756
00:38:27,248 --> 00:38:31,319
and every step would've been using cache.

757
00:38:31,319 --> 00:38:34,037
And I just like to remind
myself that you want to see

758
00:38:34,037 --> 00:38:37,748
at least one of these steps,
and it is, in this case,

759
00:38:37,748 --> 00:38:42,016
step five of six, where it's
not using the cache any more,

760
00:38:42,016 --> 00:38:44,838
it is removing an intermediate container.

761
00:38:44,838 --> 00:38:47,011
It's worth looking out
for that just in case

762
00:38:47,011 --> 00:38:49,561
you forgot to do a step.

763
00:38:49,561 --> 00:38:53,459
But we do now have a fresh image, so.

764
00:38:53,459 --> 00:38:57,144
I'm going to just recall
the previous command,

765
00:38:57,144 --> 00:39:00,467
where we were running the
Fleetman webapp container.

766
00:39:00,467 --> 00:39:02,721
Now we're gonna have
a little problem here,

767
00:39:02,721 --> 00:39:04,868
a very small problem.

768
00:39:04,868 --> 00:39:07,510
Yeah, we have an error, and
the error is simply because

769
00:39:07,510 --> 00:39:09,683
we're now using names.

770
00:39:09,683 --> 00:39:12,350
And we can only use a name once.

771
00:39:13,369 --> 00:39:16,619
Now, although, if we do a container ls,

772
00:39:18,053 --> 00:39:20,259
and I'll move across to the right.

773
00:39:20,259 --> 00:39:23,005
Yeah, we've only got one
container with the name database,

774
00:39:23,005 --> 00:39:25,088
but if I do an ls dash a,

775
00:39:26,340 --> 00:39:28,752
well, I've got a lot
of previous containers,

776
00:39:28,752 --> 00:39:31,985
but of course, I only
stopped that container.

777
00:39:31,985 --> 00:39:36,194
It's this container at
the top, beginning a4.

778
00:39:36,194 --> 00:39:40,159
If I move across to the right,
it's still holding that name

779
00:39:40,159 --> 00:39:44,326
fleetman dash webapp, even
though the container is stopped.

780
00:39:45,170 --> 00:39:47,125
Which makes sense if you think about it.

781
00:39:47,125 --> 00:39:50,065
So that might seem really awkward,

782
00:39:50,065 --> 00:39:53,565
that we've also got to remember to remove,

783
00:39:54,940 --> 00:39:58,488
using the rm command, that container.

784
00:39:58,488 --> 00:40:01,830
Now in this case it's the
container beginning a4.

785
00:40:01,830 --> 00:40:05,080
If I use the name fleetman dash webapp,

786
00:40:06,045 --> 00:40:08,974
then yeah, that works fine.

787
00:40:08,974 --> 00:40:11,814
So it's not enough to stop the container,

788
00:40:11,814 --> 00:40:14,202
we also have to remove the container.

789
00:40:14,202 --> 00:40:15,918
If that feels tedious to you,

790
00:40:15,918 --> 00:40:18,217
then I can show you a little workaround.

791
00:40:18,217 --> 00:40:19,778
Let's recall the command where

792
00:40:19,778 --> 00:40:22,615
we're going to run the container.

793
00:40:22,615 --> 00:40:25,960
Now, if you add in an
additional command line here,

794
00:40:25,960 --> 00:40:29,793
dash dash rm, so there's
the complete command.

795
00:40:31,823 --> 00:40:34,696
This is saying that when
this container stops

796
00:40:34,696 --> 00:40:38,863
it should also be removed,
which is really useful.

797
00:40:40,513 --> 00:40:42,846
So let's run that container,

798
00:40:44,293 --> 00:40:46,827
and importantly we're gonna
want to pretty quickly

799
00:40:46,827 --> 00:40:50,827
do docker container logs
dash f fleetman-webapp,

800
00:40:52,362 --> 00:40:56,529
and let's see if it's connecting
to our MySQL database.

801
00:40:58,753 --> 00:41:03,276
And what you're looking here
for is any big exceptions

802
00:41:03,276 --> 00:41:07,443
related to MySQL, but it
certainly ran through okay for me.

803
00:41:08,460 --> 00:41:10,630
It started in about 20 seconds.

804
00:41:10,630 --> 00:41:12,215
And if I go a little further up,

805
00:41:12,215 --> 00:41:16,382
I did notice it was saying
table not found for vehicle.

806
00:41:17,607 --> 00:41:21,137
And it does automatically
create these tables,

807
00:41:21,137 --> 00:41:23,209
and it's creating some records,

808
00:41:23,209 --> 00:41:26,369
so that's actually looking pretty good.

809
00:41:26,369 --> 00:41:30,624
But how do we know that it's
actually doing that with MySQL?

810
00:41:30,624 --> 00:41:32,882
Well, I'll do a Control
C there on the log,

811
00:41:32,882 --> 00:41:34,535
and there's lots of ways we could do this.

812
00:41:34,535 --> 00:41:39,331
We could exec a Bash shell
onto the MySQL container.

813
00:41:39,331 --> 00:41:41,095
So I could do that, but
I think I'm going to

814
00:41:41,095 --> 00:41:44,192
create a third container, and
I'll attach that container

815
00:41:44,192 --> 00:41:47,140
to the same network as
the other two containers,

816
00:41:47,140 --> 00:41:51,307
and then we can run a MySQL
client on that new container.

817
00:41:53,317 --> 00:41:55,475
So it's a slightly
long-winded way of doing it,

818
00:41:55,475 --> 00:41:58,093
but it will just give us
some chance to practise.

819
00:41:58,093 --> 00:42:00,731
So we'll do a docker container run,

820
00:42:00,731 --> 00:42:03,822
and I'm going to run the Alpine container.

821
00:42:03,822 --> 00:42:06,528
And I need to do this interactively,

822
00:42:06,528 --> 00:42:08,445
so I'll need a dash it.

823
00:42:09,350 --> 00:42:12,605
And of course I need to
connect it to our new network.

824
00:42:12,605 --> 00:42:15,688
So dash dash network my dash network.

825
00:42:19,905 --> 00:42:22,667
That should be enough, that's good.

826
00:42:22,667 --> 00:42:25,742
I now have a new container
just running Alpine,

827
00:42:25,742 --> 00:42:28,078
nothing specially installed on it.

828
00:42:28,078 --> 00:42:29,541
The first test I would want to do is

829
00:42:29,541 --> 00:42:33,908
I should be able to do a ping
of the database container,

830
00:42:33,908 --> 00:42:34,741
and I can.

831
00:42:37,012 --> 00:42:41,095
I should also be able to
do a ping of the webapp,

832
00:42:42,054 --> 00:42:44,721
fleetman dash webapp, and I can.

833
00:42:45,577 --> 00:42:47,228
So we can see those containers.

834
00:42:47,228 --> 00:42:49,608
By the way, the reason
that I went for Alpine

835
00:42:49,608 --> 00:42:52,338
rather than Ubuntu is that Alpine

836
00:42:52,338 --> 00:42:56,171
has ping installed by
default, Ubuntu doesn't.

837
00:42:57,416 --> 00:43:00,465
And frankly, I can never
remember the name of the package

838
00:43:00,465 --> 00:43:02,462
that has ping.

839
00:43:02,462 --> 00:43:04,655
However, we still have the
problem that I would like

840
00:43:04,655 --> 00:43:07,880
to connect to the database
on the command line.

841
00:43:07,880 --> 00:43:12,567
I think we're almost certain
to find, if we just do MySQL,

842
00:43:12,567 --> 00:43:15,193
of course that command's
not going to be found.

843
00:43:15,193 --> 00:43:18,546
Alpine is a very basic installation.

844
00:43:18,546 --> 00:43:20,190
Now, when you're working in Docker,

845
00:43:20,190 --> 00:43:22,175
you are gonna find that you
have to work with containers

846
00:43:22,175 --> 00:43:24,518
that use different distributions,

847
00:43:24,518 --> 00:43:26,687
and every distribution has its own

848
00:43:26,687 --> 00:43:30,249
preferred package management system.

849
00:43:30,249 --> 00:43:33,196
And so it would be worth
acquiring the knowledge

850
00:43:33,196 --> 00:43:36,486
of how as many different
package management systems

851
00:43:36,486 --> 00:43:38,148
work as possible.

852
00:43:38,148 --> 00:43:41,612
It turns out that the package
manager used by Alpine

853
00:43:41,612 --> 00:43:45,890
is called APK, and of
course you could find this

854
00:43:45,890 --> 00:43:49,057
by Googling, but if you do an apk add,

855
00:43:51,701 --> 00:43:54,701
followed by dash dash no dash cache,

856
00:43:57,242 --> 00:43:59,368
and then the name of the
package we're installing

857
00:43:59,368 --> 00:44:01,118
is mysql dash client.

858
00:44:02,630 --> 00:44:06,291
Now, I keep a little crib
sheet of the main commands

859
00:44:06,291 --> 00:44:10,339
for the main package
management systems like apt-get

860
00:44:10,339 --> 00:44:12,506
and YUM and APK and so on.

861
00:44:15,177 --> 00:44:17,339
Obviously, installing packages
like this is not something

862
00:44:17,339 --> 00:44:20,651
that we do with production systems.

863
00:44:20,651 --> 00:44:23,031
This is just something
to do when you're testing

864
00:44:23,031 --> 00:44:24,683
or when you're trying things out

865
00:44:24,683 --> 00:44:26,387
and you're doing diagnostics.

866
00:44:26,387 --> 00:44:28,549
Of course, normally, this kind
of thing you would be doing

867
00:44:28,549 --> 00:44:30,430
in a Docker file.

868
00:44:30,430 --> 00:44:32,955
But it's okay for this quick test,

869
00:44:32,955 --> 00:44:35,705
so yeah, that's installing MySQL.

870
00:44:37,003 --> 00:44:40,152
So I should now be able to run MySQL,

871
00:44:40,152 --> 00:44:42,743
and I can, even though
we have an error there,

872
00:44:42,743 --> 00:44:45,419
that's proving that it is installed.

873
00:44:45,419 --> 00:44:48,900
So we just need the paramaters,
dash u for the username,

874
00:44:48,900 --> 00:44:52,150
root, dash p for the password password,

875
00:44:53,551 --> 00:44:57,915
we need dash h for the
host, this would normally be

876
00:44:57,915 --> 00:45:00,187
the IP address of the
host, but we know now

877
00:45:00,187 --> 00:45:02,437
we can simply say database.

878
00:45:04,519 --> 00:45:06,797
And that should be enough.

879
00:45:06,797 --> 00:45:09,414
Great, we're now on
the MySQL command line.

880
00:45:09,414 --> 00:45:11,497
We can do show databases,

881
00:45:13,502 --> 00:45:15,508
they're really called schemas in MySQL,

882
00:45:15,508 --> 00:45:18,898
but we can now switch
to the Fleetman schema.

883
00:45:18,898 --> 00:45:22,148
And we can do a show tables, fantastic.

884
00:45:23,921 --> 00:45:25,504
We can see a table.

885
00:45:26,891 --> 00:45:29,891
Let's do a select star from vehicle.

886
00:45:33,101 --> 00:45:36,315
And yeah, that proves that we
do have some data recorded.

887
00:45:36,315 --> 00:45:38,333
By the way, we have nulls in here for the

888
00:45:38,333 --> 00:45:41,329
last recorded position, because
the coding of the system

889
00:45:41,329 --> 00:45:43,866
is just that it only stores this data

890
00:45:43,866 --> 00:45:46,033
when it actually needs to.

891
00:45:47,230 --> 00:45:48,764
And it hasn't needed to, I think,

892
00:45:48,764 --> 00:45:51,847
just because I haven't
refreshed the web page.

893
00:45:51,847 --> 00:45:54,735
So if we go to our browser
and visit local host,

894
00:45:54,735 --> 00:45:58,902
now the system's updating, so
check out the timestamps here.

895
00:46:00,167 --> 00:46:04,575
Monday the seventh of August,
something around 16:54.

896
00:46:04,575 --> 00:46:07,191
Switch back, and I'll repeat that select,

897
00:46:07,191 --> 00:46:09,434
and yeah, we can now see
that there is definitely

898
00:46:09,434 --> 00:46:12,351
live data going into that database.

899
00:46:13,892 --> 00:46:16,450
So I know this has been
quite a long chapter,

900
00:46:16,450 --> 00:46:18,971
and I have been talking quite a lot,

901
00:46:18,971 --> 00:46:20,952
but the key information
here is that we can

902
00:46:20,952 --> 00:46:23,514
very easily create our
own private networks

903
00:46:23,514 --> 00:46:26,866
and any container that's on that network

904
00:46:26,866 --> 00:46:30,178
can very easily see each other,

905
00:46:30,178 --> 00:46:33,799
just by using the name of that container.

906
00:46:33,799 --> 00:46:36,368
One last piece of information
before I close this chapter

907
00:46:36,368 --> 00:46:39,978
is that it's absolutely fine
to have multiple networks

908
00:46:39,978 --> 00:46:43,448
in your system, so here
I've created a Network One

909
00:46:43,448 --> 00:46:47,318
and a Network Two, and when
you start your containers,

910
00:46:47,318 --> 00:46:50,761
you can choose which networks
they're connected to.

911
00:46:50,761 --> 00:46:54,926
So perhaps our database here
is connected to Network One.

912
00:46:54,926 --> 00:46:56,739
I have a container here which,

913
00:46:56,739 --> 00:46:58,531
I don't know if you can see that icon,

914
00:46:58,531 --> 00:47:02,139
it's supposed to
represent Apache ActiveMQ.

915
00:47:02,139 --> 00:47:04,150
We'll be using that
later on in the course,

916
00:47:04,150 --> 00:47:06,760
it's a message broker.

917
00:47:06,760 --> 00:47:09,130
I've connected that to Network Two.

918
00:47:09,130 --> 00:47:13,825
So that means that the MySQL
and Apache ActiveMQ containers

919
00:47:13,825 --> 00:47:15,697
can't see each other.

920
00:47:15,697 --> 00:47:18,160
They simply wouldn't be able to network.

921
00:47:18,160 --> 00:47:22,345
But this container here, which
appears to contain a webapp,

922
00:47:22,345 --> 00:47:26,549
I've decided to connect to both networks.

923
00:47:26,549 --> 00:47:31,218
So that would be able to talk
to both of the containers.

924
00:47:31,218 --> 00:47:33,708
So I hope you can see
that what we have here

925
00:47:33,708 --> 00:47:37,708
is effectively a virtual
private network system,

926
00:47:38,978 --> 00:47:40,110
and I should also go on to say that

927
00:47:40,110 --> 00:47:42,443
anything outside of our Docker system

928
00:47:42,443 --> 00:47:46,275
would not be able to see
any of these containers

929
00:47:46,275 --> 00:47:48,442
unless we published ports.

930
00:47:50,302 --> 00:47:52,683
So in this example, it's probably the case

931
00:47:52,683 --> 00:47:56,154
that we would publish
the ports on the webapp,

932
00:47:56,154 --> 00:47:58,818
we would expose port 8080,

933
00:47:58,818 --> 00:48:01,854
we might map it to another port like 80,

934
00:48:01,854 --> 00:48:05,956
and then it would be visible
to the outside world.

935
00:48:05,956 --> 00:48:10,123
But these containers are going
to remain completely private.

936
00:48:11,530 --> 00:48:16,486
So with relatively little
work and a bit of thought,

937
00:48:16,486 --> 00:48:20,154
we can achieve a secure
system where containers

938
00:48:20,154 --> 00:48:22,628
can freely talk to each other.

939
00:48:22,628 --> 00:48:24,384
And we'll be doing a
lot more with networking

940
00:48:24,384 --> 00:48:25,770
as we go through the course,

941
00:48:25,770 --> 00:48:27,878
but I hope that's a good
start on networking.

942
00:48:27,878 --> 00:48:30,599
In the next chapter, a
very much quicker chapter,

943
00:48:30,599 --> 00:48:33,683
definitely a less important topic,

944
00:48:33,683 --> 00:48:35,827
but it might still be useful for you,

945
00:48:35,827 --> 00:48:37,424
and that's called Docker Volumes.

946
00:48:37,424 --> 00:48:41,591
So have a good break, and I
will see you for that chapter.

947
00:48:49,016 --> 00:48:50,537
Yeah, that chapter was too long.

948
00:48:50,537 --> 00:48:53,892
Many apologies for that, but I
can't bear to leave it there.

949
00:48:53,892 --> 00:48:56,780
There was a big question
that I left unanswered

950
00:48:56,780 --> 00:48:58,670
in the middle of that chapter.

951
00:48:58,670 --> 00:49:01,493
We saw that Steve Wozniak is
one of the candidate names

952
00:49:01,493 --> 00:49:04,920
for automatic generation
of container names.

953
00:49:04,920 --> 00:49:07,503
Is Steve Jobs in there as well?

954
00:49:09,070 --> 00:49:11,256
I've had a little bit of a poke around,

955
00:49:11,256 --> 00:49:14,151
and the routine that's used
for generating the names

956
00:49:14,151 --> 00:49:17,902
you can find on the GitHub
repository you can see here.

957
00:49:17,902 --> 00:49:21,640
It's actually part of the
organisation called Moby.

958
00:49:21,640 --> 00:49:24,459
They contribute to the Docker project.

959
00:49:24,459 --> 00:49:29,233
And it happens to be written
in the Go programming language.

960
00:49:29,233 --> 00:49:30,721
Doesn't matter if you know Go or not,

961
00:49:30,721 --> 00:49:33,271
because it's very
readable and very simple.

962
00:49:33,271 --> 00:49:36,840
We have an array, adjectives here.

963
00:49:36,840 --> 00:49:40,774
Notice that not all of the
adjectives are positive ones.

964
00:49:40,774 --> 00:49:44,107
We've got angry and agitated and cranky.

965
00:49:46,489 --> 00:49:49,129
But also boring, as well.

966
00:49:49,129 --> 00:49:53,614
But a lot of them are positive,
like elegant and eloquent,

967
00:49:53,614 --> 00:49:55,047
and friendly.

968
00:49:55,047 --> 00:49:57,184
So there are the adjectives,

969
00:49:57,184 --> 00:50:01,351
and so yes, there are notable
scientists and hackers,

970
00:50:02,659 --> 00:50:05,605
and very nicely, for each of them,

971
00:50:05,605 --> 00:50:08,207
there is a comment saying who they are.

972
00:50:08,207 --> 00:50:12,745
So earlier in the video we
had Cori generated for us,

973
00:50:12,745 --> 00:50:16,715
and that was Gerty Theresa
Cori, an American biochemist.

974
00:50:16,715 --> 00:50:19,278
Well, I had no idea that was the case,

975
00:50:19,278 --> 00:50:21,957
so I've learnt something on this video.

976
00:50:21,957 --> 00:50:25,012
So plenty of notables on the list.

977
00:50:25,012 --> 00:50:29,486
We also saw the great
Steve Wozniak, of course.

978
00:50:29,486 --> 00:50:33,653
But the question is, going
up, do we have Steve Jobs?

979
00:50:36,618 --> 00:50:37,819
And we don't.

980
00:50:37,819 --> 00:50:40,802
Well, we don't at the
time of recording, anyway.

981
00:50:40,802 --> 00:50:43,641
Controversial, I like that.

982
00:50:43,641 --> 00:50:45,696
But what I like best
of all about this code,

983
00:50:45,696 --> 00:50:49,186
and you think of the, out
of all those possibilities,

984
00:50:49,186 --> 00:50:52,241
there is just one, I love this.

985
00:50:52,241 --> 00:50:54,588
Right down at the bottom.

986
00:50:54,588 --> 00:50:59,483
If the combination of
boring and Wozniak comes up,

987
00:50:59,483 --> 00:51:03,078
then that one is going to be disallowed.

988
00:51:03,078 --> 00:51:05,935
So Steve Wozniak's not boring, but I am.

989
00:51:05,935 --> 00:51:07,548
I've gone on far too long.

990
00:51:07,548 --> 00:51:09,094
I'll see you in the next chapter.

1
00:00:00,228 --> 00:00:02,424
- [Narrator] It's going to be
quite a short chapter this one

2
00:00:02,424 --> 00:00:07,076
we're going to look at Docker
volumes and mount points.

3
00:00:07,076 --> 00:00:10,847
Up until now we've been treating
a container as a disposable

4
00:00:10,847 --> 00:00:15,481
entity, we start up a container,
we do some things with it

5
00:00:15,481 --> 00:00:18,567
and then when we're
finished, we dispose of it.

6
00:00:18,567 --> 00:00:21,456
And we've been assuming so
far that all of the data

7
00:00:21,456 --> 00:00:25,123
in that container, well
it's just been lost.

8
00:00:26,433 --> 00:00:29,452
Now I think this way of
thinking is a good thing,

9
00:00:29,452 --> 00:00:34,127
it's one of the reasons for
using Docker, we often want our

10
00:00:34,127 --> 00:00:38,294
containers to be, self contained,
and we want to be able to

11
00:00:40,733 --> 00:00:44,900
easily discard containers,
and restart a new instance

12
00:00:46,194 --> 00:00:51,043
of an image without worrying
about what went before it.

13
00:00:51,043 --> 00:00:55,981
But there are some circumstances
where we do want some data

14
00:00:55,981 --> 00:01:00,906
to persist, in other words
we want some data to outlive

15
00:01:00,906 --> 00:01:04,642
their containers, we
want it to live longer

16
00:01:04,642 --> 00:01:09,321
than the container, and we
might want to reuse that data

17
00:01:09,321 --> 00:01:13,002
across different container instances.

18
00:01:13,002 --> 00:01:15,745
Well the classic example of this of course

19
00:01:15,745 --> 00:01:19,649
is if we're running a database
inside of a container.

20
00:01:19,649 --> 00:01:23,051
In the previous chapter we ran a database,

21
00:01:23,051 --> 00:01:25,804
and I don't know what state
your Docker environment is in,

22
00:01:25,804 --> 00:01:28,108
in fact I'm in a fresh
recording session here,

23
00:01:28,108 --> 00:01:30,858
so if I do a Docker container ls,

24
00:01:32,716 --> 00:01:36,648
I personally have no running
containers, if I do a Docker

25
00:01:36,648 --> 00:01:39,834
container ls dash a
there is a stop container

26
00:01:39,834 --> 00:01:42,793
that I was experimenting with off camera.

27
00:01:42,793 --> 00:01:45,115
Just to keep things clean, and
you might want to do the same

28
00:01:45,115 --> 00:01:49,083
I'll do a Docker container
prune, and that will,

29
00:01:49,083 --> 00:01:52,456
as the warning suggests
here, that's going to remove

30
00:01:52,456 --> 00:01:54,826
any stopped containers.

31
00:01:54,826 --> 00:01:56,776
And you don't necessarily need to do that

32
00:01:56,776 --> 00:01:59,548
but it's good to start from a clean point.

33
00:01:59,548 --> 00:02:01,284
Now in the previous
chapter we were running

34
00:02:01,284 --> 00:02:05,019
a database container,
and we were doing that

35
00:02:05,019 --> 00:02:08,352
with something like Docker container run

36
00:02:10,230 --> 00:02:12,092
and we were in the previous
chapter connecting it to

37
00:02:12,092 --> 00:02:15,583
a network, for this demonstration
we're not going to run

38
00:02:15,583 --> 00:02:17,302
multiple containers so I won't need

39
00:02:17,302 --> 00:02:18,994
to bother with the network.

40
00:02:18,994 --> 00:02:21,135
Now the tricky thing about
running the MYSQL container

41
00:02:21,135 --> 00:02:25,912
was we need to supply
environment variables, so dash e,

42
00:02:25,912 --> 00:02:28,662
and that was MYSQL_ROOT_PASSWORD,

43
00:02:30,287 --> 00:02:33,064
we were just setting to password.

44
00:02:33,064 --> 00:02:35,189
We were specifying a database with

45
00:02:35,189 --> 00:02:38,106
dash e MYSQL_DATABASE=fleetman

46
00:02:43,453 --> 00:02:46,786
and the image we were running was mysql.

47
00:02:47,634 --> 00:02:51,859
And it would help if I
could spell mysql correctly.

48
00:02:51,859 --> 00:02:54,190
Lets try that again.

49
00:02:54,190 --> 00:02:58,011
Okay, and I forgot to put
in the dash d option there

50
00:02:58,011 --> 00:03:00,871
to run this in the
background, so I can do a

51
00:03:00,871 --> 00:03:03,558
control c there, but as you know

52
00:03:03,558 --> 00:03:05,579
that's just going to stop the log.

53
00:03:05,579 --> 00:03:07,910
If I do a Docker container ls

54
00:03:07,910 --> 00:03:12,149
there's my new container
successfully up and running.

55
00:03:12,149 --> 00:03:14,479
Now for this demonstration I'm
just going to put some data

56
00:03:14,479 --> 00:03:16,737
into that database and
I guess the quickest way

57
00:03:16,737 --> 00:03:20,280
of doing that would be to
do Docker container exec

58
00:03:20,280 --> 00:03:23,732
and we'll run a bash shell
inside that container.

59
00:03:23,732 --> 00:03:27,899
So the usual dash it followed
by the id of the container,

60
00:03:28,803 --> 00:03:32,970
for me begins 3d and we're
running the bash command.

61
00:03:33,933 --> 00:03:38,108
And so we can run a mysql
client inside that container.

62
00:03:38,108 --> 00:03:42,275
We just need the password
dash p password and we're in

63
00:03:43,750 --> 00:03:48,420
we can do a show databases
and we have our fleetman

64
00:03:48,420 --> 00:03:52,587
database there, so we can
use fleetman and just to put

65
00:03:54,441 --> 00:03:56,798
some dummy data into this database,

66
00:03:56,798 --> 00:04:00,215
I'm going to do a quick create table temp

67
00:04:01,763 --> 00:04:03,601
and we'll put a single column in.

68
00:04:03,601 --> 00:04:05,867
I think you need one column in a table

69
00:04:05,867 --> 00:04:10,034
so I'll call the column temp
and I'll make that a varchar255

70
00:04:13,571 --> 00:04:15,784
really doesn't matter what we
put in there, but the point

71
00:04:15,784 --> 00:04:19,042
of doing that is I can
now do a show tables

72
00:04:19,042 --> 00:04:22,900
and there is some data in my database.

73
00:04:22,900 --> 00:04:25,567
Now if we exit that mysql client

74
00:04:26,562 --> 00:04:29,596
and then exit the container itself,

75
00:04:29,596 --> 00:04:32,881
the point of this demonstration now.

76
00:04:32,881 --> 00:04:37,048
Docker container ls, if I
now stop that container,

77
00:04:38,828 --> 00:04:41,806
plus I need the id of the
container I'm stopping.

78
00:04:41,806 --> 00:04:44,556
Docker container stop, for me, 3d

79
00:04:45,421 --> 00:04:49,588
and I'll even go so far as
to remove that container.

80
00:04:50,469 --> 00:04:53,572
I think you can probably
guess now, that if we go back

81
00:04:53,572 --> 00:04:57,739
and recall the command we
used to run that container,

82
00:04:59,027 --> 00:05:02,382
absolutely identical although
I wish I'd added a d,

83
00:05:02,382 --> 00:05:05,382
dash d option onto it but nevermind.

84
00:05:06,767 --> 00:05:08,918
It looks like it's up and running,

85
00:05:08,918 --> 00:05:12,001
sort of so I'll do a control c again.

86
00:05:14,702 --> 00:05:17,543
And just verify with the
Docker container ls that I have

87
00:05:17,543 --> 00:05:21,710
a new container for me
beginning e7, so I'll recall the

88
00:05:22,979 --> 00:05:27,146
exec command and I'll change
the container id to e7,

89
00:05:29,817 --> 00:05:33,900
and again we'll repeat
the mysql dash p password,

90
00:05:35,378 --> 00:05:39,545
we'll use fleetman and now
for the big reveal if I do

91
00:05:41,495 --> 00:05:45,662
a show tables yeah we have lost
the data that we had before.

92
00:05:47,895 --> 00:05:51,025
I don't know if you're
surprised by that, I'm guessing

93
00:05:51,025 --> 00:05:54,118
you're probably not surprised
by that, because of course

94
00:05:54,118 --> 00:05:58,321
all of the data you might think
was stored safely inside the

95
00:05:58,321 --> 00:06:02,689
container and was destroyed
when we did a remove.

96
00:06:02,689 --> 00:06:06,729
But, that's not true,
so why is it not true?

97
00:06:06,729 --> 00:06:11,568
Well if we go to Dockerhub,
and we'll find the mysql image

98
00:06:11,568 --> 00:06:13,769
that we're working from,
so it's this one here

99
00:06:13,769 --> 00:06:17,936
the official image and I'm
going to look in the Dockerfile,

100
00:06:19,567 --> 00:06:23,814
so I'll go for the latest
Dockerfile, and you should be

101
00:06:23,814 --> 00:06:28,365
fairly familiar with the contents
of this Dockerfile by now.

102
00:06:28,365 --> 00:06:32,569
It's quite a complicated one
of course, but the types of

103
00:06:32,569 --> 00:06:36,904
things we've been doing in
module 1 of the course they're,

104
00:06:36,904 --> 00:06:39,829
looks like they're installing
some software here,

105
00:06:39,829 --> 00:06:41,973
and anyway, various operations.

106
00:06:41,973 --> 00:06:45,065
But the line I want to
draw your attention to

107
00:06:45,065 --> 00:06:48,818
is the one right here, lets
zoom in on that a little bit.

108
00:06:48,818 --> 00:06:50,807
It's the Volume command.

109
00:06:50,807 --> 00:06:53,775
The first time we've seen this
in a Docker file, now what

110
00:06:53,775 --> 00:06:56,926
this command is saying
is that the contents

111
00:06:56,926 --> 00:07:01,093
of the /var/lib/mysql directory,
and that's the contents

112
00:07:03,092 --> 00:07:07,259
of the directory in the
container, needs to be persisted.

113
00:07:10,082 --> 00:07:13,674
And what Docker is automatically
doing when the container

114
00:07:13,674 --> 00:07:18,328
is starting up, that the data
inside that volume is actually

115
00:07:18,328 --> 00:07:21,161
being stored on the host computer.

116
00:07:22,446 --> 00:07:26,037
So that means that the
data inside this folder,

117
00:07:26,037 --> 00:07:30,204
this directory is going to
persist, we destroy the container

118
00:07:32,012 --> 00:07:36,179
but the data inside here will
remain on your host computer.

119
00:07:38,904 --> 00:07:42,002
Now this isn't a mysql course
but I can tell you that the

120
00:07:42,002 --> 00:07:46,169
contents of this folder are
effectively the database.

121
00:07:47,298 --> 00:07:51,579
So all of the important
data is inside that folder.

122
00:07:51,579 --> 00:07:54,693
Lets have a look at how
this works on a caption.

123
00:07:54,693 --> 00:07:58,469
Here's our host system,
and we're going to launch

124
00:07:58,469 --> 00:08:03,042
a container from an image,
such as the MYSQL image.

125
00:08:03,042 --> 00:08:05,480
And we've seen that in the
definition of that image

126
00:08:05,480 --> 00:08:09,621
the creators have declared
that there is a volume,

127
00:08:09,621 --> 00:08:14,362
which is going to be the
directory /var/lib/mysql

128
00:08:14,362 --> 00:08:16,195
inside that container.

129
00:08:17,189 --> 00:08:21,453
So what will happen at
runtime, when we run this image

130
00:08:21,453 --> 00:08:25,620
is the contents of the volume
are going to be mirrored

131
00:08:28,601 --> 00:08:31,944
in some directory, or some folder

132
00:08:31,944 --> 00:08:35,031
somewhere on the hosts system.

133
00:08:35,031 --> 00:08:37,174
We don't know where that
directory is just yet

134
00:08:37,174 --> 00:08:40,402
but I'll show you that in
a few moments, the point is

135
00:08:40,402 --> 00:08:44,842
it's stored somewhere
safe on the host's system.

136
00:08:44,842 --> 00:08:47,872
So that means that when
the container is stopped

137
00:08:47,872 --> 00:08:51,002
and removed, the data
that had been in that

138
00:08:51,002 --> 00:08:55,512
/var/lib/mysql folder is still present,

139
00:08:55,512 --> 00:08:57,076
it's still persistent

140
00:08:57,076 --> 00:09:01,707
it's right there on the hard
disc of the host system.

141
00:09:01,707 --> 00:09:03,204
So you might be wondering then,

142
00:09:03,204 --> 00:09:06,165
why when we did the
demonstration a few moments ago,

143
00:09:06,165 --> 00:09:09,288
and we started a brand new MYSQL container

144
00:09:09,288 --> 00:09:12,184
did we appear to lose our data?

145
00:09:12,184 --> 00:09:16,027
Well the answer's simply
unless we override the defaults

146
00:09:16,027 --> 00:09:19,685
when a second container is
created from that image,

147
00:09:19,685 --> 00:09:23,348
the process repeats we
have a volume here called

148
00:09:23,348 --> 00:09:27,611
/var/lib/mysql, Docker will mount that to

149
00:09:27,611 --> 00:09:30,278
a new folder on the host system.

150
00:09:31,843 --> 00:09:35,755
So we will have a fresh
database, however the

151
00:09:35,755 --> 00:09:39,922
important point is the old
data, has not been lost

152
00:09:41,136 --> 00:09:44,297
it's just not currently
in use, but it is there.

153
00:09:44,297 --> 00:09:46,380
On a directory somewhere.

154
00:09:47,432 --> 00:09:50,676
So lets investigate that, just
to remind ourselves we've got

155
00:09:50,676 --> 00:09:54,653
a MYSQL container running,
I've had a bit of a break

156
00:09:54,653 --> 00:09:56,093
and it was actually two hours ago

157
00:09:56,093 --> 00:09:57,672
that I started that container.

158
00:09:57,672 --> 00:10:01,626
But it is still running
is the important point,

159
00:10:01,626 --> 00:10:03,687
now a new command that
we haven't seen so far,

160
00:10:03,687 --> 00:10:06,730
is the command called inspect.

161
00:10:06,730 --> 00:10:10,897
We can inspect a container
using Docker container inspect

162
00:10:13,451 --> 00:10:18,254
followed by as usual the name
or the id of the container,

163
00:10:18,254 --> 00:10:22,989
my id begins e7 and what
we get from that is a large

164
00:10:22,989 --> 00:10:27,829
JSON document a lot of information
about the configuration

165
00:10:27,829 --> 00:10:29,827
of that container.

166
00:10:29,827 --> 00:10:31,977
There's a lot of stuff in
there that we're never going to

167
00:10:31,977 --> 00:10:35,235
look at or ever need,
but somewhere in here

168
00:10:35,235 --> 00:10:38,672
if you poke around, and I can see it here.

169
00:10:38,672 --> 00:10:41,255
There's a section called mount,

170
00:10:42,127 --> 00:10:44,512
and this is where the answer lies.

171
00:10:44,512 --> 00:10:48,678
We can see that we have a
mount, it's type is a volume

172
00:10:48,678 --> 00:10:52,845
and it has one of these long
automatically generated names.

173
00:10:54,518 --> 00:10:58,455
Now for me the name begins
two, zero b, and I'd like you

174
00:10:58,455 --> 00:11:02,088
to remember that, it's not
actually very important

175
00:11:02,088 --> 00:11:04,178
as you'll see shortly but I'm going

176
00:11:04,178 --> 00:11:08,677
to refer to that in a
moment, so two, zero b.

177
00:11:08,677 --> 00:11:12,015
I'll skip source for a
moment, but the destination,

178
00:11:12,015 --> 00:11:16,098
that's the folder in the
container's file system.

179
00:11:16,998 --> 00:11:21,030
So the /var/lib/mysql that we saw before.

180
00:11:21,030 --> 00:11:23,406
Now for the interesting part.

181
00:11:23,406 --> 00:11:26,000
We can now see, that what's happening is,

182
00:11:26,000 --> 00:11:29,750
that's been mounted to
the host's file system

183
00:11:31,080 --> 00:11:35,247
at this location, for me
it's var/lib/Docker/volumes

184
00:11:36,642 --> 00:11:40,809
long series of random characters /_data.

185
00:11:41,925 --> 00:11:46,009
Now if you're on a Linux
host system you could now go

186
00:11:46,009 --> 00:11:49,214
into that folder and have a
look for yourself, if you're

187
00:11:49,214 --> 00:11:53,318
on Windows or Mac, like
myself, this is actually on the

188
00:11:53,318 --> 00:11:56,680
file system of that virtual
machine that you're running

189
00:11:56,680 --> 00:12:00,669
in the background, we very
rarely see it or feel it,

190
00:12:00,669 --> 00:12:03,377
or really care that it's there.

191
00:12:03,377 --> 00:12:07,210
But it is there, and
that's where it's stored.

192
00:12:08,409 --> 00:12:10,467
So for me as a Windows
user, I tend to think

193
00:12:10,467 --> 00:12:13,823
of this directory as just being
a kind of hidden directory

194
00:12:13,823 --> 00:12:15,837
that I don't have access to.

195
00:12:15,837 --> 00:12:19,158
Now you can actually get
access to that if you want to,

196
00:12:19,158 --> 00:12:21,043
but I'm not going to look in there.

197
00:12:21,043 --> 00:12:24,398
The point is that volume is safely

198
00:12:24,398 --> 00:12:27,847
persisted outside of the container.

199
00:12:27,847 --> 00:12:31,174
Another new command is that
you can inspect these volumes,

200
00:12:31,174 --> 00:12:34,370
now I must admit I don't do
this very often so it's not a

201
00:12:34,370 --> 00:12:38,537
sort of day to day routine but
we can do a Docker volume ls

202
00:12:40,955 --> 00:12:44,925
and that will list all of
the volumes that we have.

203
00:12:44,925 --> 00:12:48,495
Now what I'm seeing is, the
only reason I'd asked you

204
00:12:48,495 --> 00:12:51,269
to remember the one beginning two, zero, b

205
00:12:51,269 --> 00:12:54,705
this one at the top is
obviously the volume

206
00:12:54,705 --> 00:12:58,210
that is currently attached
to my running container.

207
00:12:58,210 --> 00:12:59,430
What's the other one?

208
00:12:59,430 --> 00:13:01,758
This one beginning seven, nine, e?

209
00:13:01,758 --> 00:13:04,685
Well that's the volume that
we created the first time

210
00:13:04,685 --> 00:13:08,598
I ran the MYSQL container at
the start of this chapter.

211
00:13:08,598 --> 00:13:12,070
So this volume actually
contains that temporary table

212
00:13:12,070 --> 00:13:14,357
that I set up for testing,
now if you've done a

213
00:13:14,357 --> 00:13:17,804
Docker volume ls, you'll
probably see quite a long list

214
00:13:17,804 --> 00:13:21,691
of volumes, and that's because
of course in the previous

215
00:13:21,691 --> 00:13:24,829
chapter you were creating
MYSQL containers that,

216
00:13:24,829 --> 00:13:28,591
without your knowledge
were creating volumes.

217
00:13:28,591 --> 00:13:30,716
Before I started recording this chapter,

218
00:13:30,716 --> 00:13:34,799
I did a Docker volume
prune and what that will do

219
00:13:35,846 --> 00:13:40,037
is it will delete any volumes
that aren't currently in use.

220
00:13:40,037 --> 00:13:43,931
So I can do that right now,
so the warning confirms what

221
00:13:43,931 --> 00:13:47,251
I just said, so if I say yes
to that it will delete that

222
00:13:47,251 --> 00:13:50,440
volume that was containing
that temporary table.

223
00:13:50,440 --> 00:13:54,912
So this is all very intellectually
interesting, I suppose

224
00:13:54,912 --> 00:13:57,036
if you like that kind of thing.

225
00:13:57,036 --> 00:13:58,934
But what we really want to do is

226
00:13:58,934 --> 00:14:02,020
we want to be able to reuse a volume.

227
00:14:02,020 --> 00:14:04,837
Now you can, I suppose, fiddle around

228
00:14:04,837 --> 00:14:07,731
with these automatically generated names.

229
00:14:07,731 --> 00:14:10,715
But that's not the right
way to do it, the right way

230
00:14:10,715 --> 00:14:15,374
is to give your volumes a name
and all that means is when

231
00:14:15,374 --> 00:14:19,918
you start your first
container from the image,

232
00:14:19,918 --> 00:14:23,023
we know that it has a volume,
we know that by looking at

233
00:14:23,023 --> 00:14:27,531
the Dockerfile, and the
volume is /var/lib/mysql.

234
00:14:27,531 --> 00:14:30,228
At the command line we will
tell Docker that whatever

235
00:14:30,228 --> 00:14:34,144
volume it creates, and we
know now that's some directory

236
00:14:34,144 --> 00:14:37,183
somewhere on the host system.

237
00:14:37,183 --> 00:14:41,062
We're going to give that volume
a name, in the demonstration

238
00:14:41,062 --> 00:14:44,145
I'm going to go for the label mydata,

239
00:14:45,383 --> 00:14:48,675
and the point of doing that
is when we stop the container

240
00:14:48,675 --> 00:14:51,276
and remove the container,
and then at some point

241
00:14:51,276 --> 00:14:55,855
in the future we start a new
container from that image,

242
00:14:55,855 --> 00:15:00,022
we can remount the volume
using the same label which will

243
00:15:01,283 --> 00:15:03,783
mean it will pick up the same directory

244
00:15:03,783 --> 00:15:06,339
that we created before.

245
00:15:06,339 --> 00:15:08,446
So I hope that's quite straightforward,

246
00:15:08,446 --> 00:15:10,619
lets try this in a demonstration.

247
00:15:10,619 --> 00:15:12,752
And I think just to keep
things as clear as possible,

248
00:15:12,752 --> 00:15:14,752
lets start from scratch.

249
00:15:15,909 --> 00:15:18,399
Docker container ls tells
me that I've currently got

250
00:15:18,399 --> 00:15:22,885
one container running, I'm
going to stop that container

251
00:15:22,885 --> 00:15:27,052
and I'm going to do a Docker
container prune to remove that

252
00:15:29,475 --> 00:15:33,642
stopped container and I'm going
to do a Docker volume prune

253
00:15:34,873 --> 00:15:39,040
as well so that we really
do have, a Docker volume ls

254
00:15:40,381 --> 00:15:44,510
will confirm, we have a clean
sheet of paper to work from.

255
00:15:44,510 --> 00:15:48,227
But I am going to recall
the previous command,

256
00:15:48,227 --> 00:15:51,043
where we ran the container, so here it is.

257
00:15:51,043 --> 00:15:54,437
Docker container run, a couple
of environment variables,

258
00:15:54,437 --> 00:15:56,678
all very straightforward.

259
00:15:56,678 --> 00:16:00,845
We know that this image defines
a volume at /var/lib/mysql.

260
00:16:04,836 --> 00:16:08,986
We know that from the Docker
file, so to associate that with

261
00:16:08,986 --> 00:16:12,819
a label we use the dash
v command line option.

262
00:16:14,771 --> 00:16:18,380
You have to remember the
structure which is the label,

263
00:16:18,380 --> 00:16:22,547
that we want to give to this
volume, mydata followed by

264
00:16:23,455 --> 00:16:26,777
a colon, followed by
the path of the volume

265
00:16:26,777 --> 00:16:28,819
inside the container.

266
00:16:28,819 --> 00:16:31,293
And once again, I'm simply
working from the Dockerfile here,

267
00:16:31,293 --> 00:16:36,232
we know there's a volume
declared at /var/lib/mysql

268
00:16:36,232 --> 00:16:38,789
that's what I'm going to reflect in here,

269
00:16:38,789 --> 00:16:42,956
/var/lib/mysql, so quite a small change.

270
00:16:44,646 --> 00:16:49,502
And once again I forgotten to
put the dash d argument in to

271
00:16:49,502 --> 00:16:50,674
run this in the background.

272
00:16:50,674 --> 00:16:52,513
I don't really want to see these logs,

273
00:16:52,513 --> 00:16:55,681
but as usual I can do a control c

274
00:16:55,681 --> 00:16:58,470
and while that's starting
up, Docker container ls

275
00:16:58,470 --> 00:17:02,315
confirms the container
started up just fine.

276
00:17:02,315 --> 00:17:07,185
But the big difference now
is if I do a Docker volume ls

277
00:17:07,185 --> 00:17:10,406
we've got rid now, of that horrible random

278
00:17:10,406 --> 00:17:14,007
auto generated name which is very useful.

279
00:17:14,007 --> 00:17:16,931
By the way, we can also
inspect this volume,

280
00:17:16,931 --> 00:17:18,812
we've done an inspection of a container

281
00:17:18,812 --> 00:17:23,015
but we can also do a Docker volume inspect

282
00:17:23,015 --> 00:17:26,451
followed by the name, and I'm
not sure how useful this data

283
00:17:26,451 --> 00:17:28,926
is particularly but once
again it does confirm

284
00:17:28,926 --> 00:17:31,633
that this is mounting that volume

285
00:17:31,633 --> 00:17:35,196
on the host file system
under this path here.

286
00:17:35,196 --> 00:17:37,462
And again if you're on a
Linux system you can go

287
00:17:37,462 --> 00:17:40,276
and have a look at that
data if you're interested.

288
00:17:40,276 --> 00:17:42,421
What this means now, is if I put some data

289
00:17:42,421 --> 00:17:45,671
into this container, when
I destroy the container

290
00:17:45,671 --> 00:17:50,170
if I start it up again I can
use the same volume again.

291
00:17:50,170 --> 00:17:54,337
So lets run through that,
I'll exec onto this container

292
00:17:57,891 --> 00:18:01,558
and my container id
begins one, three, nine.

293
00:18:03,356 --> 00:18:05,823
I can run a bash shell in it,

294
00:18:05,823 --> 00:18:08,823
and we can do mysql dash p password,

295
00:18:11,531 --> 00:18:12,977
I'm going to use fleetman database

296
00:18:12,977 --> 00:18:16,227
and just as before I'll create a table.

297
00:18:17,270 --> 00:18:18,816
Lets give it a different name this time,

298
00:18:18,816 --> 00:18:22,733
I'm going to call the
table, does_this_persist,

299
00:18:24,935 --> 00:18:27,685
with a single column called dummy

300
00:18:28,977 --> 00:18:31,310
which will be a varchar 255.

301
00:18:33,592 --> 00:18:36,712
Anything you like in there,
really doesn't matter.

302
00:18:36,712 --> 00:18:39,569
And then we can exit from MYSQL,

303
00:18:39,569 --> 00:18:43,047
and exit from the container,
and now for the point of it.

304
00:18:43,047 --> 00:18:46,714
So I can stop that
container, and remove it.

305
00:18:53,523 --> 00:18:55,395
So in the past we used to think that

306
00:18:55,395 --> 00:18:58,549
the data inside that
container was destroyed.

307
00:18:58,549 --> 00:19:03,360
You know now it isn't,
it's safely in the volume

308
00:19:03,360 --> 00:19:05,610
called mydata, and now when

309
00:19:06,599 --> 00:19:10,266
we recall command to
restart that container.

310
00:19:11,307 --> 00:19:15,931
I won't change anything in
here because this dash v

311
00:19:15,931 --> 00:19:20,134
is now going to remount the
same volume that we used before.

312
00:19:20,134 --> 00:19:21,450
Because this time around it won't

313
00:19:21,450 --> 00:19:24,605
create a random name for that volume.

314
00:19:24,605 --> 00:19:28,772
So lets try that, and again
I've forgotten the dash d. Rgh.

315
00:19:30,284 --> 00:19:33,119
I suppose it's useful to see
this log so we know roughly

316
00:19:33,119 --> 00:19:36,573
when the container is
actually up and running.

317
00:19:36,573 --> 00:19:39,469
So I think that's in a good
state, if I do a control c

318
00:19:39,469 --> 00:19:43,552
now, and to complete the
demo I'll repeat the ls.

319
00:19:44,679 --> 00:19:47,596
So my id now begins six, nine, six.

320
00:19:49,242 --> 00:19:53,242
So I'll recall the exact
command six, nine, six,

321
00:19:56,521 --> 00:20:00,688
we're in the container, I can
run MYSQL dash p password,

322
00:20:03,490 --> 00:20:07,657
use the fleetman database,
and now for the big reveal.

323
00:20:08,747 --> 00:20:12,914
If we do a showtables, we now
have an answer to our question

324
00:20:14,486 --> 00:20:16,819
yes, that table did persist.

325
00:20:18,328 --> 00:20:21,755
So that's how volumes work,
and I hope you can see that

326
00:20:21,755 --> 00:20:25,922
is really an essential concept
if you're going to use Docker

327
00:20:27,003 --> 00:20:30,494
to containerize things such as databases,

328
00:20:30,494 --> 00:20:33,050
or really and kind of persistent source.

329
00:20:33,050 --> 00:20:37,227
So it could be a Redis
container, or whatever.

330
00:20:37,227 --> 00:20:40,204
Now perhaps a problem with
this is if I exit all the way

331
00:20:40,204 --> 00:20:44,371
back out, as you saw from the
inspection of that volume.

332
00:20:46,376 --> 00:20:49,859
The actual data is being
stored in some kind

333
00:20:49,859 --> 00:20:53,419
of strange folder that,
especially if you're

334
00:20:53,419 --> 00:20:55,329
on Windows or Mac we don't have

335
00:20:55,329 --> 00:20:59,262
easy visibility of that particular folder.

336
00:20:59,262 --> 00:21:02,915
Now it might be that you need
to keep control of that folder

337
00:21:02,915 --> 00:21:06,955
perhaps you need to take
a backup of that folder,

338
00:21:06,955 --> 00:21:09,961
or you need to put that,
the contents of that folder,

339
00:21:09,961 --> 00:21:14,044
into source code control,
or for whatever reason.

340
00:21:14,936 --> 00:21:19,327
So for that reason we don't
have to use these named volumes

341
00:21:19,327 --> 00:21:23,324
you can instead specify
your own mount point.

342
00:21:23,324 --> 00:21:25,483
So again, to demonstrate
this I'll start a fresh.

343
00:21:25,483 --> 00:21:29,400
We have one running
container which I will stop

344
00:21:31,448 --> 00:21:34,515
and I'll do a container prune

345
00:21:34,515 --> 00:21:36,868
to get rid of that stopped container

346
00:21:36,868 --> 00:21:40,508
and don't forget of course
that means that volume

347
00:21:40,508 --> 00:21:43,940
will still be there but
just to start from scratch

348
00:21:43,940 --> 00:21:46,588
I'm going to remove that
volume which we can do using

349
00:21:46,588 --> 00:21:51,077
Docker volume rn followed
by the name of that volume.

350
00:21:51,077 --> 00:21:54,380
And that will only work if
that volume is not associated

351
00:21:54,380 --> 00:21:56,845
with any containers, we know it isn't

352
00:21:56,845 --> 00:21:59,804
so it was fine to delete it.

353
00:21:59,804 --> 00:22:03,971
If I go back to my run command,
so this was where we were

354
00:22:06,815 --> 00:22:10,982
associating this volume with
a name, instead of the name,

355
00:22:12,951 --> 00:22:15,210
I can delete the name.

356
00:22:15,210 --> 00:22:17,627
I can simply specify directly

357
00:22:18,647 --> 00:22:21,600
a directory on my host file system.

358
00:22:21,600 --> 00:22:24,066
So if you're on a Linux
operating system you could do

359
00:22:24,066 --> 00:22:28,233
something like /home/ your
account name, whatever.

360
00:22:31,685 --> 00:22:34,376
You can, you put, you
can put any directory

361
00:22:34,376 --> 00:22:37,256
you like in there, on
Windows it is slightly

362
00:22:37,256 --> 00:22:41,999
more complicated because
obviously windows has colons

363
00:22:41,999 --> 00:22:43,520
and backslashes and so on.

364
00:22:43,520 --> 00:22:46,589
So the way it works for
windows is you begin

365
00:22:46,589 --> 00:22:50,756
with a double forward slash,
followed by your drive letter.

366
00:22:51,770 --> 00:22:56,243
So I'll go for the c drive
and then a forward slash

367
00:22:56,243 --> 00:22:59,184
and then the path to a
folder, and we still use

368
00:22:59,184 --> 00:23:02,244
forward slashes even
though we're on windows.

369
00:23:02,244 --> 00:23:05,205
So lets say I want to store
all of the data for this

370
00:23:05,205 --> 00:23:09,372
database under the c drive,
in the users/work folder

371
00:23:12,152 --> 00:23:13,430
and then I'll create a folder,

372
00:23:13,430 --> 00:23:16,680
lets call it something like mydatabase.

373
00:23:17,758 --> 00:23:20,005
So it's very similar to the
previous command where we were

374
00:23:20,005 --> 00:23:23,974
giving the volume a name but
Docker knows that we're not

375
00:23:23,974 --> 00:23:27,872
giving a name here, because
it sees the forward slashes.

376
00:23:27,872 --> 00:23:30,661
So don't forget if you're
on Linux it would just be

377
00:23:30,661 --> 00:23:34,018
a regular Linux file path,
but because I'm on Windows

378
00:23:34,018 --> 00:23:38,147
I've got to do this rather
odd forward slash business.

379
00:23:38,147 --> 00:23:41,963
Before I try that, I'll finally remember

380
00:23:41,963 --> 00:23:45,094
that it would be better if
I added the dash d argument

381
00:23:45,094 --> 00:23:49,364
so that this container
runs in the background.

382
00:23:49,364 --> 00:23:51,761
I just had to move the camera
there, because on Windows,

383
00:23:51,761 --> 00:23:54,164
and I guess this is the
case on Mac as well,

384
00:23:54,164 --> 00:23:56,459
you will be asked to confirm
that you want to share

385
00:23:56,459 --> 00:24:01,181
that particular drive, so
definitely say, share it.

386
00:24:01,181 --> 00:24:05,077
I don't think that will happen
if you're running on Linux.

387
00:24:05,077 --> 00:24:06,562
And once I make that confirmation,

388
00:24:06,562 --> 00:24:10,389
the container is now apparently running.

389
00:24:10,389 --> 00:24:12,772
And now if I go into my system explorer,

390
00:24:12,772 --> 00:24:16,093
I now have a folder called
mydatabase and this folder

391
00:24:16,093 --> 00:24:19,088
wasn't there at the
point I ran this command,

392
00:24:19,088 --> 00:24:22,327
and the timestamps confirm
this is exactly the time

393
00:24:22,327 --> 00:24:24,289
that I'm doing the recording,

394
00:24:24,289 --> 00:24:27,223
that this is the data from my database.

395
00:24:27,223 --> 00:24:29,624
So what's happening here is
no different to what happened

396
00:24:29,624 --> 00:24:32,288
when we were using the named volume,

397
00:24:32,288 --> 00:24:34,999
it's just that we've taken control

398
00:24:34,999 --> 00:24:37,745
of the location of the mount point.

399
00:24:37,745 --> 00:24:40,077
So I could go ahead now and add some data

400
00:24:40,077 --> 00:24:43,055
into that container and prove
that the data's persistent

401
00:24:43,055 --> 00:24:44,450
but I don't think I need to do that now,

402
00:24:44,450 --> 00:24:46,627
I hope you get the point.

403
00:24:46,627 --> 00:24:49,615
Join me in the next chapter
where we'll get back into Java

404
00:24:49,615 --> 00:24:53,532
and we'll see how we can
run Docker from Maven.

1
00:00:00,363 --> 00:00:01,306
- [Lecturer] In this chapter,

2
00:00:01,306 --> 00:00:04,618
it's time to return to the Java theme.

3
00:00:04,618 --> 00:00:09,166
And we'll be looking at how to
integrate Docker into Maven.

4
00:00:09,166 --> 00:00:11,713
But the way this chapter is optional.

5
00:00:11,713 --> 00:00:13,452
If you decide to skip it

6
00:00:13,452 --> 00:00:16,637
or you can't get something
working in this chapter,

7
00:00:16,637 --> 00:00:18,731
don't worry, you can safely proceed

8
00:00:18,731 --> 00:00:21,475
with the rest of the course.

9
00:00:21,475 --> 00:00:23,260
So up until now, we've been making changes

10
00:00:23,260 --> 00:00:25,295
to the project's code.

11
00:00:25,295 --> 00:00:28,379
And then we've been running
a build using maven.

12
00:00:28,379 --> 00:00:30,925
So here's the project that
we've been working on.

13
00:00:30,925 --> 00:00:33,342
I think we last worked on this

14
00:00:33,342 --> 00:00:35,820
in the chapter on networking.

15
00:00:35,820 --> 00:00:38,441
If you need information about
how to open the project,

16
00:00:38,441 --> 00:00:41,440
just check out the networking chapter.

17
00:00:41,440 --> 00:00:44,472
But up until now we've
been making changes,

18
00:00:44,472 --> 00:00:46,305
running a maven build,

19
00:00:47,453 --> 00:00:49,240
and the end results of that build

20
00:00:49,240 --> 00:00:51,573
has been we have a jar file.

21
00:00:52,518 --> 00:00:55,827
Then we've been switching
to the command line.

22
00:00:55,827 --> 00:00:59,040
And in the root folder of that project,

23
00:00:59,040 --> 00:01:02,332
we've been learning something like docker

24
00:01:02,332 --> 00:01:03,307
image

25
00:01:03,307 --> 00:01:04,542
build.

26
00:01:04,542 --> 00:01:07,112
We've been giving it a tag like

27
00:01:07,112 --> 00:01:08,971
fleetman-webapp.

28
00:01:08,971 --> 00:01:12,371
I'm using that folder
to build an image from,

29
00:01:12,371 --> 00:01:14,352
and then possibly if required,

30
00:01:14,352 --> 00:01:16,285
we've been doing a docker push

31
00:01:16,285 --> 00:01:19,285
to publish that image to docker hub.

32
00:01:20,289 --> 00:01:24,183
The steps I've carried out
in here are quite tedious.

33
00:01:24,183 --> 00:01:28,283
And it's been a real break in
the flow of our programming.

34
00:01:28,283 --> 00:01:29,770
So it would be great if we could get Maven

35
00:01:29,770 --> 00:01:32,131
to do all of those steps,

36
00:01:32,131 --> 00:01:35,496
create the jar, build the
docker image from that jar,

37
00:01:35,496 --> 00:01:38,746
and then optionally push to docker hub.

38
00:01:39,612 --> 00:01:41,303
All we need to achieve
this is to get hold of

39
00:01:41,303 --> 00:01:45,139
some kind of Maven plug-in
to make this happen.

40
00:01:45,139 --> 00:01:48,850
At the time of recording and
this is a fast-moving area

41
00:01:48,850 --> 00:01:51,467
so it might have changed
by time you watch this

42
00:01:51,467 --> 00:01:56,284
but in 2017 it seems that
the most popular plug-in

43
00:01:56,284 --> 00:01:58,892
for Maven and Docker out there

44
00:01:58,892 --> 00:02:02,725
is from a project called
fabric8 or fabricate.

45
00:02:04,288 --> 00:02:08,243
Now this project is
related to Red Hat I think,

46
00:02:08,243 --> 00:02:12,011
and fabric8 build
infrastructure and so on for

47
00:02:12,011 --> 00:02:13,678
cloud based systems.

48
00:02:14,921 --> 00:02:17,221
I don't know much about them but

49
00:02:17,221 --> 00:02:19,818
of the projects I've been working with,

50
00:02:19,818 --> 00:02:22,982
most of them working
with Docker and Maven,

51
00:02:22,982 --> 00:02:25,614
are using this fabric8 plug-in.

52
00:02:25,614 --> 00:02:27,662
So in this course we'll use it as well.

53
00:02:27,662 --> 00:02:31,084
There are some competing plug-ins as well.

54
00:02:31,084 --> 00:02:33,411
I know that Netflix for example have one

55
00:02:33,411 --> 00:02:35,484
and quite a few of this.

56
00:02:35,484 --> 00:02:39,067
Now I'm on their webpage
at dmp.fabric8.io.

57
00:02:41,735 --> 00:02:46,016
The dmp simply stands
for docker-maven-plugin.

58
00:02:46,016 --> 00:02:47,762
Be a little bit careful here.

59
00:02:47,762 --> 00:02:51,827
If you went to Google
for fabric8 maven plugin,

60
00:02:51,827 --> 00:02:55,521
and I must admit I make this
mistake quite often myself,

61
00:02:55,521 --> 00:02:58,426
you'll go for the obvious top links here

62
00:02:58,426 --> 00:03:00,933
and you'll think you're
in the right place but

63
00:03:00,933 --> 00:03:04,499
actually this is just a
general maven plug-in,

64
00:03:04,499 --> 00:03:06,608
the fabric8 creates.

65
00:03:06,608 --> 00:03:09,680
And it does have some
docker integration in there,

66
00:03:09,680 --> 00:03:11,472
but this is a bigger plug-in

67
00:03:11,472 --> 00:03:16,137
that is related to Kubernetes
and OpenShift platforms.

68
00:03:16,137 --> 00:03:20,304
In fact what you need is the
smaller docker-maven-plugin.

69
00:03:21,881 --> 00:03:24,131
As I say at dmp.fabric8.io.

70
00:03:26,492 --> 00:03:30,636
To use this plug-in, it's a
very simple job of adding in

71
00:03:30,636 --> 00:03:34,620
a new block inside your
maven plugin section.

72
00:03:34,620 --> 00:03:39,118
So in our projects, if
you can find your pom.xml,

73
00:03:39,118 --> 00:03:41,346
quite a long way down

74
00:03:41,346 --> 00:03:44,809
we have the build plugin section.

75
00:03:44,809 --> 00:03:48,341
Up until now we've been using
this spring-boot-maven-plugin.

76
00:03:48,341 --> 00:03:49,637
And what we're going to do

77
00:03:49,637 --> 00:03:53,137
is adding a new plugin section right here.

78
00:03:53,994 --> 00:03:56,012
Now it is quite a long plugin section

79
00:03:56,012 --> 00:03:59,303
and you can easily find this from inside

80
00:03:59,303 --> 00:04:02,689
the fabric8 docker-maven-plugin
reference manual,

81
00:04:02,689 --> 00:04:06,565
or if you prefer in the
practicals and code download

82
00:04:06,565 --> 00:04:10,427
for this course in the
folder called Maven Plugin.

83
00:04:10,427 --> 00:04:14,786
I've done you a little quick
text file called plugin.txt.

84
00:04:14,786 --> 00:04:18,002
All you need to do is grab
the contents of that file,

85
00:04:18,002 --> 00:04:20,144
and transfer that into the pom.

86
00:04:20,144 --> 00:04:21,702
If you're using the same pom as me,

87
00:04:21,702 --> 00:04:23,952
it will be around line 181.

88
00:04:26,091 --> 00:04:28,082
You won't need to make
some changes in here.

89
00:04:28,082 --> 00:04:29,692
There's nothing very exciting really

90
00:04:29,692 --> 00:04:31,872
in this plugin configuration.

91
00:04:31,872 --> 00:04:34,829
The groupid is io.fabric8.

92
00:04:34,829 --> 00:04:37,885
The name of the artefact
is docker-maven-plugin.

93
00:04:37,885 --> 00:04:40,738
And you might want to
check the version number.

94
00:04:40,738 --> 00:04:45,515
At the time of recording
the version was 0.21.0.

95
00:04:45,515 --> 00:04:47,276
But perhaps by the time you watch this,

96
00:04:47,276 --> 00:04:49,204
there will be a more recent version.

97
00:04:49,204 --> 00:04:52,085
In the reference manual
you can check the version

98
00:04:52,085 --> 00:04:54,615
listed right at the top here,

99
00:04:54,615 --> 00:04:56,762
and you can change that if you want.

100
00:04:56,762 --> 00:04:58,170
Now by far the hardest thing

101
00:04:58,170 --> 00:05:00,001
about getting this plugin to work

102
00:05:00,001 --> 00:05:04,442
is that maven is going to have
to communicate with docker.

103
00:05:04,442 --> 00:05:05,895
And you know by now that docker

104
00:05:05,895 --> 00:05:08,704
is running as a daemon process

105
00:05:08,704 --> 00:05:10,757
either on your native machine

106
00:05:10,757 --> 00:05:14,319
or possibly in a virtual machine.

107
00:05:14,319 --> 00:05:16,464
If you're running on Windows or Macintosh,

108
00:05:16,464 --> 00:05:18,235
then you will have a virtual machine

109
00:05:18,235 --> 00:05:19,740
running in the background.

110
00:05:19,740 --> 00:05:22,458
Maven will communicate with
the docker daemon process

111
00:05:22,458 --> 00:05:25,874
by using some kind of
a network connection.

112
00:05:25,874 --> 00:05:28,215
And sometimes this network connection

113
00:05:28,215 --> 00:05:30,289
needs to be configured.

114
00:05:30,289 --> 00:05:34,143
Now I'm recording here
on docker for Windows,

115
00:05:34,143 --> 00:05:36,060
not the docker toolbox.

116
00:05:37,521 --> 00:05:39,699
And for me I've discovered that

117
00:05:39,699 --> 00:05:43,366
I don't need any
configuration of dockerHost

118
00:05:44,952 --> 00:05:49,119
which is why for me I've
commented out these three lines.

119
00:05:50,018 --> 00:05:52,393
For me it will just work.

120
00:05:52,393 --> 00:05:55,070
So definitely if you're
running on docker for windows,

121
00:05:55,070 --> 00:05:57,848
then you can just do what I've done here.

122
00:05:57,848 --> 00:06:01,010
You could in fact delete
these three lines of code.

123
00:06:01,010 --> 00:06:03,058
However on different platforms

124
00:06:03,058 --> 00:06:05,106
you do need a configuration.

125
00:06:05,106 --> 00:06:07,138
On some platforms you will have

126
00:06:07,138 --> 00:06:10,138
to explicitly have a dockerHost line

127
00:06:11,850 --> 00:06:13,183
pointing to http

128
00:06:14,933 --> 00:06:16,856
and this is local host

129
00:06:16,856 --> 00:06:17,689
:2375

130
00:06:19,571 --> 00:06:22,607
which is the docker daemon port.

131
00:06:22,607 --> 00:06:23,618
Now I have that line in

132
00:06:23,618 --> 00:06:26,141
when I'm developing on my laptop

133
00:06:26,141 --> 00:06:29,391
which is running the
mint Linux distribution.

134
00:06:29,391 --> 00:06:31,685
But I don't need it
for docker for windows.

135
00:06:31,685 --> 00:06:35,101
But on some platforms such as Mac OS,

136
00:06:35,101 --> 00:06:38,158
you may need this line here instead.

137
00:06:38,158 --> 00:06:39,991
This is a Unix socket.

138
00:06:41,674 --> 00:06:45,250
And I don't understand
the full reasons why but

139
00:06:45,250 --> 00:06:49,554
when I'm working on an
Amazon Linux machine,

140
00:06:49,554 --> 00:06:52,994
then I do need this line of configuration.

141
00:06:52,994 --> 00:06:54,052
Now later on in the course

142
00:06:54,052 --> 00:06:56,144
we will be using an Amazon Linux machine,

143
00:06:56,144 --> 00:06:58,628
but we won't actually be building there.

144
00:06:58,628 --> 00:07:01,042
That would be significant if for example

145
00:07:01,042 --> 00:07:03,513
you're running a Jenkins installation

146
00:07:03,513 --> 00:07:06,137
on an Amazon Linux box

147
00:07:06,137 --> 00:07:09,756
and you want to run your
maven builds from that box.

148
00:07:09,756 --> 00:07:12,825
So I'm sort of a little
bit nervous here that

149
00:07:12,825 --> 00:07:15,596
clearly there's a lot of
different configurations

150
00:07:15,596 --> 00:07:17,058
depending on your platform

151
00:07:17,058 --> 00:07:19,564
and I can't test them all on the video.

152
00:07:19,564 --> 00:07:23,296
So I suggest you just
try running this with

153
00:07:23,296 --> 00:07:26,252
all of these lines commented out.

154
00:07:26,252 --> 00:07:28,494
If you have any problems then try

155
00:07:28,494 --> 00:07:30,066
the local host version,

156
00:07:30,066 --> 00:07:31,616
try the sock version definitely

157
00:07:31,616 --> 00:07:35,404
if you're on a Linux
distribution or a Macintosh.

158
00:07:35,404 --> 00:07:37,712
And if all of those options fail,

159
00:07:37,712 --> 00:07:39,463
then do contact us through the

160
00:07:39,463 --> 00:07:41,649
virtual pair programmes contact link.

161
00:07:41,649 --> 00:07:43,081
If you do get completely stuck,

162
00:07:43,081 --> 00:07:44,810
as I said at start, don't panic,

163
00:07:44,810 --> 00:07:48,051
you don't need to do this
for the rest of the course.

164
00:07:48,051 --> 00:07:51,295
You can do the building
of the images by hand.

165
00:07:51,295 --> 00:07:53,573
So it's not a disaster
but it would be nice

166
00:07:53,573 --> 00:07:56,345
if you could get it up and running.

167
00:07:56,345 --> 00:07:59,672
So just to reiterate, I'm
on a docker for Windows

168
00:07:59,672 --> 00:08:02,997
so I don't need any of
these configurations.

169
00:08:02,997 --> 00:08:05,235
Now the next block that I've given you is

170
00:08:05,235 --> 00:08:07,868
if you want to do pushes to docker hub

171
00:08:07,868 --> 00:08:10,290
as part of your build process.

172
00:08:10,290 --> 00:08:12,694
Now obviously maven is going to need to

173
00:08:12,694 --> 00:08:14,723
log in to docker hub to do that.

174
00:08:14,723 --> 00:08:15,700
So one way of doing that

175
00:08:15,700 --> 00:08:18,777
is by providing this authConfig block

176
00:08:18,777 --> 00:08:22,037
where you put in your
username and password.

177
00:08:22,037 --> 00:08:25,057
Now this is a very easy way
of getting up and running,

178
00:08:25,057 --> 00:08:26,404
of making things work.

179
00:08:26,404 --> 00:08:28,887
However I guess you would prefer

180
00:08:28,887 --> 00:08:31,043
to store your username and password

181
00:08:31,043 --> 00:08:34,559
somewhere outside of
your maven configuration.

182
00:08:34,559 --> 00:08:35,836
So I'll show you in a few moments

183
00:08:35,836 --> 00:08:37,679
how you can do that.

184
00:08:37,679 --> 00:08:40,510
For now we'll just leave that as is.

185
00:08:40,510 --> 00:08:42,958
Now we're in the images block

186
00:08:42,958 --> 00:08:46,292
and this is where we can
naturally configure the images

187
00:08:46,292 --> 00:08:48,230
that we're going to be building.

188
00:08:48,230 --> 00:08:50,725
And we only have one image tag in here.

189
00:08:50,725 --> 00:08:52,475
This line here is where you specify

190
00:08:52,475 --> 00:08:54,978
the name of the image
that you're building.

191
00:08:54,978 --> 00:08:57,107
Ideally but we put that in a placeholder

192
00:08:57,107 --> 00:08:58,801
to force you to remain it.

193
00:08:58,801 --> 00:09:01,884
So for me it's virtualpairprogrammers

194
00:09:03,288 --> 00:09:05,621
/fleetmap-webapp.

195
00:09:06,946 --> 00:09:08,590
If you're publishing your image

196
00:09:08,590 --> 00:09:10,577
to your own docker hub repository,

197
00:09:10,577 --> 00:09:11,863
then of course you'll need to change

198
00:09:11,863 --> 00:09:13,864
this virtual pair programmers

199
00:09:13,864 --> 00:09:16,140
to something different.

200
00:09:16,140 --> 00:09:18,070
And if you're not planning in pushing

201
00:09:18,070 --> 00:09:20,380
these images to docker hub,

202
00:09:20,380 --> 00:09:24,007
then you could remove the
whole of the label as well.

203
00:09:24,007 --> 00:09:25,781
That was entirely up to you.

204
00:09:25,781 --> 00:09:27,336
Now that's pretty much it

205
00:09:27,336 --> 00:09:30,447
apart from this very important line here,

206
00:09:30,447 --> 00:09:33,177
the docker file directory.

207
00:09:33,177 --> 00:09:35,044
Now this is telling the maven plugin

208
00:09:35,044 --> 00:09:37,487
where to find the docker file.

209
00:09:37,487 --> 00:09:39,174
Up until now on this course,

210
00:09:39,174 --> 00:09:41,407
we've been storing the docker file

211
00:09:41,407 --> 00:09:43,976
in the roots of the project,

212
00:09:43,976 --> 00:09:46,154
but you'll notice from here

213
00:09:46,154 --> 00:09:49,758
that I'm now proposing that
we store the docker file

214
00:09:49,758 --> 00:09:53,925
in a sub-folder such as src/main.docker.

215
00:09:55,026 --> 00:09:56,229
Now the reason for this

216
00:09:56,229 --> 00:09:58,897
is something that I've
been ignoring up until now.

217
00:09:58,897 --> 00:10:01,207
I'm here in the roots of the project

218
00:10:01,207 --> 00:10:03,398
and of course in the root of the project,

219
00:10:03,398 --> 00:10:05,950
we got a lot of sub-folders

220
00:10:05,950 --> 00:10:09,106
and a lot of configuration files.

221
00:10:09,106 --> 00:10:13,663
Basically we have a lot of
assets inside this folder.

222
00:10:13,663 --> 00:10:17,769
You probably noticed that
whenever you run a build,

223
00:10:17,769 --> 00:10:21,232
I'm going to sort of slow
down the video at this stage

224
00:10:21,232 --> 00:10:25,278
just so you catch what's happening there.

225
00:10:25,278 --> 00:10:27,412
Every time we've been building an image,

226
00:10:27,412 --> 00:10:30,610
you've seen this sending build context

227
00:10:30,610 --> 00:10:32,723
to docker daemon.

228
00:10:32,723 --> 00:10:35,778
And I don't think I've
explained what's happening there

229
00:10:35,778 --> 00:10:37,371
at any point.

230
00:10:37,371 --> 00:10:41,408
Well docker is running as a daemon process

231
00:10:41,408 --> 00:10:42,741
on your machine.

232
00:10:43,730 --> 00:10:46,814
And in order for it to do its work,

233
00:10:46,814 --> 00:10:51,097
your command line has to
send all of the information,

234
00:10:51,097 --> 00:10:53,160
all the data that docker is going to need

235
00:10:53,160 --> 00:10:55,278
to build an image.

236
00:10:55,278 --> 00:10:58,884
And the way it works actually
is via this dot here.

237
00:10:58,884 --> 00:11:02,033
I can finally explain
what the dot is all about.

238
00:11:02,033 --> 00:11:04,913
It's telling maven that it
will find the docker file

239
00:11:04,913 --> 00:11:06,653
in this folder,

240
00:11:06,653 --> 00:11:10,522
and this folder and all
of its sub-directories

241
00:11:10,522 --> 00:11:13,758
contains all of the data
that docker is going to need

242
00:11:13,758 --> 00:11:16,602
in order to build its image.

243
00:11:16,602 --> 00:11:18,431
So what the docker command line is doing

244
00:11:18,431 --> 00:11:22,598
is zipping up this entire
folder and all sub-folders.

245
00:11:24,023 --> 00:11:25,835
And when it zips it up,

246
00:11:25,835 --> 00:11:28,553
it sends it across the docker daemon

247
00:11:28,553 --> 00:11:30,766
through a network connection.

248
00:11:30,766 --> 00:11:33,507
Now I've been putting the
docker file in the root folder,

249
00:11:33,507 --> 00:11:35,665
really just out of laziness but

250
00:11:35,665 --> 00:11:37,228
it's pretty inefficient

251
00:11:37,228 --> 00:11:40,074
because every time we
run that image build,

252
00:11:40,074 --> 00:11:41,694
it has to zip everything up

253
00:11:41,694 --> 00:11:45,676
and do that very expensive
network transfer.

254
00:11:45,676 --> 00:11:46,848
Now if you think about it,

255
00:11:46,848 --> 00:11:50,655
all our image build
needs is the docker file

256
00:11:50,655 --> 00:11:54,439
and the jar file that we're building.

257
00:11:54,439 --> 00:11:56,361
So we really should now be more efficient

258
00:11:56,361 --> 00:11:58,647
in the way that we're
running these builds.

259
00:11:58,647 --> 00:12:00,460
It's actually not too bad right now.

260
00:12:00,460 --> 00:12:04,300
My project directory
is about 65 megabytes.

261
00:12:04,300 --> 00:12:05,788
But of course on a real project,

262
00:12:05,788 --> 00:12:08,907
this is likely to be significantly bigger,

263
00:12:08,907 --> 00:12:11,609
it could slow down your
builds quite a lot.

264
00:12:11,609 --> 00:12:15,606
So for that reason and if
you're following along with me,

265
00:12:15,606 --> 00:12:17,351
you will need to do the same.

266
00:12:17,351 --> 00:12:21,963
We're going to create a new
folder inside the SRC folder

267
00:12:21,963 --> 00:12:22,880
under main,

268
00:12:24,770 --> 00:12:27,020
a new folder called docker.

269
00:12:29,077 --> 00:12:31,702
And I'm proposing that we will

270
00:12:31,702 --> 00:12:34,340
take the existing docker file

271
00:12:34,340 --> 00:12:37,673
and move it into that new docker folder.

272
00:12:39,948 --> 00:12:44,865
And the purpose of that is now
when we run the image build

273
00:12:44,865 --> 00:12:46,478
and of course we're going
to be doing that now

274
00:12:46,478 --> 00:12:47,645
through maven,

275
00:12:49,102 --> 00:12:51,116
it's only going to have to zip up

276
00:12:51,116 --> 00:12:53,638
the contents of this docker folder

277
00:12:53,638 --> 00:12:56,697
which is just actually the docker file.

278
00:12:56,697 --> 00:12:59,973
Well of course we also
need the jar file as well.

279
00:12:59,973 --> 00:13:03,402
But this plugin can handle that.

280
00:13:03,402 --> 00:13:04,961
If I go back to the pom,

281
00:13:04,961 --> 00:13:07,558
it's actually is quite obscure tag here,

282
00:13:07,558 --> 00:13:10,480
this descriptorRef artefact.

283
00:13:10,480 --> 00:13:12,245
The plugin knows to take the jar file

284
00:13:12,245 --> 00:13:14,140
from the target directory.

285
00:13:14,140 --> 00:13:16,791
And because of this, it knows
to transparently include

286
00:13:16,791 --> 00:13:20,080
the jar file alongside the docker file.

287
00:13:20,080 --> 00:13:22,829
Now it doesn't physically move
it into this docker folder.

288
00:13:22,829 --> 00:13:25,176
You won't see any changes
to that docker folder

289
00:13:25,176 --> 00:13:28,081
but conceptually that's what it's doing.

290
00:13:28,081 --> 00:13:29,869
So it will make the whole build process

291
00:13:29,869 --> 00:13:31,786
be much more efficient.

292
00:13:33,237 --> 00:13:34,898
There is one change you will need to make

293
00:13:34,898 --> 00:13:37,468
to your docker file however.

294
00:13:37,468 --> 00:13:39,388
We just have to change this one line here

295
00:13:39,388 --> 00:13:41,658
where up until now we've
been copying the jar file

296
00:13:41,658 --> 00:13:45,075
from the target directory into the image.

297
00:13:46,306 --> 00:13:48,456
Now it's just the way
that this plugin works

298
00:13:48,456 --> 00:13:51,492
that instead of working
from the target directory,

299
00:13:51,492 --> 00:13:55,409
it will now work from a
directory called maven.

300
00:13:56,939 --> 00:13:59,458
You should now be able to include docker

301
00:13:59,458 --> 00:14:01,595
into your build process.

302
00:14:01,595 --> 00:14:03,407
Now we'll improve this in a few moments

303
00:14:03,407 --> 00:14:06,177
but just to test everything's working,

304
00:14:06,177 --> 00:14:08,822
we'll right-click on the pom.xml

305
00:14:08,822 --> 00:14:11,486
under Run As Maven Build.

306
00:14:11,486 --> 00:14:13,897
And the goals we're going to run are

307
00:14:13,897 --> 00:14:16,857
the clean goal which as usual

308
00:14:16,857 --> 00:14:19,982
is going to clean the target directory.

309
00:14:19,982 --> 00:14:22,395
Then we're going to run the package goal

310
00:14:22,395 --> 00:14:24,625
which will build your jar file.

311
00:14:24,625 --> 00:14:27,469
That's what we've been
doing so far on the course.

312
00:14:27,469 --> 00:14:30,121
Now we're going to add an additional step

313
00:14:30,121 --> 00:14:31,454
which is docker:

314
00:14:33,383 --> 00:14:34,216
build.

315
00:14:35,471 --> 00:14:37,137
And that's going to build a docker image

316
00:14:37,137 --> 00:14:39,463
from the docker file.

317
00:14:39,463 --> 00:14:41,009
Hope that makes sense.

318
00:14:41,009 --> 00:14:42,842
Let's see if it works.

319
00:14:44,522 --> 00:14:47,323
And now there's a very significant step.

320
00:14:47,323 --> 00:14:48,761
Once the jar file has been created,

321
00:14:48,761 --> 00:14:52,856
you can now see some
logging coming form docker.

322
00:14:52,856 --> 00:14:54,200
And you'll recognise all of these.

323
00:14:54,200 --> 00:14:56,403
This is exactly what you will have seen

324
00:14:56,403 --> 00:14:58,495
on the command line.

325
00:14:58,495 --> 00:15:00,730
Don't forget if you have
any problems at this stage,

326
00:15:00,730 --> 00:15:02,838
it's probably due to the docker host.

327
00:15:02,838 --> 00:15:05,183
Check out your configuration there.

328
00:15:05,183 --> 00:15:06,341
But according to this,

329
00:15:06,341 --> 00:15:08,392
it has now successfully built an image

330
00:15:08,392 --> 00:15:09,601
which is being tagged

331
00:15:09,601 --> 00:15:13,515
virtualpairprogrammers/flettman-webapp.

332
00:15:13,515 --> 00:15:15,348
Now I just want to be clear that

333
00:15:15,348 --> 00:15:17,543
although we've done this through maven,

334
00:15:17,543 --> 00:15:21,088
we are still talking to the
same docker daemon process

335
00:15:21,088 --> 00:15:23,933
that we've been using
throughout the course.

336
00:15:23,933 --> 00:15:26,990
So therefore if I go to my command line

337
00:15:26,990 --> 00:15:28,740
and do a docker image

338
00:15:30,122 --> 00:15:30,955
ls,

339
00:15:32,260 --> 00:15:34,303
I've got a lot of irrelevant images here

340
00:15:34,303 --> 00:15:36,047
from earlier rehearsals but

341
00:15:36,047 --> 00:15:38,452
the important one is
the one at the top here,

342
00:15:38,452 --> 00:15:41,787
fleetman-webapp which
was created apparently

343
00:15:41,787 --> 00:15:43,037
52 seconds ago.

344
00:15:44,027 --> 00:15:46,338
So that's the one that was just created.

345
00:15:46,338 --> 00:15:48,096
So we're not doing anything clever

346
00:15:48,096 --> 00:15:50,108
or special here through maven.

347
00:15:50,108 --> 00:15:52,973
We're just making everything
a little more seamless

348
00:15:52,973 --> 00:15:54,586
than it was before.

349
00:15:54,586 --> 00:15:57,224
I could now on this
command line run that image

350
00:15:57,224 --> 00:15:59,479
in exactly the same way.

351
00:15:59,479 --> 00:16:02,964
By the way you can also run
your images using maven.

352
00:16:02,964 --> 00:16:04,738
If you're interested in doing that,

353
00:16:04,738 --> 00:16:06,231
just check out the reference manual.

354
00:16:06,231 --> 00:16:08,575
That's not something that I generally do.

355
00:16:08,575 --> 00:16:10,489
And the reasons for
that will become obvious

356
00:16:10,489 --> 00:16:12,758
when we do the probably the next chapter

357
00:16:12,758 --> 00:16:14,231
on docker compose.

358
00:16:14,231 --> 00:16:17,743
That's how I generally run my images.

359
00:16:17,743 --> 00:16:19,756
So the build's running well then.

360
00:16:19,756 --> 00:16:24,077
Before I move on, as we saw,
going back to the docker file,

361
00:16:24,077 --> 00:16:26,085
we changed the line here.

362
00:16:26,085 --> 00:16:28,443
And we changed it so that
we're copying the jar file

363
00:16:28,443 --> 00:16:31,064
from this folder called maven.

364
00:16:31,064 --> 00:16:33,645
We don't have a folder called maven

365
00:16:33,645 --> 00:16:36,098
anywhere on our hierarchy.

366
00:16:36,098 --> 00:16:38,285
So I think it's worth
just trying to work out

367
00:16:38,285 --> 00:16:39,943
what's happening here.

368
00:16:39,943 --> 00:16:40,776
And the answer comes

369
00:16:40,776 --> 00:16:43,285
if you have a look in
the target directory.

370
00:16:43,285 --> 00:16:46,130
You might need to do a
refresher of your project

371
00:16:46,130 --> 00:16:48,441
just to be safe first of all.

372
00:16:48,441 --> 00:16:50,987
Have a look inside your target directory.

373
00:16:50,987 --> 00:16:54,405
The plugin has created
a folder called docker.

374
00:16:54,405 --> 00:16:56,707
And you'll have a couple
of sub-folders in there

375
00:16:56,707 --> 00:17:00,050
just representing tag name of the image.

376
00:17:00,050 --> 00:17:03,163
And inside the build folder, aha,

377
00:17:03,163 --> 00:17:05,698
now we have the, as part of the build,

378
00:17:05,698 --> 00:17:08,822
the plugin has created
a folder called maven.

379
00:17:08,822 --> 00:17:11,627
It's copied your jar file into there

380
00:17:11,627 --> 00:17:13,687
and it's got the docker file in there

381
00:17:13,687 --> 00:17:16,052
at the same level as the maven folder.

382
00:17:16,052 --> 00:17:17,367
So I hope you can see now

383
00:17:17,367 --> 00:17:20,620
that the plugin is
working from this folder

384
00:17:20,620 --> 00:17:24,171
as its root folder when
it's building the image.

385
00:17:24,171 --> 00:17:26,752
That's more efficient than what
we've been doing previously

386
00:17:26,752 --> 00:17:29,092
because now it only has to zip up

387
00:17:29,092 --> 00:17:30,915
the contents of this folder

388
00:17:30,915 --> 00:17:33,734
rather than the entire project.

389
00:17:33,734 --> 00:17:35,674
So you don't really
need to know about that

390
00:17:35,674 --> 00:17:37,262
but I think it's worth getting a feeling

391
00:17:37,262 --> 00:17:39,971
for what's happening under the hood.

392
00:17:39,971 --> 00:17:42,327
So this is all very nice but

393
00:17:42,327 --> 00:17:45,018
the slight problem was
that when I ran that build,

394
00:17:45,018 --> 00:17:46,601
I had to do a clean

395
00:17:48,180 --> 00:17:49,612
package

396
00:17:49,612 --> 00:17:51,195
and a docker:build.

397
00:17:52,859 --> 00:17:55,899
Now I would say it's very
likely the case on a project

398
00:17:55,899 --> 00:17:58,591
that every time you run that package,

399
00:17:58,591 --> 00:18:00,608
because you have a new jar file,

400
00:18:00,608 --> 00:18:05,067
you also want to create
a new image as well.

401
00:18:05,067 --> 00:18:07,632
So how can we make this docker build goal

402
00:18:07,632 --> 00:18:11,953
happen automatically as
part of the package goal?

403
00:18:11,953 --> 00:18:14,989
And really here we're just
into standard maven theory.

404
00:18:14,989 --> 00:18:18,182
There's details of this on
our java build tools course

405
00:18:18,182 --> 00:18:19,957
if you're interested.

406
00:18:19,957 --> 00:18:22,776
It's covered on chapter
11 of Java build tools

407
00:18:22,776 --> 00:18:25,698
where we look at tailoring
the maven lifecycle

408
00:18:25,698 --> 00:18:27,484
which all sounds very grand

409
00:18:27,484 --> 00:18:29,215
but really it's just the case

410
00:18:29,215 --> 00:18:32,308
if we can tell maven fill up this plugin.

411
00:18:32,308 --> 00:18:35,325
So I'm working inside the plugin tag,

412
00:18:35,325 --> 00:18:38,341
and I'm going to put a
block of configuration

413
00:18:38,341 --> 00:18:40,591
just before the end plugin.

414
00:18:41,538 --> 00:18:44,621
And the tag I'm adding is executions.

415
00:18:46,262 --> 00:18:50,549
And inside there, there's a
single tag called execution.

416
00:18:50,549 --> 00:18:52,601
Now the execution tag, what we can do

417
00:18:52,601 --> 00:18:55,141
is we can use the phase tag.

418
00:18:55,141 --> 00:18:56,823
You might not be familiar with the concept

419
00:18:56,823 --> 00:18:58,471
of a phase in maven.

420
00:18:58,471 --> 00:19:02,512
A phase is a part of the maven lifecycle.

421
00:19:02,512 --> 00:19:05,048
And in fact package that we've been using

422
00:19:05,048 --> 00:19:06,809
throughout the course

423
00:19:06,809 --> 00:19:09,860
is one of the maven phases.

424
00:19:09,860 --> 00:19:12,913
And we can attach any goals that we like

425
00:19:12,913 --> 00:19:15,093
to that particular phase.

426
00:19:15,093 --> 00:19:17,343
So if we say phase package,

427
00:19:19,161 --> 00:19:21,494
we can then go on and attach

428
00:19:22,334 --> 00:19:25,799
a number of goals to that phase.

429
00:19:25,799 --> 00:19:27,043
And it's done using this stretch.

430
00:19:27,043 --> 00:19:29,031
We have an outer goals tag

431
00:19:29,031 --> 00:19:31,423
followed by one or more goals.

432
00:19:31,423 --> 00:19:35,081
Now already actually as part
of this spring boot plugin,

433
00:19:35,081 --> 00:19:38,773
there are already goals
attached to the package phase.

434
00:19:38,773 --> 00:19:40,462
All of the work needed to build

435
00:19:40,462 --> 00:19:43,438
that spring executable jar file

436
00:19:43,438 --> 00:19:45,962
has been attached to the package phase.

437
00:19:45,962 --> 00:19:50,082
But what we're doing here is
we're adding additional goals.

438
00:19:50,082 --> 00:19:53,415
So we can say that the docker:build goal

439
00:19:54,670 --> 00:19:57,591
is now going to be part
of the package phase.

440
00:19:57,591 --> 00:20:02,352
Actually we don't need the
docker: in front of that

441
00:20:02,352 --> 00:20:04,756
because we're already,

442
00:20:04,756 --> 00:20:06,013
that's a bit of a big tag this,

443
00:20:06,013 --> 00:20:08,694
but we're already in the plugin tag

444
00:20:08,694 --> 00:20:11,208
for the docker-maven-plugin.

445
00:20:11,208 --> 00:20:12,390
So I just wanted to be clear there

446
00:20:12,390 --> 00:20:16,226
that this build goal comes
from the docker plug in

447
00:20:16,226 --> 00:20:20,257
and it isn't kind of some
built-in part of maven.

448
00:20:20,257 --> 00:20:22,781
Alright so that simple
change now means that

449
00:20:22,781 --> 00:20:24,452
if I run the build again,

450
00:20:24,452 --> 00:20:28,699
but this time I'm just going
to use the clean and package

451
00:20:28,699 --> 00:20:31,003
while it says goal is actually we know now

452
00:20:31,003 --> 00:20:33,735
these are lifecycle phases.

453
00:20:33,735 --> 00:20:37,275
I don't need to include
docker build anymore.

454
00:20:37,275 --> 00:20:39,529
And can you see now that
the docker-maven-plugin

455
00:20:39,529 --> 00:20:41,260
build is running?

456
00:20:41,260 --> 00:20:42,489
And if you're following along with me,

457
00:20:42,489 --> 00:20:46,833
do check carefully that
you have a build success.

458
00:20:46,833 --> 00:20:49,490
It might be the case that
after every single build,

459
00:20:49,490 --> 00:20:53,301
you want to push the resulting image to

460
00:20:53,301 --> 00:20:56,187
a repository such as docker hub.

461
00:20:56,187 --> 00:20:59,385
And you've already seen in the pom

462
00:20:59,385 --> 00:21:02,890
that there's an authConfig section here

463
00:21:02,890 --> 00:21:06,643
which allows you to plug in
your username and password

464
00:21:06,643 --> 00:21:08,148
for docker hub.

465
00:21:08,148 --> 00:21:10,229
Feel free to do that if you want.

466
00:21:10,229 --> 00:21:12,413
It is a kind of a quick and dirty way

467
00:21:12,413 --> 00:21:14,013
of getting up and running

468
00:21:14,013 --> 00:21:16,309
with pushing from maven.

469
00:21:16,309 --> 00:21:18,036
The problem is of course,

470
00:21:18,036 --> 00:21:20,452
it's probably not a good idea

471
00:21:20,452 --> 00:21:24,339
to be embedding usernames
and passwords into poms.

472
00:21:24,339 --> 00:21:26,468
If it's a public Github repository,

473
00:21:26,468 --> 00:21:28,564
then you definitely would not be wanting

474
00:21:28,564 --> 00:21:30,950
to put your credentials in here.

475
00:21:30,950 --> 00:21:32,056
So if you want to keep things simple

476
00:21:32,056 --> 00:21:33,771
and you're following along with me,

477
00:21:33,771 --> 00:21:35,673
then just plug in your docker hub

478
00:21:35,673 --> 00:21:37,708
username and password there,

479
00:21:37,708 --> 00:21:40,541
and then you will be able to do a,

480
00:21:42,735 --> 00:21:43,893
we can do the same as before,

481
00:21:43,893 --> 00:21:45,633
we can do a clean package,

482
00:21:45,633 --> 00:21:49,873
and then we'll follow up with docker:push.

483
00:21:49,873 --> 00:21:51,412
And the important thing here is

484
00:21:51,412 --> 00:21:54,669
that you can see that it
attempted to do a push here.

485
00:21:54,669 --> 00:21:57,481
Of course that failed because I have an

486
00:21:57,481 --> 00:21:59,582
incorrect username and password.

487
00:21:59,582 --> 00:22:01,159
So if you don't want to put

488
00:22:01,159 --> 00:22:03,665
your username and password in here,

489
00:22:03,665 --> 00:22:06,718
and in fact I'm going
to remove this block,

490
00:22:06,718 --> 00:22:08,828
you can use that if you just want to do

491
00:22:08,828 --> 00:22:10,081
a quick and dirty test.

492
00:22:10,081 --> 00:22:12,824
But the recommended way is to
put your username and password

493
00:22:12,824 --> 00:22:15,423
into a local config file.

494
00:22:15,423 --> 00:22:19,066
And by local I mean it's outside
of your project structure.

495
00:22:19,066 --> 00:22:20,586
In fact the file that you're looking for

496
00:22:20,586 --> 00:22:22,957
is called settings.xml.

497
00:22:22,957 --> 00:22:27,127
And it will be located in
your maven home directory.

498
00:22:27,127 --> 00:22:29,399
The only complicated thing about that

499
00:22:29,399 --> 00:22:31,994
is actually finding that directory.

500
00:22:31,994 --> 00:22:35,586
The default location of
the maven home directory,

501
00:22:35,586 --> 00:22:37,300
just in case you don't know,

502
00:22:37,300 --> 00:22:39,467
is in your home directory.

503
00:22:40,657 --> 00:22:44,055
Now that's fairly easy
to find on Linux or Mac.

504
00:22:44,055 --> 00:22:48,222
On the command line you can
simply do a cd or a cd tilda,

505
00:22:49,226 --> 00:22:51,735
and that will take you
to your home directory.

506
00:22:51,735 --> 00:22:55,444
You should then find a
hidden directory called m2.

507
00:22:55,444 --> 00:22:57,139
So if you do an ls-a,

508
00:22:57,139 --> 00:23:00,550
that should show you there
is a directory called .m2.

509
00:23:00,550 --> 00:23:03,049
On Windows it's slightly different,

510
00:23:03,049 --> 00:23:06,610
you'll find your home
directory on the C drive

511
00:23:06,610 --> 00:23:09,777
under users followed by your username.

512
00:23:10,749 --> 00:23:13,038
And I've got a lot of rubbish in here

513
00:23:13,038 --> 00:23:16,174
but one of them is the .m2 directory.

514
00:23:16,174 --> 00:23:17,967
So if you have used this before,

515
00:23:17,967 --> 00:23:21,094
you'll know this is where maven
stores all of the jar files

516
00:23:21,094 --> 00:23:23,570
and so on that it downloads.

517
00:23:23,570 --> 00:23:28,100
So the location of the
setting.xml file is in here.

518
00:23:28,100 --> 00:23:30,911
It depends on whether you've
worked on this file before

519
00:23:30,911 --> 00:23:32,978
as to whether you actually have one.

520
00:23:32,978 --> 00:23:36,462
I have a pretty clean maven
installation on this computer

521
00:23:36,462 --> 00:23:40,004
so I don't have a settings.xml file.

522
00:23:40,004 --> 00:23:41,406
If that's the case for you,

523
00:23:41,406 --> 00:23:44,765
then in the practicals and
code download for this course,

524
00:23:44,765 --> 00:23:48,063
you'll find inside the
maven plugin folder,

525
00:23:48,063 --> 00:23:51,646
I've given you a basic
copy of setting.xml.

526
00:23:52,795 --> 00:23:56,962
Just copy that and transfer
it into your .m2 directory.

527
00:23:58,323 --> 00:24:00,774
We'll then add it in a
standard text editor.

528
00:24:00,774 --> 00:24:03,334
And very simple config file this.

529
00:24:03,334 --> 00:24:06,728
If you already have a settings.xml file,

530
00:24:06,728 --> 00:24:09,849
then you will be adding this service tag

531
00:24:09,849 --> 00:24:11,958
to your existing one.

532
00:24:11,958 --> 00:24:13,968
This is a standard maven construct

533
00:24:13,968 --> 00:24:15,908
that allows us to configure service

534
00:24:15,908 --> 00:24:17,992
that we're deploying to.

535
00:24:17,992 --> 00:24:21,493
So the ID is the name
of the server, docker.io

536
00:24:21,493 --> 00:24:23,088
for docker hub.

537
00:24:23,088 --> 00:24:25,374
And so all you need to do is simply add in

538
00:24:25,374 --> 00:24:29,419
your username and password,
and save that file.

539
00:24:29,419 --> 00:24:32,006
I'm going to do this of course off camera.

540
00:24:32,006 --> 00:24:33,270
Okay so that's done.

541
00:24:33,270 --> 00:24:36,659
So that means I should now be
able now to push this image

542
00:24:36,659 --> 00:24:38,473
to the docker repository.

543
00:24:38,473 --> 00:24:41,144
Before I do that, there's
one thing I need to change

544
00:24:41,144 --> 00:24:43,359
that you don't need to change.

545
00:24:43,359 --> 00:24:45,330
Up until now I've been tagging this image

546
00:24:45,330 --> 00:24:48,720
virtualpairprogrammers/fleetman-webapp,

547
00:24:48,720 --> 00:24:50,778
now you'll know this from the
first module of the course,

548
00:24:50,778 --> 00:24:52,527
that relates to the initial image

549
00:24:52,527 --> 00:24:54,661
that we pulled really early on

550
00:24:54,661 --> 00:24:57,078
in module one of this series.

551
00:24:57,947 --> 00:25:00,451
Now the problem is the
last thing I want to do

552
00:25:00,451 --> 00:25:03,214
is to push to this image

553
00:25:03,214 --> 00:25:06,252
because of course that's
going to ruin the image

554
00:25:06,252 --> 00:25:08,884
for everybody who's still working on

555
00:25:08,884 --> 00:25:10,982
module one of this course.

556
00:25:10,982 --> 00:25:13,679
Bear in mind I have made
changes to this image

557
00:25:13,679 --> 00:25:15,257
as part of this module.

558
00:25:15,257 --> 00:25:18,983
We've been using the MySQL
database for example.

559
00:25:18,983 --> 00:25:21,287
Now the correct way to handle this really,

560
00:25:21,287 --> 00:25:23,110
if we're going to the tags list.

561
00:25:23,110 --> 00:25:25,455
Normally in real life,

562
00:25:25,455 --> 00:25:29,208
I would give this new
version of the image,

563
00:25:29,208 --> 00:25:31,442
the one that's working with MySQL,

564
00:25:31,442 --> 00:25:34,276
I would give it a new tag.

565
00:25:34,276 --> 00:25:37,299
And I could do that by
simply changing the tag here

566
00:25:37,299 --> 00:25:38,634
to something like,

567
00:25:38,634 --> 00:25:41,742
well this is the version
of fleetman-webapp

568
00:25:41,742 --> 00:25:43,900
that is going to be going into production

569
00:25:43,900 --> 00:25:46,256
on our micro service architecture,

570
00:25:46,256 --> 00:25:49,582
so I could tag it as production.

571
00:25:49,582 --> 00:25:52,059
That's how I would do it in real life but

572
00:25:52,059 --> 00:25:55,741
I'm not going to do that on this video

573
00:25:55,741 --> 00:25:58,230
purely because if I do that,

574
00:25:58,230 --> 00:26:01,064
it might confuse people
who are new to docker

575
00:26:01,064 --> 00:26:02,989
who are doing module one,

576
00:26:02,989 --> 00:26:05,614
and they're going to see
two versions of the image

577
00:26:05,614 --> 00:26:06,891
and they might get confused

578
00:26:06,891 --> 00:26:10,058
because they haven't yet work on tags.

579
00:26:11,032 --> 00:26:13,336
Just for the purposes of the course then,

580
00:26:13,336 --> 00:26:15,925
I'm going to do the
simplest possible thing,

581
00:26:15,925 --> 00:26:18,912
and I'm going to just
give this a new name.

582
00:26:18,912 --> 00:26:22,097
I'm going to call this
just fleetman-production.

583
00:26:22,097 --> 00:26:25,058
I'm even not going to
put the webapp on there

584
00:26:25,058 --> 00:26:28,898
just to avoid confusing
the module one viewers.

585
00:26:28,898 --> 00:26:32,347
So I hope I've not
confused you in doing that,

586
00:26:32,347 --> 00:26:34,019
if you're following along with me,

587
00:26:34,019 --> 00:26:35,798
you'll have your own repository.

588
00:26:35,798 --> 00:26:37,664
You can call this anything you like

589
00:26:37,664 --> 00:26:39,978
including fleetman-webapp.

590
00:26:39,978 --> 00:26:42,955
But I just thought I'd
better be careful there.

591
00:26:42,955 --> 00:26:45,584
So I can now re-run this pom.

592
00:26:45,584 --> 00:26:49,447
So this time I'll run
the full clean package

593
00:26:49,447 --> 00:26:53,729
but then I'm going to follow
up with a docker:push.

594
00:26:53,729 --> 00:26:55,564
And to finish this course,

595
00:26:55,564 --> 00:26:58,058
I'll show you how you
can integrate docker push

596
00:26:58,058 --> 00:27:00,263
into an existing phase.

597
00:27:00,263 --> 00:27:01,839
For now though that should work,

598
00:27:01,839 --> 00:27:03,381
let's see what happens.

599
00:27:03,381 --> 00:27:05,077
Of course you will need to have changed

600
00:27:05,077 --> 00:27:07,071
your username and password

601
00:27:07,071 --> 00:27:09,846
in the settings.xml file.

602
00:27:09,846 --> 00:27:13,378
So there it's built my
fleetman-production image.

603
00:27:13,378 --> 00:27:15,268
And now it's running the push.

604
00:27:15,268 --> 00:27:17,484
This will take some time.

605
00:27:17,484 --> 00:27:20,293
Uploads to docker hub can be quite slow.

606
00:27:20,293 --> 00:27:23,117
Okay well that took a while,
two minutes 13 seconds for me,

607
00:27:23,117 --> 00:27:24,980
but I now have a build success.

608
00:27:24,980 --> 00:27:26,501
Hope that's working for you.

609
00:27:26,501 --> 00:27:28,606
Very occasionally I
found that at this stage,

610
00:27:28,606 --> 00:27:30,791
you might see an error saying that

611
00:27:30,791 --> 00:27:33,124
all pipe instances are busy.

612
00:27:34,085 --> 00:27:37,169
Now I found that this is
just a transient error

613
00:27:37,169 --> 00:27:38,622
that will go away

614
00:27:38,622 --> 00:27:41,306
if you just wait five minutes

615
00:27:41,306 --> 00:27:42,960
and try the build again.

616
00:27:42,960 --> 00:27:45,058
I suspect that's just a temporary problem

617
00:27:45,058 --> 00:27:47,335
with the docker hub website,

618
00:27:47,335 --> 00:27:50,112
although I must admit I've
never actually managed

619
00:27:50,112 --> 00:27:52,377
to narrow down that problem

620
00:27:52,377 --> 00:27:55,218
and work out why it happens.

621
00:27:55,218 --> 00:27:57,411
The trouble is after a few minutes,

622
00:27:57,411 --> 00:27:58,370
the problem has gone away

623
00:27:58,370 --> 00:28:01,234
so it's very difficult
to actually debug it.

624
00:28:01,234 --> 00:28:03,581
So if you have an all pipe instances

625
00:28:03,581 --> 00:28:04,985
are busy error at this stage,

626
00:28:04,985 --> 00:28:07,201
don't worry, just have a little break.

627
00:28:07,201 --> 00:28:09,669
Try again in a few minutes.

628
00:28:09,669 --> 00:28:10,629
We should now in docker hub,

629
00:28:10,629 --> 00:28:12,816
I guess we'll need to do a refresh,

630
00:28:12,816 --> 00:28:16,448
I should be able to
find the new repository.

631
00:28:16,448 --> 00:28:19,761
Notice that repository didn't exist

632
00:28:19,761 --> 00:28:21,917
and is absolutely fine to push

633
00:28:21,917 --> 00:28:24,372
a new repository like I've done.

634
00:28:24,372 --> 00:28:27,733
Notice for me this
ability of that repository

635
00:28:27,733 --> 00:28:29,313
is defaulted to private.

636
00:28:29,313 --> 00:28:31,798
And I think that's just because
I have a corporate account

637
00:28:31,798 --> 00:28:33,066
with docker hub,

638
00:28:33,066 --> 00:28:34,933
and on a corporate account,

639
00:28:34,933 --> 00:28:37,564
the default's to private repositories.

640
00:28:37,564 --> 00:28:39,719
I can easily change that by

641
00:28:39,719 --> 00:28:42,054
going into the repository info,

642
00:28:42,054 --> 00:28:44,232
going into settings,

643
00:28:44,232 --> 00:28:48,509
and I can click on Make
this Repository Public.

644
00:28:48,509 --> 00:28:51,757
So that's all good but you might
want to include the pushing

645
00:28:51,757 --> 00:28:54,744
into every single build you run.

646
00:28:54,744 --> 00:28:56,420
Now for me I don't.

647
00:28:56,420 --> 00:28:57,253
I will

648
00:28:58,188 --> 00:28:59,746
typically,

649
00:28:59,746 --> 00:29:00,752
every time I run a build,

650
00:29:00,752 --> 00:29:04,050
I will build an image but
only when I'm satisfied

651
00:29:04,050 --> 00:29:04,953
with that image.

652
00:29:04,953 --> 00:29:06,953
So that might be after several builds

653
00:29:06,953 --> 00:29:10,878
am I going to do a push to docker hub.

654
00:29:10,878 --> 00:29:13,531
So the way I just did it there

655
00:29:13,531 --> 00:29:15,746
with a clean package

656
00:29:15,746 --> 00:29:17,404
docker:push

657
00:29:17,404 --> 00:29:18,999
is a little bit tedious but

658
00:29:18,999 --> 00:29:21,201
I don't personally mind doing that.

659
00:29:21,201 --> 00:29:22,398
But if you're familiar with maven,

660
00:29:22,398 --> 00:29:25,427
you probably know there is
a standard built-in phase

661
00:29:25,427 --> 00:29:27,298
called deploy.

662
00:29:27,298 --> 00:29:30,621
And the idea of the deploy phase is that

663
00:29:30,621 --> 00:29:32,885
any artefacts that you
build as part of the build

664
00:29:32,885 --> 00:29:36,135
are transferred to a remote repository.

665
00:29:37,129 --> 00:29:39,801
Now usually that's a
jar file or a wall file

666
00:29:39,801 --> 00:29:42,361
that you're sending to a maven repository.

667
00:29:42,361 --> 00:29:44,756
But clearly pushing our image

668
00:29:44,756 --> 00:29:48,454
fits really nicely with the deploy phase.

669
00:29:48,454 --> 00:29:50,938
Now because I don't do this very often,

670
00:29:50,938 --> 00:29:52,975
I had to poke around a little bit

671
00:29:52,975 --> 00:29:54,695
to get this working.

672
00:29:54,695 --> 00:29:56,886
It's another execution tag.

673
00:29:56,886 --> 00:30:00,251
We can pretty much repeat
what we did before by

674
00:30:00,251 --> 00:30:01,539
plugging in to the phase,

675
00:30:01,539 --> 00:30:03,977
this time the deploy phase.

676
00:30:03,977 --> 00:30:07,539
And we have a set of goals as before.

677
00:30:07,539 --> 00:30:09,763
And we can attach to that the goal,

678
00:30:09,763 --> 00:30:11,363
this time of push.

679
00:30:11,363 --> 00:30:15,197
And remember that's the docker:push goal.

680
00:30:15,197 --> 00:30:18,321
Now there's two reasons
why that won't work.

681
00:30:18,321 --> 00:30:21,216
Let's look at the first reason.

682
00:30:21,216 --> 00:30:23,473
If we Run As Maven Build,

683
00:30:23,473 --> 00:30:25,800
just for speed, I'll go
straight to the deploy goal.

684
00:30:25,800 --> 00:30:27,730
I won't bother with the clean.

685
00:30:27,730 --> 00:30:29,974
It's immediately crashed with an error,

686
00:30:29,974 --> 00:30:34,633
and the line here is saying
that executions.execution.id

687
00:30:34,633 --> 00:30:35,883
must be unique.

688
00:30:36,798 --> 00:30:40,965
But duplicate execution
of that ID has been found.

689
00:30:41,924 --> 00:30:42,816
Now that's a maven problem

690
00:30:42,816 --> 00:30:45,169
and I don't really want
to get hung up on it.

691
00:30:45,169 --> 00:30:47,567
I think what's happening
is the fabric8 plugin

692
00:30:47,567 --> 00:30:51,440
has already done a bind to this phase.

693
00:30:51,440 --> 00:30:53,605
Now I've never managed
to get the out-of-the-box

694
00:30:53,605 --> 00:30:55,040
binding working.

695
00:30:55,040 --> 00:30:57,147
It might just be
something I'm doing wrong.

696
00:30:57,147 --> 00:31:00,469
I'm sort of overriding what they've done.

697
00:31:00,469 --> 00:31:02,968
And all you have to do to get around this,

698
00:31:02,968 --> 00:31:05,660
I'm not sure if this is
the best way to do it,

699
00:31:05,660 --> 00:31:07,521
this is just what works for me.

700
00:31:07,521 --> 00:31:10,858
Plug in an ID tag for this execution

701
00:31:10,858 --> 00:31:13,882
and you can put any
label you like in here.

702
00:31:13,882 --> 00:31:16,195
I'm going to go for mydeploy.

703
00:31:16,195 --> 00:31:19,862
And that should now
mean the build will run,

704
00:31:21,968 --> 00:31:24,172
the docker build is now running.

705
00:31:24,172 --> 00:31:25,879
We have a build failure.

706
00:31:25,879 --> 00:31:28,327
I'll need to move over
to the right-hand side.

707
00:31:28,327 --> 00:31:30,888
Repository element was not specified

708
00:31:30,888 --> 00:31:33,657
in the POM inside distributionManagement.

709
00:31:33,657 --> 00:31:35,500
Now the reason for this is,

710
00:31:35,500 --> 00:31:38,319
I don't think I've ever covered
it on any previous courses,

711
00:31:38,319 --> 00:31:42,672
but there is a standard deploy
plugin provided by maven

712
00:31:42,672 --> 00:31:45,526
which is used to deploy your
jar files or your wall files

713
00:31:45,526 --> 00:31:47,943
to remote maven repositories.

714
00:31:49,074 --> 00:31:52,084
And that's fine, we could
do that if we wanted to

715
00:31:52,084 --> 00:31:55,979
but we don't need it for this course.

716
00:31:55,979 --> 00:31:57,120
If you are doing it though,

717
00:31:57,120 --> 00:32:00,163
you have to provide some configuration.

718
00:32:00,163 --> 00:32:02,448
And that's why this is falling over.

719
00:32:02,448 --> 00:32:05,164
Now because we don't want
to deploy our jar files,

720
00:32:05,164 --> 00:32:07,706
we want to deploy our docker images,

721
00:32:07,706 --> 00:32:09,449
I have a simple fix, and again,

722
00:32:09,449 --> 00:32:12,062
this is just what works for me.

723
00:32:12,062 --> 00:32:15,145
We can provide a separate plugin tag,

724
00:32:16,777 --> 00:32:20,220
and this time we are
overriding the configuration

725
00:32:20,220 --> 00:32:23,137
of the default maven-deploy-plugin.

726
00:32:24,511 --> 00:32:26,011
So for artifactId,

727
00:32:29,577 --> 00:32:33,424
we need exactly what you
see here on the logging,

728
00:32:33,424 --> 00:32:34,424
maven-deploy

729
00:32:38,855 --> 00:32:39,688
- plugin.

730
00:32:40,646 --> 00:32:43,439
And then a configuration tag,

731
00:32:43,439 --> 00:32:46,038
we can plug in a tag called skip,

732
00:32:46,038 --> 00:32:48,672
give that a value of true.

733
00:32:48,672 --> 00:32:50,728
And that will effectively disable

734
00:32:50,728 --> 00:32:53,751
the built-in maven-deploy-plugin.

735
00:32:53,751 --> 00:32:55,888
So we then we won't get that error

736
00:32:55,888 --> 00:33:00,819
and then it will go on and
run the docker deploy instead.

737
00:33:00,819 --> 00:33:05,124
So as I say, that's
just what works for me.

738
00:33:05,124 --> 00:33:07,562
I'll do a full clean this time.

739
00:33:07,562 --> 00:33:09,229
A full clean deploy.

740
00:33:11,009 --> 00:33:13,530
All we need to run the full build.

741
00:33:13,530 --> 00:33:15,206
Yeah that's running nicely now.

742
00:33:15,206 --> 00:33:18,853
Can you see that here we had a
skipping artefact deployment?

743
00:33:18,853 --> 00:33:21,251
But then it's rolled on
and it's gone on to do

744
00:33:21,251 --> 00:33:24,150
the docker-maven-plugin push.

745
00:33:24,150 --> 00:33:26,942
That's perfect, that's
exactly what we want.

746
00:33:26,942 --> 00:33:28,913
The only possible error now would be

747
00:33:28,913 --> 00:33:32,230
if you see that all pipe
instances busy problem,

748
00:33:32,230 --> 00:33:34,036
again just come back in a few minutes

749
00:33:34,036 --> 00:33:36,422
and that problem should go away.

750
00:33:36,422 --> 00:33:37,985
That's going to take a few minutes.

751
00:33:37,985 --> 00:33:40,638
I'll let the push happen off camera.

752
00:33:40,638 --> 00:33:41,718
So the last thing to say on this

753
00:33:41,718 --> 00:33:44,860
is we were going to have a
chatter on Jenkins on this course

754
00:33:44,860 --> 00:33:47,826
but really I've thought about it and

755
00:33:47,826 --> 00:33:49,935
I've realised there isn't any need

756
00:33:49,935 --> 00:33:52,018
for separate chapter on Jenkins.

757
00:33:52,018 --> 00:33:54,158
The fact that you can run all of this

758
00:33:54,158 --> 00:33:55,985
from a standard maven build

759
00:33:55,985 --> 00:33:57,825
means that if you are using Jenkins,

760
00:33:57,825 --> 00:34:00,432
you can now just run this maven build

761
00:34:00,432 --> 00:34:02,904
on your Jenkins server.

762
00:34:02,904 --> 00:34:05,954
That's exactly what we do here
at virtual pair programmers.

763
00:34:05,954 --> 00:34:08,540
For example, our new sister site

764
00:34:08,540 --> 00:34:11,493
which is called All Things Java,

765
00:34:11,493 --> 00:34:15,942
we use that site primarily
to publish our podcast but

766
00:34:15,942 --> 00:34:17,334
we're planning to expand that

767
00:34:17,334 --> 00:34:20,267
into a kind of a Java news site.

768
00:34:20,267 --> 00:34:22,799
And all of that is dockerized.

769
00:34:22,799 --> 00:34:26,369
And you can see here from my
Jenkins pipeline stages that

770
00:34:26,369 --> 00:34:28,321
we've just combined the whole build

771
00:34:28,321 --> 00:34:31,123
in pushing the docker
image to our repository

772
00:34:31,123 --> 00:34:33,444
as a single step in that build.

773
00:34:33,444 --> 00:34:36,871
And all we're doing there
is running a maven pom.

774
00:34:36,871 --> 00:34:40,684
This deploy phase here is
deploying the resulting image

775
00:34:40,684 --> 00:34:42,791
to a piece of real hardware.

776
00:34:42,791 --> 00:34:45,607
So that's running up an EC2 instance.

777
00:34:45,607 --> 00:34:47,498
Now the only problem with that is

778
00:34:47,498 --> 00:34:49,085
it does mean you have to instal

779
00:34:49,085 --> 00:34:51,918
docker onto your Jenkins instance.

780
00:34:52,940 --> 00:34:53,773
That might be fine

781
00:34:53,773 --> 00:34:56,256
and actually that's
exactly what we've done.

782
00:34:56,256 --> 00:34:58,791
But you could be overloading
your Jenkins instance

783
00:34:58,791 --> 00:34:59,624
by doing that.

784
00:34:59,624 --> 00:35:02,331
And perhaps you don't
want you Jenkins instance

785
00:35:02,331 --> 00:35:05,299
to also be running
docker daemon and so on.

786
00:35:05,299 --> 00:35:09,466
So for that reason, there is,
if I go into Manage Jenkins,

787
00:35:11,233 --> 00:35:13,883
there is under Manage Plugins,

788
00:35:13,883 --> 00:35:16,208
you'll not be surprised to discover,

789
00:35:16,208 --> 00:35:18,870
if I click on the Available link,

790
00:35:18,870 --> 00:35:21,870
and search on the filter for docker,

791
00:35:23,065 --> 00:35:24,325
you'll not be surprised to find

792
00:35:24,325 --> 00:35:28,105
that there are several
docker plugins available.

793
00:35:28,105 --> 00:35:31,554
Now some of the plugins such
as this CloudBees Docker Plugin

794
00:35:31,554 --> 00:35:35,369
gives you the ability to build
a project from a docker file.

795
00:35:35,369 --> 00:35:38,809
Well we don't need that because
we can build our project

796
00:35:38,809 --> 00:35:41,188
from a docker file using maven.

797
00:35:41,188 --> 00:35:45,291
I think most of the plugins
such as this one here,

798
00:35:45,291 --> 00:35:46,783
the Docker Plugin,

799
00:35:46,783 --> 00:35:48,168
the main purpose of this plugin

800
00:35:48,168 --> 00:35:50,720
if I go a little further down,

801
00:35:50,720 --> 00:35:54,303
is the Docker Plugin
will use a docker host

802
00:35:55,577 --> 00:35:58,237
to dynamically provision a slave,

803
00:35:58,237 --> 00:35:59,411
run a build,

804
00:35:59,411 --> 00:36:01,437
and then tear-down that slave.

805
00:36:01,437 --> 00:36:03,090
Now on all of our courses so far,

806
00:36:03,090 --> 00:36:05,091
we haven't looked at Jenkins slaves

807
00:36:05,091 --> 00:36:06,717
but this is where you can spin up

808
00:36:06,717 --> 00:36:10,853
a separate instance
purely to do the build,

809
00:36:10,853 --> 00:36:12,468
and then when the build is done,

810
00:36:12,468 --> 00:36:14,727
that instance is destroyed,

811
00:36:14,727 --> 00:36:16,836
and that means that your Jenkins instance

812
00:36:16,836 --> 00:36:19,066
doesn't have to do a lot of hard work.

813
00:36:19,066 --> 00:36:22,856
You don't need a bigger
expensive server to run Jenkins.

814
00:36:22,856 --> 00:36:24,524
So that's for efficiency

815
00:36:24,524 --> 00:36:28,367
and we might do a module on Jenkins slaves

816
00:36:28,367 --> 00:36:31,274
at some point in the future
if anybody's interested.

817
00:36:31,274 --> 00:36:34,154
But for now it's just
enough to recognise that

818
00:36:34,154 --> 00:36:36,013
that's all this plugin is doing

819
00:36:36,013 --> 00:36:38,918
is it starts up a separate
machine running docker

820
00:36:38,918 --> 00:36:40,861
just to build your image,

821
00:36:40,861 --> 00:36:42,571
and then it tears it down.

822
00:36:42,571 --> 00:36:45,095
So that's all really useful and nice

823
00:36:45,095 --> 00:36:47,345
but when you're starting out with this,

824
00:36:47,345 --> 00:36:49,502
I would suggest it's
far easier just to use

825
00:36:49,502 --> 00:36:51,010
a standard maven build

826
00:36:51,010 --> 00:36:53,749
using the docker-maven-plugin
that we've studied

827
00:36:53,749 --> 00:36:57,201
in this chapter as part
of your standard build.

828
00:36:57,201 --> 00:36:59,902
So I hope that's a good start
with using maven and docker.

829
00:36:59,902 --> 00:37:01,975
Nothing too exciting in here.

830
00:37:01,975 --> 00:37:04,318
A lot of it is just really reading

831
00:37:04,318 --> 00:37:07,363
the reference manual for
the docker-maven-plugin.

832
00:37:07,363 --> 00:37:09,674
As I've said there are
other plugins out there,

833
00:37:09,674 --> 00:37:11,057
and I expect over time

834
00:37:11,057 --> 00:37:13,744
there's going to be a lot
of movements in this area.

835
00:37:13,744 --> 00:37:15,526
There is a plugin for Netflix.

836
00:37:15,526 --> 00:37:19,009
And there's also one from
Spotify as well I think.

837
00:37:19,009 --> 00:37:21,037
So I'll keep an eye on
those if you're interested,

838
00:37:21,037 --> 00:37:23,435
but for us at Virtual
Pair Programmers so far

839
00:37:23,435 --> 00:37:26,000
the fabric8 plugin has
done a great job for us.

840
00:37:26,000 --> 00:37:27,695
I hope it will for you too.

841
00:37:27,695 --> 00:37:30,678
In the next chapter we're
going to finally start

842
00:37:30,678 --> 00:37:34,041
moving towards multiple
container deployment.

843
00:37:34,041 --> 00:37:35,839
This is where things
get really interesting

844
00:37:35,839 --> 00:37:38,217
and we'll finally going
to be moving towards

845
00:37:38,217 --> 00:37:40,234
a micro service architecture.

846
00:37:40,234 --> 00:37:43,651
In the next chapter, it's Docker Compose.

1
00:00:01,240 --> 00:00:03,922
- [Instructor] It's
time to get serious now.

2
00:00:03,922 --> 00:00:05,524
The goal of this course

3
00:00:05,524 --> 00:00:07,736
was to be able to run multiple containers

4
00:00:07,736 --> 00:00:10,481
for a large architecture

5
00:00:10,481 --> 00:00:13,581
such as a microservice architecture

6
00:00:13,581 --> 00:00:16,501
and we're aiming to run across a cluster

7
00:00:16,501 --> 00:00:19,380
of physical hardware machines.

8
00:00:19,380 --> 00:00:22,260
Well we've got a while
before we get there,

9
00:00:22,260 --> 00:00:25,017
but the first serious step along the way

10
00:00:25,017 --> 00:00:28,024
is the very useful Docker compose tool

11
00:00:28,024 --> 00:00:31,443
which we'll be looking at in this chapter.

12
00:00:31,443 --> 00:00:33,081
Up until now, throughout this course,

13
00:00:33,081 --> 00:00:35,948
we've been manually starting containers

14
00:00:35,948 --> 00:00:38,001
on the command line.

15
00:00:38,001 --> 00:00:40,662
That's been fine for
getting started with Docker

16
00:00:40,662 --> 00:00:43,245
but of course when you're
doing real development work,

17
00:00:43,245 --> 00:00:46,344
that can get tedious very quickly.

18
00:00:46,344 --> 00:00:50,546
So up until now, we've been
setting up a small system

19
00:00:50,546 --> 00:00:52,649
where we have some kind of a webapp

20
00:00:52,649 --> 00:00:56,081
which is defined in the container image

21
00:00:56,081 --> 00:00:57,914
and we have a database

22
00:00:58,767 --> 00:01:01,768
which is its own container image.

23
00:01:01,768 --> 00:01:03,620
And back on the chapter on networking

24
00:01:03,620 --> 00:01:07,202
we saw how to connect those
two containers together.

25
00:01:07,202 --> 00:01:10,215
So imagine that we're the
developer on that project

26
00:01:10,215 --> 00:01:11,944
and it's a Monday morning

27
00:01:11,944 --> 00:01:15,556
and we've got to get our
development up and running.

28
00:01:15,556 --> 00:01:19,044
Well, we've got to do quite
a lot of tedious work.

29
00:01:19,044 --> 00:01:20,640
First of all, we need to make sure

30
00:01:20,640 --> 00:01:22,202
that we have a network.

31
00:01:22,202 --> 00:01:25,342
Now, I genuinely, I've just
started recording this chapter,

32
00:01:25,342 --> 00:01:29,766
I have no idea what state my
development machine is in.

33
00:01:29,766 --> 00:01:33,951
So I guess I could start
with a Docker network LS.

34
00:01:33,951 --> 00:01:37,388
And I think this my network here

35
00:01:37,388 --> 00:01:39,652
was the network that I created

36
00:01:39,652 --> 00:01:43,268
back in the networking
chapter to run our system.

37
00:01:43,268 --> 00:01:45,507
Just to be safe I'm going to start clean.

38
00:01:45,507 --> 00:01:48,840
I'll do a Docker network RM, my network.

39
00:01:50,966 --> 00:01:53,909
And we're now back to the
initial starting state

40
00:01:53,909 --> 00:01:56,447
of Docker which is we
have the bridge, the host,

41
00:01:56,447 --> 00:01:59,006
and the none network.

42
00:01:59,006 --> 00:02:02,043
And for running this
system this time around

43
00:02:02,043 --> 00:02:04,828
I'm going to do a Docker network create

44
00:02:04,828 --> 00:02:08,851
and this time I'll call
it the fleetman network

45
00:02:08,851 --> 00:02:11,730
and you can follow along
with me if you'd wish.

46
00:02:11,730 --> 00:02:14,708
Now we've got to start
up all of the containers.

47
00:02:14,708 --> 00:02:16,177
Now I reckon I should start

48
00:02:16,177 --> 00:02:18,486
by running the database container

49
00:02:18,486 --> 00:02:20,902
so you know how to do this by now,

50
00:02:20,902 --> 00:02:22,922
Docker container run.

51
00:02:22,922 --> 00:02:26,485
The image is going to be the MySQL image

52
00:02:26,485 --> 00:02:28,942
but we have a lot of
command line arguments

53
00:02:28,942 --> 00:02:30,961
to add into here.

54
00:02:30,961 --> 00:02:33,846
I'm definitely going to
need to the -d to run this

55
00:02:33,846 --> 00:02:35,786
in a detached state.

56
00:02:35,786 --> 00:02:38,665
I need to connect this
container to the network

57
00:02:38,665 --> 00:02:41,225
that we've just created,

58
00:02:41,225 --> 00:02:43,808
so --network fleetman -network.

59
00:02:45,428 --> 00:02:47,407
I will need to give this container a name

60
00:02:47,407 --> 00:02:50,160
and as we saw back in the
chapter on networking,

61
00:02:50,160 --> 00:02:52,307
that's so important because
it will be this name

62
00:02:52,307 --> 00:02:55,568
that's used for DNS resolution.

63
00:02:55,568 --> 00:02:58,060
It's going to become the
host name of this container

64
00:02:58,060 --> 00:02:59,567
in other words.

65
00:02:59,567 --> 00:03:01,400
So that will be --name

66
00:03:02,379 --> 00:03:04,387
and the name we'll be
using for this container

67
00:03:04,387 --> 00:03:09,160
back in the previous
chapters was just database.

68
00:03:09,160 --> 00:03:11,904
Now, I had to look that up off camera.

69
00:03:11,904 --> 00:03:15,075
Going back into the
project for this system,

70
00:03:15,075 --> 00:03:17,500
we're running under this
application Docker demo

71
00:03:17,500 --> 00:03:18,833
properties file.

72
00:03:19,805 --> 00:03:23,044
And recall that we set up
the URL of the database.

73
00:03:23,044 --> 00:03:26,561
Well it's that host name
there that's significant here.

74
00:03:26,561 --> 00:03:30,144
That must match the
name of this container.

75
00:03:30,144 --> 00:03:32,065
We also had a couple of command
line arguments to set here

76
00:03:32,065 --> 00:03:32,898
so -e

77
00:03:34,885 --> 00:03:36,552
MySQL root password,

78
00:03:38,403 --> 00:03:41,754
I think we set equal to password.

79
00:03:41,754 --> 00:03:45,254
And another command line argument -e MySQL

80
00:03:47,919 --> 00:03:51,320
_database, I've gone off
the end of the screen now

81
00:03:51,320 --> 00:03:53,259
which I don't normally like to do

82
00:03:53,259 --> 00:03:55,259
but we set that equal to

83
00:03:57,143 --> 00:03:58,643
the name fleetman.

84
00:03:59,540 --> 00:04:01,682
Now I think they're all
the arguments I need

85
00:04:01,682 --> 00:04:04,840
but what a horrible long command.

86
00:04:04,840 --> 00:04:08,584
It's Monday morning, I need
to get working on this project

87
00:04:08,584 --> 00:04:10,843
and I've got to remember all of that.

88
00:04:10,843 --> 00:04:12,543
But I am improvising here

89
00:04:12,543 --> 00:04:14,274
so i might have even forgotten something,

90
00:04:14,274 --> 00:04:16,584
let's see if that works.

91
00:04:16,584 --> 00:04:18,302
So we can check its logs,

92
00:04:18,302 --> 00:04:20,302
Docker container logs -f

93
00:04:21,762 --> 00:04:23,741
and I don't need the
ID of the container now

94
00:04:23,741 --> 00:04:25,854
because I've given it a name

95
00:04:25,854 --> 00:04:28,415
so I can just use database.

96
00:04:28,415 --> 00:04:30,997
Well it's the usual kind of MySQL logging,

97
00:04:30,997 --> 00:04:32,636
that looks okay.

98
00:04:32,636 --> 00:04:34,938
So that's container 1 up and running.

99
00:04:34,938 --> 00:04:37,679
Now we've got to start
the other container,

100
00:04:37,679 --> 00:04:39,478
so that will be Docker,

101
00:04:39,478 --> 00:04:41,040
I hope you're bored at this point,

102
00:04:41,040 --> 00:04:43,281
Docker container run.

103
00:04:43,281 --> 00:04:46,456
So this is going to be
our image called virtual

104
00:04:46,456 --> 00:04:49,039
pair programmers forward slash,

105
00:04:50,102 --> 00:04:51,861
now in the previous chapter on maven

106
00:04:51,861 --> 00:04:54,479
I gave my image a new name

107
00:04:54,479 --> 00:04:58,419
and the image I used was
fleetman -production.

108
00:04:58,419 --> 00:05:00,341
If you're confused at this point,

109
00:05:00,341 --> 00:05:01,617
I've done that purely

110
00:05:01,617 --> 00:05:03,343
so that I can make changes to that image

111
00:05:03,343 --> 00:05:05,798
and push the changes to Docker hub

112
00:05:05,798 --> 00:05:08,115
without it affecting any of our viewers

113
00:05:08,115 --> 00:05:10,704
on modulation 1 of this course.

114
00:05:10,704 --> 00:05:12,502
If you're following along with me,

115
00:05:12,502 --> 00:05:15,336
you've probably called
that image fleetman -webapp

116
00:05:15,336 --> 00:05:17,836
and you can continue to do so.

117
00:05:17,836 --> 00:05:20,096
So that's the name of the
image that I'm running

118
00:05:20,096 --> 00:05:22,318
but I'm going to need between the run

119
00:05:22,318 --> 00:05:26,499
and the image another
stack of arguments -d

120
00:05:26,499 --> 00:05:28,519
to run this detached.

121
00:05:28,519 --> 00:05:31,079
I will need to connect
it to the same network

122
00:05:31,079 --> 00:05:32,746
so fleetman network.

123
00:05:34,115 --> 00:05:37,197
So --network fleetman network.

124
00:05:37,197 --> 00:05:40,135
I'll need to give it a name, --name,

125
00:05:40,135 --> 00:05:43,139
this is going to be fleetman -webapp.

126
00:05:43,139 --> 00:05:45,217
I'm still using fleetman webapp

127
00:05:45,217 --> 00:05:47,233
as the container name

128
00:05:47,233 --> 00:05:49,979
even though I've changed the image name.

129
00:05:49,979 --> 00:05:53,059
And of course I'll need
to publish ports as well.

130
00:05:53,059 --> 00:05:56,226
I'll need to map port 80 to port 8080.

131
00:05:57,821 --> 00:06:00,277
Well yeah, I think that's enough.

132
00:06:00,277 --> 00:06:02,944
I'm getting a little bored here.

133
00:06:04,282 --> 00:06:05,762
Okay, that's up and running,

134
00:06:05,762 --> 00:06:08,179
so again I can check the logs

135
00:06:10,238 --> 00:06:11,238
for fleetman

136
00:06:12,676 --> 00:06:13,509
webapp.

137
00:06:15,579 --> 00:06:17,401
I'm going across to local host,

138
00:06:17,401 --> 00:06:20,641
yep there's our development
application up and running.

139
00:06:20,641 --> 00:06:22,620
The object of this course

140
00:06:22,620 --> 00:06:26,787
is to get this running
with real live traffic data

141
00:06:27,641 --> 00:06:31,322
rather than this rather
weird random chaotic data.

142
00:06:31,322 --> 00:06:33,882
Well I hope you were
really bored by that demo

143
00:06:33,882 --> 00:06:35,960
and I didn't enjoy doing it.

144
00:06:35,960 --> 00:06:37,400
I was convinced I was going to forget

145
00:06:37,400 --> 00:06:39,158
a command line property

146
00:06:39,158 --> 00:06:43,901
and I confess, I did forget
a few command line properties

147
00:06:43,901 --> 00:06:46,018
and had to re-record the video.

148
00:06:46,018 --> 00:06:48,035
A very tedious setup.

149
00:06:48,035 --> 00:06:51,320
So, I'm finally going to get to the point.

150
00:06:51,320 --> 00:06:54,914
We have a tool called Docker compose.

151
00:06:54,914 --> 00:06:57,119
And Docker compose will allow us to write

152
00:06:57,119 --> 00:06:59,638
a fairly simple text file

153
00:06:59,638 --> 00:07:01,821
and that text file is going to contain

154
00:07:01,821 --> 00:07:04,034
really all of the information

155
00:07:04,034 --> 00:07:06,779
that I've just been typing
through the command line.

156
00:07:06,779 --> 00:07:09,019
It's all of the configuration data

157
00:07:09,019 --> 00:07:11,742
for all of the containers that we need

158
00:07:11,742 --> 00:07:14,912
to run our development environment.

159
00:07:14,912 --> 00:07:16,419
Now the first problem

160
00:07:16,419 --> 00:07:20,861
is Docker compose is a
separate tool from Docker.

161
00:07:20,861 --> 00:07:22,817
And depending on what
platform you're running on,

162
00:07:22,817 --> 00:07:27,201
you may or may not have
Docker compose installed.

163
00:07:27,201 --> 00:07:29,877
If on your command line,
you do a Docker -compose,

164
00:07:29,877 --> 00:07:33,877
that's all one word with
a hyphen in the middle,

165
00:07:35,779 --> 00:07:38,029
followed by -v for version,

166
00:07:40,098 --> 00:07:43,072
if you get back a version
number like I am here,

167
00:07:43,072 --> 00:07:45,080
then excellent you are good to go

168
00:07:45,080 --> 00:07:47,235
with the rest of this chapter.

169
00:07:47,235 --> 00:07:49,021
If however you don't get that,

170
00:07:49,021 --> 00:07:51,458
and I know for example you
don't get this installed

171
00:07:51,458 --> 00:07:53,979
on a Linux based installation,

172
00:07:53,979 --> 00:07:55,999
then you are going to have to instal

173
00:07:55,999 --> 00:07:57,855
Docker compose manually.

174
00:07:57,855 --> 00:08:00,597
You'll find full details on
how to instal Docker compose

175
00:08:00,597 --> 00:08:03,395
at the URL you can see here.

176
00:08:03,395 --> 00:08:06,818
And if we scroll down to
this section with the tabs,

177
00:08:06,818 --> 00:08:10,082
I'm on the Mac tab and this confirms

178
00:08:10,082 --> 00:08:12,445
that Docker for Mac and Docker toolbox

179
00:08:12,445 --> 00:08:14,445
already includes compose

180
00:08:16,270 --> 00:08:19,759
and the same information
is on the Windows tab

181
00:08:19,759 --> 00:08:22,116
so you don't need to do anything,

182
00:08:22,116 --> 00:08:25,041
but on Linux, you will
need to do a few steps.

183
00:08:25,041 --> 00:08:29,360
You'll be doing a curl
to download a script

184
00:08:29,360 --> 00:08:32,914
and then you'll be applying
permissions to that script

185
00:08:32,914 --> 00:08:35,496
and you'll be installing it into your user

186
00:08:35,496 --> 00:08:37,516
local bin directory.

187
00:08:37,516 --> 00:08:39,339
So the end of that, you'll be able to do

188
00:08:39,339 --> 00:08:42,700
Docker compose --version and
you'll get the same results

189
00:08:42,700 --> 00:08:44,198
I just did.

190
00:08:44,198 --> 00:08:45,841
So Docker compose is going to allow me

191
00:08:45,841 --> 00:08:48,877
to write a text file which
defines the configuration

192
00:08:48,877 --> 00:08:51,710
of my entire running architecture.

193
00:08:52,817 --> 00:08:56,757
You can store this text
file anywhere you like.

194
00:08:56,757 --> 00:08:58,960
Just to keep things
simple, I'm going to put it

195
00:08:58,960 --> 00:09:00,960
into my eclipse project.

196
00:09:02,919 --> 00:09:06,118
So this is the fleetman webapp project.

197
00:09:06,118 --> 00:09:07,720
Normally I wouldn't really do this

198
00:09:07,720 --> 00:09:09,798
because this file for Docker compose

199
00:09:09,798 --> 00:09:12,561
is defining the configuration
of the entire architecture

200
00:09:12,561 --> 00:09:16,114
so I'm going to have a
lot of other workspaces

201
00:09:16,114 --> 00:09:20,114
that are referenced by
this Docker compose file.

202
00:09:21,100 --> 00:09:23,016
For now at least, it's not a bad idea

203
00:09:23,016 --> 00:09:24,781
to put the file in this project

204
00:09:24,781 --> 00:09:26,957
because I'm certainly up until now

205
00:09:26,957 --> 00:09:29,320
thinking of this fleetman webapp

206
00:09:29,320 --> 00:09:31,631
as being sort of the central service

207
00:09:31,631 --> 00:09:33,256
in this architecture

208
00:09:33,256 --> 00:09:35,177
so if you don't like that idea,

209
00:09:35,177 --> 00:09:38,318
you can put it anywhere you like.

210
00:09:38,318 --> 00:09:42,151
I'm going to put it in
the root of the project

211
00:09:43,020 --> 00:09:46,353
and by default, this file
is called Docker -compose

212
00:09:46,353 --> 00:09:48,103
but it is a YAML file

213
00:09:50,857 --> 00:09:52,940
so it will be Y, A, M, L.

214
00:09:54,438 --> 00:09:57,775
And my eclipse currently isn't configured

215
00:09:57,775 --> 00:10:00,516
to edit YAML files so it's popped up

216
00:10:00,516 --> 00:10:01,933
a notepad editor.

217
00:10:03,436 --> 00:10:05,317
So I can right click on the file

218
00:10:05,317 --> 00:10:09,316
and open with and I'll
just go for the text editor

219
00:10:09,316 --> 00:10:10,861
in eclipse.

220
00:10:10,861 --> 00:10:13,676
So assuming you're fairly
familiar with YAML files,

221
00:10:13,676 --> 00:10:16,039
if not it's a file that depends very much

222
00:10:16,039 --> 00:10:20,122
on indenting and you need
to indent using spaces.

223
00:10:21,321 --> 00:10:23,498
So all I'm going to do in this file then

224
00:10:23,498 --> 00:10:26,098
is define for this system we have two,

225
00:10:26,098 --> 00:10:28,658
we need two containers at runtime

226
00:10:28,658 --> 00:10:31,178
and we need them to connect
to a particular network.

227
00:10:31,178 --> 00:10:33,517
It's really quite simple.

228
00:10:33,517 --> 00:10:36,657
Oh well, nothing in life is that simple.

229
00:10:36,657 --> 00:10:38,994
Unfortunately, in Docker compose,

230
00:10:38,994 --> 00:10:41,581
there are at the time of recording

231
00:10:41,581 --> 00:10:44,831
three different versions of the syntax.

232
00:10:45,940 --> 00:10:48,499
What they've done here is every so often

233
00:10:48,499 --> 00:10:51,420
they've introduced
changes to Docker compose

234
00:10:51,420 --> 00:10:54,537
which have been breaking changes.

235
00:10:54,537 --> 00:10:57,428
And to allow for backwards compatibility,

236
00:10:57,428 --> 00:11:00,122
they allow you at the top of the file

237
00:11:00,122 --> 00:11:03,901
to specify which version
of the syntax you're on.

238
00:11:03,901 --> 00:11:06,466
So we can have version colon

239
00:11:06,466 --> 00:11:09,044
and then in quote marks the version number

240
00:11:09,044 --> 00:11:11,294
that this file is based on.

241
00:11:12,162 --> 00:11:14,327
Now at the time of the recording,

242
00:11:14,327 --> 00:11:18,262
the latest version of
this syntax is version 3.

243
00:11:18,262 --> 00:11:19,999
And because it's the latest,

244
00:11:19,999 --> 00:11:23,928
that's what I'm going to be
focusing on on this course.

245
00:11:23,928 --> 00:11:26,807
But if you had some old legacy scripts

246
00:11:26,807 --> 00:11:28,542
and you want them to still work,

247
00:11:28,542 --> 00:11:30,424
you can do what I've done here

248
00:11:30,424 --> 00:11:34,463
and just say that I want
to go back to version 2.

249
00:11:34,463 --> 00:11:38,528
Whichever version you go
for, and we are going for 3,

250
00:11:38,528 --> 00:11:40,865
I think it is actually mandatory

251
00:11:40,865 --> 00:11:43,425
that you have that
version line at the top.

252
00:11:43,425 --> 00:11:46,527
So in YAML, just in case
you're not familiar with YAML,

253
00:11:46,527 --> 00:11:49,504
we work with key value pairs.

254
00:11:49,504 --> 00:11:52,671
The keys end in the colon as seen here

255
00:11:54,166 --> 00:11:56,864
and then we have some kind of a value.

256
00:11:56,864 --> 00:11:58,526
Now I just suggest you follow along.

257
00:11:58,526 --> 00:12:00,864
It's not particularly exciting.

258
00:12:00,864 --> 00:12:02,398
Really all we're doing in this file

259
00:12:02,398 --> 00:12:04,063
is capturing all that information

260
00:12:04,063 --> 00:12:06,717
that we just ran on the command line.

261
00:12:06,717 --> 00:12:08,725
The first concept in Docker compose

262
00:12:08,725 --> 00:12:11,363
is that we call the
containers that we want to run

263
00:12:11,363 --> 00:12:12,196
services.

264
00:12:14,646 --> 00:12:16,184
Now I like that.

265
00:12:16,184 --> 00:12:19,064
You think of each
container as being a single

266
00:12:19,064 --> 00:12:21,920
standalone service in its own right.

267
00:12:21,920 --> 00:12:24,335
And I know I've talked a lot about that

268
00:12:24,335 --> 00:12:26,327
earlier on in the course,

269
00:12:26,327 --> 00:12:28,410
but now these concepts
are coming together.

270
00:12:28,410 --> 00:12:31,475
I hope you too are thinking of a container

271
00:12:31,475 --> 00:12:34,993
not as being some kind of
a Linux virtual machine.

272
00:12:34,993 --> 00:12:39,695
A container is some kind of
service within your system.

273
00:12:39,695 --> 00:12:41,530
So we've got two of them

274
00:12:41,530 --> 00:12:43,213
and the way that we define them

275
00:12:43,213 --> 00:12:44,751
is on the next line,

276
00:12:44,751 --> 00:12:46,737
we're going to need to indent inwards.

277
00:12:46,737 --> 00:12:49,395
You can use two or three
spaces it doesn't matter

278
00:12:49,395 --> 00:12:52,756
but you must not use tabs in YAML.

279
00:12:52,756 --> 00:12:55,832
And we simply declare the name
of the service that we want.

280
00:12:55,832 --> 00:12:58,254
So we have two so far,

281
00:12:58,254 --> 00:13:00,504
one called fleetman -webapp

282
00:13:04,691 --> 00:13:06,352
and then at the same level

283
00:13:06,352 --> 00:13:09,051
we have one called database.

284
00:13:09,051 --> 00:13:11,634
So these are the names of the services.

285
00:13:11,634 --> 00:13:14,252
Notice you don't put name colon

286
00:13:14,252 --> 00:13:16,087
which often surprises me

287
00:13:16,087 --> 00:13:18,252
but we do need a colon
at the end of the name

288
00:13:18,252 --> 00:13:20,133
because we're then going to go ahead

289
00:13:20,133 --> 00:13:21,793
for each of the services and define all

290
00:13:21,793 --> 00:13:23,848
of their configuration properties.

291
00:13:23,848 --> 00:13:25,793
So underneath fleetman webapp

292
00:13:25,793 --> 00:13:27,935
we'll need to indent again.

293
00:13:27,935 --> 00:13:29,572
All you've really got
to do is just think back

294
00:13:29,572 --> 00:13:31,772
to all of the command line arguments

295
00:13:31,772 --> 00:13:35,017
that we supplied for the webapp.

296
00:13:35,017 --> 00:13:37,035
Of course we need to say what image

297
00:13:37,035 --> 00:13:40,234
that this service is
going to be formed from.

298
00:13:40,234 --> 00:13:42,632
So we have the image key

299
00:13:42,632 --> 00:13:45,288
and the value for that
is the name of the image

300
00:13:45,288 --> 00:13:46,493
we're running.

301
00:13:46,493 --> 00:13:48,967
Again, I'm using fleetman -production,

302
00:13:48,967 --> 00:13:52,395
you're probably using fleetman webapp.

303
00:13:52,395 --> 00:13:54,154
We need to connect the services container

304
00:13:54,154 --> 00:13:55,237
to a network.

305
00:13:56,171 --> 00:13:58,338
So we have a networks key.

306
00:13:59,207 --> 00:14:02,248
Now notice it's a plural here

307
00:14:02,248 --> 00:14:04,170
because a container can be connected

308
00:14:04,170 --> 00:14:06,491
to multiple networks.

309
00:14:06,491 --> 00:14:08,192
And for that reason,

310
00:14:08,192 --> 00:14:09,893
for the first time in this file,

311
00:14:09,893 --> 00:14:12,060
we need to specify a list.

312
00:14:12,935 --> 00:14:16,255
A list in YAML, I'll
do an indent in there,

313
00:14:16,255 --> 00:14:19,672
and a list element is preceded by a dash.

314
00:14:20,673 --> 00:14:25,375
So we're going to connect
it to the fleetman network

315
00:14:25,375 --> 00:14:28,777
and if we were to connect
it to more networks,

316
00:14:28,777 --> 00:14:32,416
we'd just add more elements to that list.

317
00:14:32,416 --> 00:14:34,151
We only need the one,

318
00:14:34,151 --> 00:14:37,473
but you still need to
declare this as a list.

319
00:14:37,473 --> 00:14:40,834
We also did port mappings
on the command line

320
00:14:40,834 --> 00:14:44,293
and we do that using the ports key.

321
00:14:44,293 --> 00:14:47,614
And again, this is going to be a list.

322
00:14:47,614 --> 00:14:50,534
And the elements of this
list key value pairs again

323
00:14:50,534 --> 00:14:54,272
exactly is on the command line actually.

324
00:14:54,272 --> 00:14:58,439
We're mapping port 80 to
port 8080 in the container.

325
00:15:00,071 --> 00:15:01,795
Key value pair.

326
00:15:01,795 --> 00:15:04,936
And we could add more
port mappings if required.

327
00:15:04,936 --> 00:15:06,568
And I think that's all the elements

328
00:15:06,568 --> 00:15:08,291
that we have on the command line.

329
00:15:08,291 --> 00:15:09,672
Let me remind myself of that,

330
00:15:09,672 --> 00:15:13,254
here is the run command
for the fleetman webapp.

331
00:15:13,254 --> 00:15:14,793
The -d is not relevant

332
00:15:14,793 --> 00:15:18,055
but we've connected our
container service to a network.

333
00:15:18,055 --> 00:15:20,453
We've given it a name,

334
00:15:20,453 --> 00:15:22,537
remember the name comes from here.

335
00:15:22,537 --> 00:15:24,006
We've mapped the ports

336
00:15:24,006 --> 00:15:26,728
and we've declared the
image that we want to run.

337
00:15:26,728 --> 00:15:28,893
If you're bored of
listening to me droning on,

338
00:15:28,893 --> 00:15:30,790
you could pause the video at this point

339
00:15:30,790 --> 00:15:33,636
and complete the job for the database.

340
00:15:33,636 --> 00:15:35,813
Or if you want to follow along with me,

341
00:15:35,813 --> 00:15:39,336
it's going to be the
image is simple this time,

342
00:15:39,336 --> 00:15:42,494
it's the standard MySQL image.

343
00:15:42,494 --> 00:15:45,449
We have the networks exactly the same,

344
00:15:45,449 --> 00:15:48,782
we'll be connecting to fleetman network.

345
00:15:50,407 --> 00:15:52,194
We don't need any port mappings in here

346
00:15:52,194 --> 00:15:53,511
but what we do need

347
00:15:53,511 --> 00:15:56,647
are those environment variables.

348
00:15:56,647 --> 00:15:59,594
So how do we add in environment variables.

349
00:15:59,594 --> 00:16:01,673
Well I should be showing you
the reference manual here

350
00:16:01,673 --> 00:16:04,896
and on the same page
that I showed you before,

351
00:16:04,896 --> 00:16:07,014
there is on the left-hand side a link

352
00:16:07,014 --> 00:16:09,412
to the compose file reference.

353
00:16:09,412 --> 00:16:11,274
And these are the different versions

354
00:16:11,274 --> 00:16:13,110
that I've talked about before.

355
00:16:13,110 --> 00:16:16,150
Because we're working on
version 3 I'll follow that link.

356
00:16:16,150 --> 00:16:18,166
Okay now on this page it's quite a long

357
00:16:18,166 --> 00:16:22,391
single page of all of
these valid key value pairs

358
00:16:22,391 --> 00:16:24,493
that you can specify in this file.

359
00:16:24,493 --> 00:16:26,967
But over on the right-hand side, usefully,

360
00:16:26,967 --> 00:16:29,230
there's an index here.

361
00:16:29,230 --> 00:16:30,709
Now we're looking for how to specify

362
00:16:30,709 --> 00:16:34,611
environment variables and just
with a quick look down here

363
00:16:34,611 --> 00:16:38,966
I can see there is a key
there called environment.

364
00:16:38,966 --> 00:16:41,775
And this looks like exactly what we need.

365
00:16:41,775 --> 00:16:44,695
Confusingly possibly depending
on how familiar you are

366
00:16:44,695 --> 00:16:47,696
with YAML there are two
ways of doing it in fact.

367
00:16:47,696 --> 00:16:50,732
You can either use an
array or a dictionary.

368
00:16:50,732 --> 00:16:53,048
And it's actually the other way around,

369
00:16:53,048 --> 00:16:54,255
this is the array version

370
00:16:54,255 --> 00:16:58,772
where they've specified
the values as a list.

371
00:16:58,772 --> 00:17:02,574
The values in the list
have equals in them.

372
00:17:02,574 --> 00:17:05,754
Alternatively, you can treat
the environment variables

373
00:17:05,754 --> 00:17:07,194
as keys

374
00:17:07,194 --> 00:17:11,351
so we have here a set of key value pairs.

375
00:17:11,351 --> 00:17:14,573
It's obviously up to you
which of the two you use.

376
00:17:14,573 --> 00:17:17,685
I always go for the list version,

377
00:17:17,685 --> 00:17:21,713
this was the array version
so we have environment

378
00:17:21,713 --> 00:17:23,287
and then a list

379
00:17:23,287 --> 00:17:24,454
so we have the

380
00:17:26,833 --> 00:17:29,589
keep that one in line, we have MySQL

381
00:17:29,589 --> 00:17:32,088
underscore root password

382
00:17:32,088 --> 00:17:35,088
is going to be set equal to password

383
00:17:36,932 --> 00:17:39,932
and we have MySQL database set equal

384
00:17:41,389 --> 00:17:42,389
to fleetman.

385
00:17:43,794 --> 00:17:46,544
And that's it for that container.

386
00:17:47,974 --> 00:17:50,371
The other thing we're aiming
for with a Docker compose file

387
00:17:50,371 --> 00:17:53,645
is we should be able
to run this file cold.

388
00:17:53,645 --> 00:17:56,548
By which I mean even if we
haven't configured anything

389
00:17:56,548 --> 00:17:58,759
in our local environment,

390
00:17:58,759 --> 00:18:01,418
this file will be able to run.

391
00:18:01,418 --> 00:18:03,857
And what I mean by that is I don't want

392
00:18:03,857 --> 00:18:05,963
to have to go to the
bother of manually creating

393
00:18:05,963 --> 00:18:06,963
this network

394
00:18:08,041 --> 00:18:09,958
before I run this file.

395
00:18:11,298 --> 00:18:13,643
And for that reason we
can very easily define

396
00:18:13,643 --> 00:18:17,777
the networks as well
right here in this file.

397
00:18:17,777 --> 00:18:21,200
We do that by we close the services area

398
00:18:21,200 --> 00:18:25,741
by moving the indent back
to the far left-hand side

399
00:18:25,741 --> 00:18:29,381
and we have a new key
in here called networks.

400
00:18:29,381 --> 00:18:31,759
And underneath here we will just declare

401
00:18:31,759 --> 00:18:34,259
all of the networks that
we want for our system

402
00:18:34,259 --> 00:18:37,342
as again a series of key value pairs.

403
00:18:38,860 --> 00:18:41,293
The key is going to be
the name of the networks

404
00:18:41,293 --> 00:18:43,626
so we have fleetman network.

405
00:18:44,741 --> 00:18:48,258
Followed by a colon and the value is going

406
00:18:48,258 --> 00:18:51,138
to be any special
configurations that we need

407
00:18:51,138 --> 00:18:53,197
for the network.

408
00:18:53,197 --> 00:18:55,919
Well, we haven't been
configuring these networks,

409
00:18:55,919 --> 00:18:59,299
we've just been doing
Docker network create

410
00:18:59,299 --> 00:19:00,632
fleetman network

411
00:19:01,540 --> 00:19:03,756
and for that reason we
don't need to supply

412
00:19:03,756 --> 00:19:05,839
anything after the colon.

413
00:19:07,055 --> 00:19:09,202
If we wanted other networks

414
00:19:09,202 --> 00:19:10,785
we would just go on

415
00:19:13,677 --> 00:19:15,722
and declare further ones.

416
00:19:15,722 --> 00:19:18,183
So again going back to what
the reference manual said,

417
00:19:18,183 --> 00:19:19,766
this is not a list,

418
00:19:20,656 --> 00:19:22,978
it's actually an array in YAML.

419
00:19:22,978 --> 00:19:26,001
It's not an array, it's a dictionary

420
00:19:26,001 --> 00:19:28,841
meaning a set of key value pairs.

421
00:19:28,841 --> 00:19:31,855
That's why you don't need the dashes here.

422
00:19:31,855 --> 00:19:33,862
Okay well we don't need
that second network

423
00:19:33,862 --> 00:19:35,343
so I'll get rid of that.

424
00:19:35,343 --> 00:19:38,123
We just need the one fleetman network.

425
00:19:38,123 --> 00:19:40,103
So I hope you're beginning to get a feel

426
00:19:40,103 --> 00:19:42,819
for what this Docker compose is all about.

427
00:19:42,819 --> 00:19:44,782
In this single file now

428
00:19:44,782 --> 00:19:47,243
I have the configuration
of all of the containers

429
00:19:47,243 --> 00:19:48,974
for this system.

430
00:19:48,974 --> 00:19:51,533
Meaning that I'll be able
to run this system now

431
00:19:51,533 --> 00:19:53,366
with just one command.

432
00:19:54,441 --> 00:19:56,334
This script now is nearly ready to run

433
00:19:56,334 --> 00:19:57,802
but before we do that,

434
00:19:57,802 --> 00:20:00,101
I want to address one
tricky problem that we have

435
00:20:00,101 --> 00:20:02,382
with Docker compose.

436
00:20:02,382 --> 00:20:04,495
Think about these two containers

437
00:20:04,495 --> 00:20:06,858
and think about the
order that we want them

438
00:20:06,858 --> 00:20:08,557
to start up in.

439
00:20:08,557 --> 00:20:10,823
Remember that the fleetman webapp

440
00:20:10,823 --> 00:20:14,219
is a regular spring boot application.

441
00:20:14,219 --> 00:20:18,097
And you know well that when
that application starts up,

442
00:20:18,097 --> 00:20:20,198
one of the first things it's going to do

443
00:20:20,198 --> 00:20:23,373
is it's going to connect to the database.

444
00:20:23,373 --> 00:20:26,055
If you're not familiar
with spring boot then

445
00:20:26,055 --> 00:20:29,281
just accept that spring boot will look

446
00:20:29,281 --> 00:20:31,866
for a database connection on startup.

447
00:20:31,866 --> 00:20:34,304
So clearly if this container

448
00:20:34,304 --> 00:20:36,054
is not up and running

449
00:20:37,381 --> 00:20:40,602
and servicing database requests

450
00:20:40,602 --> 00:20:43,586
then unfortunately the webapplication

451
00:20:43,586 --> 00:20:45,566
is going to fail.

452
00:20:45,566 --> 00:20:48,062
Now at the time of the recording,

453
00:20:48,062 --> 00:20:50,686
as far as I know, there's no way

454
00:20:50,686 --> 00:20:52,259
in a spring boot application

455
00:20:52,259 --> 00:20:54,743
to tell this application try again

456
00:20:54,743 --> 00:20:57,181
in five seconds or something.

457
00:20:57,181 --> 00:21:00,931
The spring boot application
will simply fail.

458
00:21:02,080 --> 00:21:04,664
And it won't start up again.

459
00:21:04,664 --> 00:21:06,945
So we have a bit of a problem here

460
00:21:06,945 --> 00:21:09,024
and it would be nice if somehow

461
00:21:09,024 --> 00:21:11,456
we could tell Docker compose

462
00:21:11,456 --> 00:21:15,705
don't start this container
until this container

463
00:21:15,705 --> 00:21:18,660
is up and running and the database

464
00:21:18,660 --> 00:21:20,410
is fully operational.

465
00:21:22,305 --> 00:21:24,662
And it turns out that this
is quite a nasty problem

466
00:21:24,662 --> 00:21:26,781
in Docker compose.

467
00:21:26,781 --> 00:21:28,901
I'm back on the reference manual here

468
00:21:28,901 --> 00:21:32,161
under the chapter called
control startup order

469
00:21:32,161 --> 00:21:35,703
and at first this looks very promising.

470
00:21:35,703 --> 00:21:39,006
We can control the
order of service startup

471
00:21:39,006 --> 00:21:41,256
with the depends on option.

472
00:21:42,659 --> 00:21:47,202
And compose will start
containers in dependency order.

473
00:21:47,202 --> 00:21:49,924
Now before we look any
further into this document,

474
00:21:49,924 --> 00:21:51,940
I'll show you how that works.

475
00:21:51,940 --> 00:21:53,821
We know that this webapp container

476
00:21:53,821 --> 00:21:56,665
needs to wait until the
database container is started

477
00:21:56,665 --> 00:22:00,543
so we can put into here
as another property

478
00:22:00,543 --> 00:22:01,376
depends_on

479
00:22:04,763 --> 00:22:07,138
and then this is going to be another list

480
00:22:07,138 --> 00:22:10,336
because we can depend
on multiple containers

481
00:22:10,336 --> 00:22:13,215
and we just specify that this container

482
00:22:13,215 --> 00:22:16,257
depends on the database container.

483
00:22:16,257 --> 00:22:18,241
So what this means in practise is simply

484
00:22:18,241 --> 00:22:21,023
that it will start the
database container first.

485
00:22:21,023 --> 00:22:24,324
So you might think that's problem solved.

486
00:22:24,324 --> 00:22:27,205
Well, no and the second paragraph here

487
00:22:27,205 --> 00:22:28,923
tells a story.

488
00:22:28,923 --> 00:22:31,002
The compose tool will not wait

489
00:22:31,002 --> 00:22:33,169
until a container is ready

490
00:22:34,583 --> 00:22:38,245
before proceeding with
starting the other containers.

491
00:22:38,245 --> 00:22:42,401
In fact, it only waits until
the container is running.

492
00:22:42,401 --> 00:22:44,899
Now think about the life cycle
of what's going to happen.

493
00:22:44,899 --> 00:22:47,801
The database container starts running

494
00:22:47,801 --> 00:22:50,204
and at the point it started running,

495
00:22:50,204 --> 00:22:53,037
it then has to start the database.

496
00:22:53,984 --> 00:22:56,921
And a MySQL database
typically takes a few seconds

497
00:22:56,921 --> 00:22:58,171
to get started.

498
00:22:59,162 --> 00:23:01,402
Now do read the documents
if you're interested

499
00:23:01,402 --> 00:23:02,881
but what they're saying here

500
00:23:02,881 --> 00:23:04,640
is that they don't believe

501
00:23:04,640 --> 00:23:06,724
that Docker compose should be responsible

502
00:23:06,724 --> 00:23:09,380
for determining the health of a container

503
00:23:09,380 --> 00:23:13,463
and whether a container
is actually ready or not.

504
00:23:15,137 --> 00:23:18,208
And they believe as stated here

505
00:23:18,208 --> 00:23:20,930
that in a distributed system like this

506
00:23:20,930 --> 00:23:24,349
actually all of the services in our system

507
00:23:24,349 --> 00:23:27,043
should be resilient to other services

508
00:23:27,043 --> 00:23:29,533
being unavailable for any reason.

509
00:23:29,533 --> 00:23:31,333
In other words, your
services should be able

510
00:23:31,333 --> 00:23:35,500
to keep retrying if something
becomes unavailable.

511
00:23:36,610 --> 00:23:38,589
So to put it another way,

512
00:23:38,589 --> 00:23:41,370
what they're saying is really
in our specific example,

513
00:23:41,370 --> 00:23:44,609
spring MVC should be resilient enough

514
00:23:44,609 --> 00:23:49,126
to say oh there's no database
connection available,

515
00:23:49,126 --> 00:23:51,205
well that's probably because the database

516
00:23:51,205 --> 00:23:55,650
is just starting up so I will
retry in a few seconds time.

517
00:23:55,650 --> 00:23:58,013
Now as far as I know at
the time of recording,

518
00:23:58,013 --> 00:24:01,513
spring boot does not support that feature.

519
00:24:02,749 --> 00:24:07,550
And for evidence, I found
this GitHub issue #4779

520
00:24:07,550 --> 00:24:10,406
still open at the time of recording.

521
00:24:10,406 --> 00:24:12,486
This was raised by Dave Syer

522
00:24:12,486 --> 00:24:15,684
who is one of the chief
architects of spring boot

523
00:24:15,684 --> 00:24:17,605
and spring cloud

524
00:24:17,605 --> 00:24:19,613
and he's basically saying here

525
00:24:19,613 --> 00:24:21,209
exactly what we've seen.

526
00:24:21,209 --> 00:24:23,769
He's saying that yes,
spring boot really should

527
00:24:23,769 --> 00:24:25,853
be able to retry a database connection

528
00:24:25,853 --> 00:24:28,603
if it's not available on startup.

529
00:24:29,731 --> 00:24:32,164
There's quite a lot of
discussion in this issue

530
00:24:32,164 --> 00:24:34,248
but at the time of recording,

531
00:24:34,248 --> 00:24:37,508
it's still not made it into spring boot.

532
00:24:37,508 --> 00:24:39,292
I hope it will in a later version

533
00:24:39,292 --> 00:24:41,370
and when and if it does,

534
00:24:41,370 --> 00:24:43,448
I'll re-record this video.

535
00:24:43,448 --> 00:24:45,573
But for now, this is
the best that we've got.

536
00:24:45,573 --> 00:24:50,112
This is a long-standing
issue with Docker compose

537
00:24:50,112 --> 00:24:52,829
and you might find if you search around

538
00:24:52,829 --> 00:24:55,429
for similar solutions to this problem

539
00:24:55,429 --> 00:24:58,489
you might find that Docker compose,

540
00:24:58,489 --> 00:25:01,571
this is a long question on stack overflow,

541
00:25:01,571 --> 00:25:04,154
but the one of the answers here

542
00:25:05,349 --> 00:25:08,572
appears to have a perfect solution.

543
00:25:08,572 --> 00:25:10,564
This is a Docker compose file.

544
00:25:10,564 --> 00:25:14,168
It happens to be a version
2 Docker compose file,

545
00:25:14,168 --> 00:25:17,768
but can you see that they have included

546
00:25:17,768 --> 00:25:18,935
a healthcheck.

547
00:25:20,328 --> 00:25:22,493
And this is where you can ping

548
00:25:22,493 --> 00:25:24,669
a particular network connection,

549
00:25:24,669 --> 00:25:28,551
for us it would be port 3306 for MySQL.

550
00:25:28,551 --> 00:25:30,852
And you can keep retrying

551
00:25:30,852 --> 00:25:32,831
and only when that succeeds

552
00:25:32,831 --> 00:25:34,909
will the container be deemed healthy.

553
00:25:34,909 --> 00:25:38,076
This is actually exactly what we want.

554
00:25:40,232 --> 00:25:43,267
And it is part of the
Docker compose syntax

555
00:25:43,267 --> 00:25:45,934
but it was removed in version 3.

556
00:25:48,006 --> 00:25:51,591
Just to prove that, I
have a GitHub issue here

557
00:25:51,591 --> 00:25:54,014
from the Docker compose repository

558
00:25:54,014 --> 00:25:56,067
depends on still exists in version 3

559
00:25:56,067 --> 00:25:59,848
but the healthcheck will not be ported.

560
00:25:59,848 --> 00:26:02,489
Now they haven't gone into details why

561
00:26:02,489 --> 00:26:05,607
but I think reading between the lines

562
00:26:05,607 --> 00:26:08,990
they had a lot of problem
making it work effectively.

563
00:26:08,990 --> 00:26:10,506
Now you might think well okay no problem

564
00:26:10,506 --> 00:26:13,111
well we'll just drop the
version back to version 2

565
00:26:13,111 --> 00:26:16,410
and you could go ahead then and
use the healthcheck feature.

566
00:26:16,410 --> 00:26:18,511
However I don't recommend that

567
00:26:18,511 --> 00:26:20,972
because version 2 is
effectively deprecated

568
00:26:20,972 --> 00:26:22,808
and far more importantly

569
00:26:22,808 --> 00:26:24,972
we're going to need version 3

570
00:26:24,972 --> 00:26:26,992
for many of the advanced features

571
00:26:26,992 --> 00:26:28,652
that we're going to be studying

572
00:26:28,652 --> 00:26:31,636
in the next chapter and
onwards on this course.

573
00:26:31,636 --> 00:26:34,196
So I'm afraid we're rather
stuck with this situation.

574
00:26:34,196 --> 00:26:36,111
So what I suggest we do

575
00:26:36,111 --> 00:26:38,834
is that we just try running this.

576
00:26:38,834 --> 00:26:40,494
What I've usually found

577
00:26:40,494 --> 00:26:44,151
is because the database
starts up quite quickly,

578
00:26:44,151 --> 00:26:46,711
by the time the webapp
has got up and running

579
00:26:46,711 --> 00:26:48,632
and needs a connection

580
00:26:48,632 --> 00:26:51,251
the database is actually ready in time.

581
00:26:51,251 --> 00:26:52,911
I'm really worried about this

582
00:26:52,911 --> 00:26:55,634
because what I've just
described is a race condition.

583
00:26:55,634 --> 00:26:58,292
I'm saying it's always worked for me.

584
00:26:58,292 --> 00:27:02,292
I am slightly concerned that
it might not work for you.

585
00:27:02,292 --> 00:27:05,456
So let's go ahead and try it.

586
00:27:05,456 --> 00:27:08,376
So at last I can show you
how to run Docker compose.

587
00:27:08,376 --> 00:27:10,170
It is very simply.

588
00:27:10,170 --> 00:27:12,153
Docker compose

589
00:27:12,153 --> 00:27:14,236
and then the argument up.

590
00:27:15,574 --> 00:27:16,791
We don't need to tell it

591
00:27:16,791 --> 00:27:18,575
what the Docker compose filename is

592
00:27:18,575 --> 00:27:21,936
because the default is
Docker compose.yaml.

593
00:27:21,936 --> 00:27:24,634
There are several options we
can add to the command line

594
00:27:24,634 --> 00:27:26,332
which I'll come to later,

595
00:27:26,332 --> 00:27:27,956
but for now

596
00:27:27,956 --> 00:27:29,789
that should be enough.

597
00:27:44,535 --> 00:27:46,554
Now I've had a few problems
recording this off camera

598
00:27:46,554 --> 00:27:48,331
and I think I've worked out,

599
00:27:48,331 --> 00:27:51,931
the first time you run Docker compose,

600
00:27:51,931 --> 00:27:56,493
because it's starting
completely clean containers,

601
00:27:56,493 --> 00:28:00,160
I don't know if you saw
that flash by there.

602
00:28:02,070 --> 00:28:04,852
Now if I go up, I notice quite a lot

603
00:28:04,852 --> 00:28:07,769
of connection refused flashing past

604
00:28:10,070 --> 00:28:12,335
and that will be because I have been bit

605
00:28:12,335 --> 00:28:14,170
by that race condition.

606
00:28:14,170 --> 00:28:16,335
I'm guessing that if
you're following along,

607
00:28:16,335 --> 00:28:19,990
you will have also have
the same race condition.

608
00:28:19,990 --> 00:28:21,687
And I think it's simply because

609
00:28:21,687 --> 00:28:25,111
we're starting brand new containers here

610
00:28:25,111 --> 00:28:27,051
and can you see here
in the database logging

611
00:28:27,051 --> 00:28:30,574
that the first the database starts up,

612
00:28:30,574 --> 00:28:32,566
it has to do quite a lot of work

613
00:28:32,566 --> 00:28:34,807
with these generating private keys

614
00:28:34,807 --> 00:28:37,232
and it's just not really relevant

615
00:28:37,232 --> 00:28:39,126
but what's relevant is it has quite a long

616
00:28:39,126 --> 00:28:40,855
startup sequence.

617
00:28:40,855 --> 00:28:44,373
You'll notice that the logs are interwoven

618
00:28:44,373 --> 00:28:47,607
so that's a clear sign that the containers

619
00:28:47,607 --> 00:28:49,754
are starting up in parallel.

620
00:28:49,754 --> 00:28:52,314
And it is just as I mentioned before.

621
00:28:52,314 --> 00:28:55,832
The webapp is trying to
make a database connection

622
00:28:55,832 --> 00:28:58,914
before the database is
up and running fully.

623
00:28:58,914 --> 00:29:02,605
Now, I've noticed that if that happens,

624
00:29:02,605 --> 00:29:04,938
we can simply do a control C

625
00:29:06,426 --> 00:29:09,502
which will stop those containers

626
00:29:09,502 --> 00:29:12,638
and now if we re-run Docker compose up,

627
00:29:12,638 --> 00:29:16,666
the big difference is
it isn't having to start

628
00:29:16,666 --> 00:29:18,878
new containers from scratch,

629
00:29:18,878 --> 00:29:22,401
it's just restarting
those stopped containers.

630
00:29:22,401 --> 00:29:24,984
And that means the database
gets up and running

631
00:29:24,984 --> 00:29:26,401
much more quickly

632
00:29:27,264 --> 00:29:29,600
and it's actually taking
less than a second

633
00:29:29,600 --> 00:29:32,641
and then the webapp is able
to start up successfully

634
00:29:32,641 --> 00:29:34,301
and this time around,

635
00:29:34,301 --> 00:29:36,718
I'm seeing much cleaner logs.

636
00:29:37,726 --> 00:29:39,520
If you've had the same problem

637
00:29:39,520 --> 00:29:41,504
and you've just run Docker compose

638
00:29:41,504 --> 00:29:42,962
up for a second time

639
00:29:42,962 --> 00:29:44,565
and you still have the problem

640
00:29:44,565 --> 00:29:46,364
then don't panic.

641
00:29:46,364 --> 00:29:48,220
In a few minutes I'll be showing you

642
00:29:48,220 --> 00:29:50,461
how to run your containers
in the background

643
00:29:50,461 --> 00:29:51,900
and when you do that,

644
00:29:51,900 --> 00:29:54,003
rather than pressing control C,

645
00:29:54,003 --> 00:29:56,662
which is going to stop
all of the containers,

646
00:29:56,662 --> 00:29:58,398
you'll see that we can just re-run

647
00:29:58,398 --> 00:30:00,544
the Docker compose up
command as many times

648
00:30:00,544 --> 00:30:01,916
as we like

649
00:30:01,916 --> 00:30:04,447
and that will restart any containers

650
00:30:04,447 --> 00:30:06,140
that have stopped

651
00:30:06,140 --> 00:30:08,381
but it won't affect any containers

652
00:30:08,381 --> 00:30:09,886
that are still running.

653
00:30:09,886 --> 00:30:11,964
So although I'm moaning about this,

654
00:30:11,964 --> 00:30:15,041
in practise, this race condition at worst

655
00:30:15,041 --> 00:30:18,042
is just the case that
we're going to have to

656
00:30:18,042 --> 00:30:20,800
run the Docker compose up command twice.

657
00:30:20,800 --> 00:30:23,197
So I hope your containers
are up and running

658
00:30:23,197 --> 00:30:25,281
and we can check on the browser

659
00:30:25,281 --> 00:30:28,665
that yeah we have a
functioning webapplication.

660
00:30:28,665 --> 00:30:30,842
All that remains in this chapter now

661
00:30:30,842 --> 00:30:32,665
is to show you what
kinds of things we can do

662
00:30:32,665 --> 00:30:34,558
with Docker compose.

663
00:30:34,558 --> 00:30:36,403
You've seen that the default

664
00:30:36,403 --> 00:30:38,046
is to start up in the foreground

665
00:30:38,046 --> 00:30:39,642
and if I do a control C,

666
00:30:39,642 --> 00:30:41,918
that's going to stop the two containers

667
00:30:41,918 --> 00:30:43,387
and therefore of course

668
00:30:43,387 --> 00:30:46,881
the webapplication will
now be out of service.

669
00:30:46,881 --> 00:30:48,884
Really everything that we've been doing

670
00:30:48,884 --> 00:30:50,741
on the course so far

671
00:30:50,741 --> 00:30:52,402
such as running in the background

672
00:30:52,402 --> 00:30:54,780
or accessing logs and so on

673
00:30:54,780 --> 00:30:57,184
you can do using Docker compose.

674
00:30:57,184 --> 00:31:00,244
We can use the -d command line argument

675
00:31:00,244 --> 00:31:01,846
on Docker compose to run
everything in the background.

676
00:31:01,846 --> 00:31:04,244
The only problem with it
is I never quite remember

677
00:31:04,244 --> 00:31:05,664
where the -d goes.

678
00:31:05,664 --> 00:31:08,383
If you put it on the end, it will work,

679
00:31:08,383 --> 00:31:11,633
but Docker compose -d up does not work.

680
00:31:14,745 --> 00:31:17,501
But anyway, Docker compose up -d.

681
00:31:17,501 --> 00:31:19,585
It will tell you that the
containers are starting

682
00:31:19,585 --> 00:31:22,078
but then we're back to the command line.

683
00:31:22,078 --> 00:31:24,445
And now to monitor what's going on,

684
00:31:24,445 --> 00:31:26,945
we can use Docker compose logs

685
00:31:29,825 --> 00:31:31,963
and exactly as with the
logs command before,

686
00:31:31,963 --> 00:31:33,942
we can do -f to follow

687
00:31:33,942 --> 00:31:36,084
and then the name of the service.

688
00:31:36,084 --> 00:31:37,942
Not the name of the container,

689
00:31:37,942 --> 00:31:40,078
you've seen the container
names in Docker compose

690
00:31:40,078 --> 00:31:41,314
are mangled.

691
00:31:41,314 --> 00:31:45,481
The name of the service
would be fleetman -webapp.

692
00:31:48,193 --> 00:31:50,050
And just scrolling up, that looks like

693
00:31:50,050 --> 00:31:52,634
a healthy start of the spring application.

694
00:31:52,634 --> 00:31:54,049
Be careful here by the way.

695
00:31:54,049 --> 00:31:56,355
I did notice some exceptions
flashing past then

696
00:31:56,355 --> 00:31:59,970
but actually what we're
seeing there is the old logs.

697
00:31:59,970 --> 00:32:01,987
So it might be a surprise that,

698
00:32:01,987 --> 00:32:04,790
that even though we've
just restarted a container,

699
00:32:04,790 --> 00:32:07,426
we are still seeing the logs

700
00:32:07,426 --> 00:32:10,432
from the previous invocations
of this container.

701
00:32:10,432 --> 00:32:13,312
So they were the exceptions
from the demonstration

702
00:32:13,312 --> 00:32:15,425
that I did earlier.

703
00:32:15,425 --> 00:32:17,985
Of course because we're
just looking at the log here

704
00:32:17,985 --> 00:32:20,092
if I do a control C,

705
00:32:20,092 --> 00:32:22,333
the container will still be running.

706
00:32:22,333 --> 00:32:23,830
You can confirm that yeah

707
00:32:23,830 --> 00:32:27,511
the webapp is running absolutely fine.

708
00:32:27,511 --> 00:32:30,651
Of course we can check the
logs for the database as well.

709
00:32:30,651 --> 00:32:32,068
Very interesting.

710
00:32:33,374 --> 00:32:36,224
If we want to stop all of the containers,

711
00:32:36,224 --> 00:32:40,630
then you can probably
guess that the command

712
00:32:40,630 --> 00:32:42,947
is Docker compose down.

713
00:32:42,947 --> 00:32:45,431
And that will bring the whole system down.

714
00:32:45,431 --> 00:32:47,109
And notice from here down at the bottom

715
00:32:47,109 --> 00:32:49,912
as well as the containers being stopped,

716
00:32:49,912 --> 00:32:53,826
the containers are also being removed.

717
00:32:53,826 --> 00:32:56,094
So Docker compose down is a bit more

718
00:32:56,094 --> 00:32:57,825
than stopping your system.

719
00:32:57,825 --> 00:32:59,873
It's really tearing down the entire system

720
00:32:59,873 --> 00:33:03,670
and removing any trace
that it was ever there.

721
00:33:03,670 --> 00:33:06,530
So for that reason, I suspect we'll find

722
00:33:06,530 --> 00:33:08,354
and I promise this is the last time

723
00:33:08,354 --> 00:33:10,433
I'll talk about that race condition.

724
00:33:10,433 --> 00:33:13,600
If we do a Docker compose up -d again.

725
00:33:17,091 --> 00:33:19,715
Because this time around it's
creating these containers

726
00:33:19,715 --> 00:33:21,271
from scratch

727
00:33:21,271 --> 00:33:23,291
I am expecting the webapp

728
00:33:23,291 --> 00:33:24,708
to fail to start.

729
00:33:26,013 --> 00:33:27,830
Let's see if that happens.

730
00:33:27,830 --> 00:33:30,330
I can do a Docker compose logs

731
00:33:31,394 --> 00:33:34,811
and follow the logs for fleetman -webapp.

732
00:33:35,973 --> 00:33:38,052
As always with race conditions,

733
00:33:38,052 --> 00:33:39,429
it might not have happened for you,

734
00:33:39,429 --> 00:33:41,507
but yes I've got connection
failed exceptions

735
00:33:41,507 --> 00:33:44,194
and you can see at the bottom

736
00:33:44,194 --> 00:33:47,009
that the container has actually exited

737
00:33:47,009 --> 00:33:48,773
which does mean that the container

738
00:33:48,773 --> 00:33:51,109
will have been stopped.

739
00:33:51,109 --> 00:33:53,526
If I do a Docker container LS

740
00:33:54,851 --> 00:33:59,014
there's my database container
running perfectly happily.

741
00:33:59,014 --> 00:34:02,434
And if I do a Docker container LS -a,

742
00:34:02,434 --> 00:34:05,186
we can now also see that
container which failed

743
00:34:05,186 --> 00:34:08,030
and is therefore in a stopped condition.

744
00:34:08,030 --> 00:34:09,475
And the point of all that

745
00:34:09,475 --> 00:34:11,774
is if you do have this race condition,

746
00:34:11,774 --> 00:34:13,632
as long as you're running
in the background,

747
00:34:13,632 --> 00:34:15,588
it really is no big deal

748
00:34:15,588 --> 00:34:19,970
because if I now do
Docker compose up again,

749
00:34:19,970 --> 00:34:21,470
crucially with -d,

750
00:34:22,391 --> 00:34:23,930
what that will do

751
00:34:23,930 --> 00:34:26,710
is it won't change the running container

752
00:34:26,710 --> 00:34:30,495
so the database is going
to be left running happily.

753
00:34:30,495 --> 00:34:32,711
It won't be restarted.

754
00:34:32,711 --> 00:34:35,416
But it will restart the webapp

755
00:34:35,416 --> 00:34:37,752
and we know because there's
been a long time elapsed

756
00:34:37,752 --> 00:34:39,893
since we started the database

757
00:34:39,893 --> 00:34:41,554
that by now,

758
00:34:41,554 --> 00:34:43,794
the webapp should be
able to start just fine.

759
00:34:43,794 --> 00:34:46,132
So let's check that by
going back to the logs

760
00:34:46,132 --> 00:34:47,956
of the webapp.

761
00:34:47,956 --> 00:34:51,028
And yes, this time we
have a started tomcat

762
00:34:51,028 --> 00:34:54,255
down at the bottom, that's perfect.

763
00:34:54,255 --> 00:34:56,397
So although I wanted you to be aware

764
00:34:56,397 --> 00:34:58,998
of this race condition problem,

765
00:34:58,998 --> 00:35:01,076
it's not a very nice problem,

766
00:35:01,076 --> 00:35:03,189
but at worst it means
that all you have to do

767
00:35:03,189 --> 00:35:07,432
is run Docker compose up a couple of times

768
00:35:07,432 --> 00:35:09,430
if you have these problems.

769
00:35:09,430 --> 00:35:11,757
And the webapplication
is running just fine.

770
00:35:11,757 --> 00:35:13,394
So a very common thing to need to do

771
00:35:13,394 --> 00:35:17,016
is to make a change to
one of the containers

772
00:35:17,016 --> 00:35:19,256
and to need to restart that container

773
00:35:19,256 --> 00:35:21,749
without restarting everything else.

774
00:35:21,749 --> 00:35:23,315
It's actually very easy to do.

775
00:35:23,315 --> 00:35:27,255
Let's simulate a minor
change to the webapp.

776
00:35:27,255 --> 00:35:30,356
So if in eclipse you go the
source main resources template

777
00:35:30,356 --> 00:35:34,189
and the main page is
called live tracking.html

778
00:35:36,471 --> 00:35:38,296
and I'm just scrolling down

779
00:35:38,296 --> 00:35:40,393
to look for the h1 tag

780
00:35:40,393 --> 00:35:43,214
and I'm going to do a silly change on here

781
00:35:43,214 --> 00:35:44,964
to reflect an update.

782
00:35:47,253 --> 00:35:51,170
And this will be a standard
clean package build

783
00:35:52,398 --> 00:35:54,035
which if you did the previous chapter

784
00:35:54,035 --> 00:35:57,270
you will know now is going
to run a Docker build.

785
00:35:57,270 --> 00:35:59,753
If you're not using maven to do this

786
00:35:59,753 --> 00:36:03,595
then you would need to
build the jar as normal

787
00:36:03,595 --> 00:36:05,587
and then on the command line

788
00:36:05,587 --> 00:36:08,310
rebuild an image from that container.

789
00:36:08,310 --> 00:36:10,352
Okay and there's the Docker build

790
00:36:10,352 --> 00:36:11,671
and that ran successfully.

791
00:36:11,671 --> 00:36:14,137
It's warning me it was unable
to remove the previous version

792
00:36:14,137 --> 00:36:15,914
of the image and that's just because

793
00:36:15,914 --> 00:36:18,497
that image is currently in use,

794
00:36:19,894 --> 00:36:22,317
it is actually running on the webapp.

795
00:36:22,317 --> 00:36:23,913
That's not a problem.

796
00:36:23,913 --> 00:36:25,748
I hope it's fairly obvious though

797
00:36:25,748 --> 00:36:27,953
that that change will
not have taken effect

798
00:36:27,953 --> 00:36:29,875
if I do a refresh here,

799
00:36:29,875 --> 00:36:32,493
yeah we've still got the
old version of the site.

800
00:36:32,493 --> 00:36:35,854
Docker compose isn't going
to detect that change

801
00:36:35,854 --> 00:36:39,633
but it actually is very simple
to restart this container.

802
00:36:39,633 --> 00:36:42,300
You can do a Docker compose stop

803
00:36:44,951 --> 00:36:48,752
followed by the name of the
service that you want to stop

804
00:36:48,752 --> 00:36:50,355
but that's quite long winded.

805
00:36:50,355 --> 00:36:52,373
It's much easier than you might think.

806
00:36:52,373 --> 00:36:56,149
If you just recall your
Docker compose up command,

807
00:36:56,149 --> 00:36:57,994
as I mentioned before,

808
00:36:57,994 --> 00:36:59,596
that's going to check the state

809
00:36:59,596 --> 00:37:01,655
of all of your running containers

810
00:37:01,655 --> 00:37:05,035
and it will restart any that
have changed their image.

811
00:37:05,035 --> 00:37:07,896
Let's see that in action.

812
00:37:07,896 --> 00:37:11,828
Great, you can see it
recreating the webapp

813
00:37:11,828 --> 00:37:13,245
as indicated here

814
00:37:15,032 --> 00:37:17,296
but the database is up to date.

815
00:37:17,296 --> 00:37:19,672
I think we'll find now if I very quickly

816
00:37:19,672 --> 00:37:21,835
go to the webapp and go to the refresh,

817
00:37:21,835 --> 00:37:23,752
yeah the webapp is down

818
00:37:25,219 --> 00:37:27,675
and I'll run the logs.

819
00:37:27,675 --> 00:37:29,734
That's just because yeah
it's still starting up.

820
00:37:29,734 --> 00:37:32,574
It takes about 10 seconds or so

821
00:37:32,574 --> 00:37:33,824
for my computer

822
00:37:34,978 --> 00:37:36,957
and there it is up and running

823
00:37:36,957 --> 00:37:39,111
and I hope you can see now

824
00:37:39,111 --> 00:37:41,636
that our update has taken effect.

825
00:37:41,636 --> 00:37:43,720
So that might be a very
common part of your workflow

826
00:37:43,720 --> 00:37:46,059
where you're working on
maybe one microservice

827
00:37:46,059 --> 00:37:49,699
and you're constantly making
changes to that microservice

828
00:37:49,699 --> 00:37:52,136
and you want to bounce the container

829
00:37:52,136 --> 00:37:54,598
that that microservice is being run inside

830
00:37:54,598 --> 00:37:57,350
but you don't want to go
through the pain and hassle

831
00:37:57,350 --> 00:38:01,477
of starting up the
entire set of containers

832
00:38:01,477 --> 00:38:04,134
that would be absolutely awful.

833
00:38:04,134 --> 00:38:06,116
So I've talked quite a
lot about Docker compose.

834
00:38:06,116 --> 00:38:09,098
You've seen it has some rough edges,

835
00:38:09,098 --> 00:38:11,775
in particular the startup
order of containers

836
00:38:11,775 --> 00:38:13,831
can be a problem.

837
00:38:13,831 --> 00:38:16,134
In practise, it isn't really a problem

838
00:38:16,134 --> 00:38:18,694
if you have a container
that fails to start

839
00:38:18,694 --> 00:38:20,257
due to a race condition,

840
00:38:20,257 --> 00:38:23,924
then you just run Docker
compose up -d again

841
00:38:24,999 --> 00:38:26,659
and that will make sure

842
00:38:26,659 --> 00:38:28,157
that the failed containers have another go

843
00:38:28,157 --> 00:38:29,597
at starting up.

844
00:38:29,597 --> 00:38:31,298
This tool is for development purposes,

845
00:38:31,298 --> 00:38:33,578
it's not intended to
be used in production.

846
00:38:33,578 --> 00:38:37,695
So how do we run this
application in production,

847
00:38:37,695 --> 00:38:39,517
well that's what the next few chapters

848
00:38:39,517 --> 00:38:40,938
are going to be covering.

849
00:38:40,938 --> 00:38:43,111
We've got some really
exciting stuff coming up

850
00:38:43,111 --> 00:38:44,870
on Docker swarm and Docker stags

851
00:38:44,870 --> 00:38:48,287
so I hope I'll see you in those chapters.

1
00:00:00,434 --> 00:00:02,141
- [Instructor] And now
for the part of the course

2
00:00:02,141 --> 00:00:04,168
I've been looking forward to.

3
00:00:04,168 --> 00:00:06,651
We're going to look at docker swarm.

4
00:00:06,651 --> 00:00:10,078
We're moving towards a
full production system.

5
00:00:10,078 --> 00:00:12,593
The goal of this course is
to get a full production,

6
00:00:12,593 --> 00:00:15,865
multiple microservice
system up and running.

7
00:00:15,865 --> 00:00:19,176
And docker swarm is the
way that we can distribute

8
00:00:19,176 --> 00:00:24,157
our application across
multiple physical computers.

9
00:00:24,157 --> 00:00:25,848
So the point that we've
got to in the course

10
00:00:25,848 --> 00:00:28,677
is we have a system,
albeit a very simple system

11
00:00:28,677 --> 00:00:31,304
with just two containers at the moment,

12
00:00:31,304 --> 00:00:34,570
but each of those containers
is publishing a service.

13
00:00:34,570 --> 00:00:38,611
We have database service
and a kind of java container

14
00:00:38,611 --> 00:00:40,979
running a spring boot application.

15
00:00:40,979 --> 00:00:42,958
We've seen that we can quite easily

16
00:00:42,958 --> 00:00:45,465
network those containers together

17
00:00:45,465 --> 00:00:47,694
and we've seen that we end up with

18
00:00:47,694 --> 00:00:51,484
what is basically a
virtual private network

19
00:00:51,484 --> 00:00:54,208
using docker networking.

20
00:00:54,208 --> 00:00:56,505
A very basic system, in a later chapter,

21
00:00:56,505 --> 00:00:57,879
I'm going to be starting up

22
00:00:57,879 --> 00:01:00,575
the other microservices that we built

23
00:01:00,575 --> 00:01:03,667
in a previous virtual
pair programmer's course,

24
00:01:03,667 --> 00:01:05,846
and that will get a little
bit more complicated

25
00:01:05,846 --> 00:01:09,024
but bear in mind throughout
that of course in real life,

26
00:01:09,024 --> 00:01:13,489
you might have several
hundred of these containers

27
00:01:13,489 --> 00:01:16,004
to manage in your running system.

28
00:01:16,004 --> 00:01:18,741
Certainly a state such as Netflix

29
00:01:18,741 --> 00:01:22,309
have that kind of
complexity in their systems.

30
00:01:22,309 --> 00:01:25,115
Now, so far, we've been
running all of our containers

31
00:01:25,115 --> 00:01:28,938
on a single computer on
a single host system.

32
00:01:28,938 --> 00:01:30,710
And, well, of course we have,

33
00:01:30,710 --> 00:01:32,316
because we've been in development,

34
00:01:32,316 --> 00:01:35,819
so we've been developing
on our local machine.

35
00:01:35,819 --> 00:01:39,138
But when we roll this
system out to production,

36
00:01:39,138 --> 00:01:41,263
then we might have a scaling problem.

37
00:01:41,263 --> 00:01:43,038
Now we'd be okay with this, of course,

38
00:01:43,038 --> 00:01:45,496
two containers would be
absolutely fine to run

39
00:01:45,496 --> 00:01:47,866
on a single physical computer,

40
00:01:47,866 --> 00:01:50,699
but once we start scaling up to dozens

41
00:01:50,699 --> 00:01:53,340
or hundreds of containers,

42
00:01:53,340 --> 00:01:57,316
then you probably struggle to
find a server that can cope.

43
00:01:57,316 --> 00:02:00,587
You would certainly need a
very, very expensive server

44
00:02:00,587 --> 00:02:02,430
to run so many containers.

45
00:02:02,430 --> 00:02:06,731
So, it's very common
to scale horizontally,

46
00:02:06,731 --> 00:02:09,580
which means to distribute the containers

47
00:02:09,580 --> 00:02:12,497
across multiple physical computers.

48
00:02:14,169 --> 00:02:18,336
And docker swarm is a tool that
enables us to do just that.

49
00:02:19,795 --> 00:02:21,321
In fact, swarm is more than that.

50
00:02:21,321 --> 00:02:26,052
It's a full scale, so called
container orchestration system.

51
00:02:26,052 --> 00:02:27,752
It's going to allow us to make sure

52
00:02:27,752 --> 00:02:30,283
that our containers are always running

53
00:02:30,283 --> 00:02:33,473
and if any container
fails then docker swarm

54
00:02:33,473 --> 00:02:36,682
will automatically
restart those containers.

55
00:02:36,682 --> 00:02:39,039
And, in fact, docker
swarm goes quite a lot

56
00:02:39,039 --> 00:02:41,421
further than that as you're going to see

57
00:02:41,421 --> 00:02:44,407
over the next few chapters.

58
00:02:44,407 --> 00:02:46,395
Now the basic concepts in docker swarm

59
00:02:46,395 --> 00:02:49,097
is that rather than running
on a single host computer

60
00:02:49,097 --> 00:02:53,264
we're going to distribute across
multiple, so called nodes.

61
00:02:54,885 --> 00:02:58,572
So, for example, we might have four nodes.

62
00:02:58,572 --> 00:03:01,365
Now up until now, we've
been on a single host system

63
00:03:01,365 --> 00:03:03,092
and we've been running commands such as

64
00:03:03,092 --> 00:03:04,842
docker container run.

65
00:03:06,171 --> 00:03:09,445
The big difference in a docker swarm

66
00:03:09,445 --> 00:03:13,323
is that we'll log on to one of these nodes

67
00:03:13,323 --> 00:03:16,983
and we're going to issue
commands to docker swarm.

68
00:03:16,983 --> 00:03:19,168
I'll show you what those
commands are in a moment,

69
00:03:19,168 --> 00:03:22,491
but they'll be very
similar to the run commands

70
00:03:22,491 --> 00:03:24,150
that we've been doing.

71
00:03:24,150 --> 00:03:26,540
But the big difference is,
even if we're logged in

72
00:03:26,540 --> 00:03:31,360
to node one and we're
issuing our commands there,

73
00:03:31,360 --> 00:03:33,455
then when we tell the swarm that we want

74
00:03:33,455 --> 00:03:35,958
a new instance of a container,

75
00:03:35,958 --> 00:03:39,274
docker swarm will be
responsible for deciding

76
00:03:39,274 --> 00:03:43,250
on which node that container
is going to be run.

77
00:03:43,250 --> 00:03:46,309
And then when we go on and ask the swarm

78
00:03:46,309 --> 00:03:50,349
to add further containers,
again the swarm will decide

79
00:03:50,349 --> 00:03:53,755
on which nodes those
containers should be run.

80
00:03:53,755 --> 00:03:57,328
Roughly what happens is a
kind of a balancing system.

81
00:03:57,328 --> 00:04:00,852
So that no one node has more containers

82
00:04:00,852 --> 00:04:03,006
than the other nodes.

83
00:04:03,006 --> 00:04:06,134
So that's the very basic
concepts of a docker swarm.

84
00:04:06,134 --> 00:04:08,513
Now, of course to learn docker swarm

85
00:04:08,513 --> 00:04:10,348
is going to be a bit more complicated

86
00:04:10,348 --> 00:04:11,405
than what we've done before

87
00:04:11,405 --> 00:04:15,195
because really, to get the
full benefit of using swarm,

88
00:04:15,195 --> 00:04:17,546
you are going to need multiple

89
00:04:17,546 --> 00:04:20,178
physical computers to deal with.

90
00:04:20,178 --> 00:04:23,837
So in a later chapter,
we are going to spin up

91
00:04:23,837 --> 00:04:26,004
some Amazon EC2 instances,

92
00:04:26,863 --> 00:04:28,989
and we'll get four or five of them,

93
00:04:28,989 --> 00:04:31,018
and we'll experiment with distributing

94
00:04:31,018 --> 00:04:33,777
our microservice architecture across it.

95
00:04:33,777 --> 00:04:37,116
However, I'm aware that many
of you watching this course

96
00:04:37,116 --> 00:04:40,046
will not be interested in Amazon EC2,

97
00:04:40,046 --> 00:04:41,934
you might have never used it before,

98
00:04:41,934 --> 00:04:43,233
so for anyone in this situation,

99
00:04:43,233 --> 00:04:45,096
I don't want to lose you at this point.

100
00:04:45,096 --> 00:04:47,666
I'm going to show you a wonderful system

101
00:04:47,666 --> 00:04:50,750
that we can use for
learning about docker swarm,

102
00:04:50,750 --> 00:04:53,667
and that's called Play With Docker.

103
00:04:54,539 --> 00:04:56,360
We're going to come onto
that in a short while,

104
00:04:56,360 --> 00:04:59,369
but actually to try out the basic commands

105
00:04:59,369 --> 00:05:03,877
in a docker swarm, you can
do that on a single instance.

106
00:05:03,877 --> 00:05:08,244
So we're going to start by
having a single node swarm.

107
00:05:08,244 --> 00:05:11,373
Now, of course, it's a nonsense really,

108
00:05:11,373 --> 00:05:14,225
you would never in production
have a single node swarm,

109
00:05:14,225 --> 00:05:15,913
it doesn't make sense.

110
00:05:15,913 --> 00:05:18,034
But we can at least do that

111
00:05:18,034 --> 00:05:20,763
just to learn the basic commands.

112
00:05:20,763 --> 00:05:22,381
So let's get started.

113
00:05:22,381 --> 00:05:23,730
So we're back on our command line,

114
00:05:23,730 --> 00:05:26,952
and I don't currently have
any containers running,

115
00:05:26,952 --> 00:05:30,334
if I do a docker container
LS, nothing running,

116
00:05:30,334 --> 00:05:34,501
and LS-A shows I don't have
any stopped containers either.

117
00:05:35,417 --> 00:05:36,995
I recommend if you do have containers

118
00:05:36,995 --> 00:05:38,294
running from previous chapters,

119
00:05:38,294 --> 00:05:42,618
do a docker container stop
on any running containers

120
00:05:42,618 --> 00:05:45,199
and then you can do a
docker container prune

121
00:05:45,199 --> 00:05:48,597
which will remove any stopped containers.

122
00:05:48,597 --> 00:05:51,069
I've probably got a stack of images,

123
00:05:51,069 --> 00:05:53,741
but that's absolutely fine,
I can leave them there.

124
00:05:53,741 --> 00:05:55,140
So what we're going to do first, then,

125
00:05:55,140 --> 00:05:57,310
is we're going to start up a docker swarm

126
00:05:57,310 --> 00:05:59,450
with just a single instance

127
00:05:59,450 --> 00:06:02,420
and it's going to be my
development computer.

128
00:06:02,420 --> 00:06:05,577
Pretty much useless, but
it's at least a start

129
00:06:05,577 --> 00:06:08,230
and we can learn the basic commands.

130
00:06:08,230 --> 00:06:13,207
We manage a docker swarm by
using the docker swarm command.

131
00:06:13,207 --> 00:06:14,927
I'm going to need some arguments

132
00:06:14,927 --> 00:06:16,850
into the docker swarm command.

133
00:06:16,850 --> 00:06:18,348
There aren't actually that many options

134
00:06:18,348 --> 00:06:20,278
for the docker swarm command,

135
00:06:20,278 --> 00:06:24,077
the one we're looking for
is the command called init,

136
00:06:24,077 --> 00:06:27,547
and that will set up a
swarm with a single node

137
00:06:27,547 --> 00:06:30,340
and that's going to be the
node that we're running on.

138
00:06:30,340 --> 00:06:32,173
So, docker swarm init.

139
00:06:36,232 --> 00:06:37,693
And it's as simple as that.

140
00:06:37,693 --> 00:06:40,993
This computer is now in swarm mode.

141
00:06:40,993 --> 00:06:42,395
Now what it's telling me, first of all,

142
00:06:42,395 --> 00:06:45,207
is that this node is a manager.

143
00:06:45,207 --> 00:06:49,260
I'll talk more about what
managers are a little later on.

144
00:06:49,260 --> 00:06:51,698
But it's telling me that if I want to add

145
00:06:51,698 --> 00:06:53,939
a worker to this swarm,

146
00:06:53,939 --> 00:06:56,059
then I need to run the following command,

147
00:06:56,059 --> 00:06:58,726
and it's this long command here.

148
00:06:59,582 --> 00:07:03,271
Docker swarm join, --token followed by

149
00:07:03,271 --> 00:07:06,942
some great, big, long
unintelligible token.

150
00:07:06,942 --> 00:07:08,623
And what that means is all we have to do

151
00:07:08,623 --> 00:07:10,331
to expand this swarm is

152
00:07:10,331 --> 00:07:13,422
at another time if we
have another computer,

153
00:07:13,422 --> 00:07:18,045
that has network connectivity
with my original node,

154
00:07:18,045 --> 00:07:20,328
then all I have to do on this new node

155
00:07:20,328 --> 00:07:22,675
is run the command you've just seen

156
00:07:22,675 --> 00:07:26,977
and then this new node
will be added to the swarm.

157
00:07:26,977 --> 00:07:28,828
So it's quite simple to manage.

158
00:07:28,828 --> 00:07:30,722
Now don't worry about
remembering that command

159
00:07:30,722 --> 00:07:33,327
because we can easily
get that command back

160
00:07:33,327 --> 00:07:35,554
and I'll show you how to do that later.

161
00:07:35,554 --> 00:07:37,223
But for now I want to show you how to

162
00:07:37,223 --> 00:07:40,778
launch a container into our swarm.

163
00:07:40,778 --> 00:07:43,188
The big difference is, up until now,

164
00:07:43,188 --> 00:07:46,873
you will have been doing
docker container run

165
00:07:46,873 --> 00:07:48,462
followed by that great big long

166
00:07:48,462 --> 00:07:51,204
list of command line arguments.

167
00:07:51,204 --> 00:07:53,896
The difference is when
you're working in a swarm,

168
00:07:53,896 --> 00:07:56,979
instead a swarm talks about services.

169
00:07:58,940 --> 00:08:00,906
Now I've been using the term service

170
00:08:00,906 --> 00:08:04,119
informally a lot on this course,

171
00:08:04,119 --> 00:08:07,017
so I've been talking
about our web apps service

172
00:08:07,017 --> 00:08:09,129
and our database service.

173
00:08:09,129 --> 00:08:11,472
For now you can think about services being

174
00:08:11,472 --> 00:08:13,722
a container inside a swarm.

175
00:08:15,193 --> 00:08:16,512
There is a subtle difference

176
00:08:16,512 --> 00:08:18,802
and I'll talk about that in a short while,

177
00:08:18,802 --> 00:08:21,882
but one of the great things
about working with a swarm

178
00:08:21,882 --> 00:08:25,542
is that pretty much
everything we have been doing

179
00:08:25,542 --> 00:08:27,631
previously on the course

180
00:08:27,631 --> 00:08:32,001
you do it in exactly
the same way in a swarm.

181
00:08:32,001 --> 00:08:36,168
So up until now we've been
doing a docker container run,

182
00:08:37,058 --> 00:08:38,988
and I've just given
myself a little more space

183
00:08:38,988 --> 00:08:40,766
on the command line there,

184
00:08:40,766 --> 00:08:42,549
but what you would do
now is simply feed in

185
00:08:42,549 --> 00:08:45,039
exactly the same command line arguments

186
00:08:45,039 --> 00:08:47,548
that you've been using
throughout the course.

187
00:08:47,548 --> 00:08:51,715
We would use -D to run this
service as a detached container.

188
00:08:52,955 --> 00:08:55,975
As usual, we'll need
to connect to a network

189
00:08:55,975 --> 00:08:58,027
so that the containers
can talk to each other,

190
00:08:58,027 --> 00:08:59,436
and up until now we've been calling

191
00:08:59,436 --> 00:09:02,471
our network fleetman-network.

192
00:09:02,471 --> 00:09:03,835
Now I think we'll find when we run this

193
00:09:03,835 --> 00:09:06,614
it won't quite work, but
we'll come back to that.

194
00:09:06,614 --> 00:09:09,625
Now I'm going to be creating
the database container here,

195
00:09:09,625 --> 00:09:13,610
so as usual, we're back to the
tedious command line again.

196
00:09:13,610 --> 00:09:17,516
We need the my sql root
password environment

197
00:09:17,516 --> 00:09:20,975
variable set to be equal to password

198
00:09:20,975 --> 00:09:23,848
and another environment variable for the

199
00:09:23,848 --> 00:09:28,015
my sql_database which we'll
set to be called fleetman

200
00:09:30,250 --> 00:09:33,797
and finally we need to
give this service a name,

201
00:09:33,797 --> 00:09:35,962
exactly as we did before,

202
00:09:35,962 --> 00:09:39,442
and I'm going to call this database.

203
00:09:39,442 --> 00:09:41,962
And the final parameter
in here is the image

204
00:09:41,962 --> 00:09:43,719
that we're running from,

205
00:09:43,719 --> 00:09:46,369
and that's going to be my sql.

206
00:09:46,369 --> 00:09:49,441
So I know it's a long,
tedious command line,

207
00:09:49,441 --> 00:09:53,068
and we got away from command
lines in the previous chapter,

208
00:09:53,068 --> 00:09:54,910
don't worry, coming up very soon

209
00:09:54,910 --> 00:09:57,353
I'll be showing you how
you can do the same things

210
00:09:57,353 --> 00:10:00,723
as docker compose within a swarm.

211
00:10:00,723 --> 00:10:02,134
But for now, I think it's worth playing

212
00:10:02,134 --> 00:10:03,596
with the command line to get a feel

213
00:10:03,596 --> 00:10:05,590
for what's going on here.

214
00:10:05,590 --> 00:10:09,446
Now, as I promised, we
are seeing an error here.

215
00:10:09,446 --> 00:10:11,559
You might, at this
stage, be seeing an error

216
00:10:11,559 --> 00:10:14,638
saying the network fleetman
network does not exist,

217
00:10:14,638 --> 00:10:17,989
depending on what you've
done in previous chapters.

218
00:10:17,989 --> 00:10:19,640
If you're seeing that, then don't worry,

219
00:10:19,640 --> 00:10:21,498
there's no problem.

220
00:10:21,498 --> 00:10:23,842
But this problem seems to be saying

221
00:10:23,842 --> 00:10:26,568
that there's something wrong
with my fleetman network

222
00:10:26,568 --> 00:10:28,688
that I've been using previously.

223
00:10:28,688 --> 00:10:32,237
And clearly it's saying it
cannot be used with services.

224
00:10:32,237 --> 00:10:36,070
Only networks scoped to
the swarm can be used.

225
00:10:37,210 --> 00:10:39,527
Which is quite obscure.

226
00:10:39,527 --> 00:10:42,274
But the reason is, when
we're working in swarm,

227
00:10:42,274 --> 00:10:45,636
we need a special type of network.

228
00:10:45,636 --> 00:10:46,983
The big difference, of course,

229
00:10:46,983 --> 00:10:49,345
is that our containers are now very likely

230
00:10:49,345 --> 00:10:52,178
to be on different physical nodes,

231
00:10:53,101 --> 00:10:55,714
so the communications between them

232
00:10:55,714 --> 00:10:59,065
are not going to be within
the same host machine,

233
00:10:59,065 --> 00:11:02,006
they're going to be across
different physical computers.

234
00:11:02,006 --> 00:11:04,060
And for that reason, in swarm,

235
00:11:04,060 --> 00:11:06,479
we have a different type of network.

236
00:11:06,479 --> 00:11:09,532
It's called an overlay network,

237
00:11:09,532 --> 00:11:11,343
and as the caption here says,

238
00:11:11,343 --> 00:11:13,477
it's going to give us
all of the same features

239
00:11:13,477 --> 00:11:16,336
that we've had on the previous network

240
00:11:16,336 --> 00:11:17,990
that we've been using.

241
00:11:17,990 --> 00:11:20,184
You might recall that that type of network

242
00:11:20,184 --> 00:11:22,451
is called a bridge network.

243
00:11:22,451 --> 00:11:24,313
The difference is this network

244
00:11:24,313 --> 00:11:27,153
will work across multiple nodes.

245
00:11:27,153 --> 00:11:29,904
It's called the overlay network.

246
00:11:29,904 --> 00:11:32,073
So to create one of
these overlay networks,

247
00:11:32,073 --> 00:11:33,477
it's really easy.

248
00:11:33,477 --> 00:11:36,227
We'll do a docker network create,

249
00:11:37,582 --> 00:11:39,332
- -driver and overlay.

250
00:11:41,317 --> 00:11:43,045
And, by the way, there isn't a great long

251
00:11:43,045 --> 00:11:46,030
collection of different
types of driver in docker,

252
00:11:46,030 --> 00:11:47,671
or at least at the time of recording,

253
00:11:47,671 --> 00:11:50,781
basically it's either an
overlay network for swarm

254
00:11:50,781 --> 00:11:54,948
or a bridge network for a
local single host deployment.

255
00:11:56,529 --> 00:11:57,889
There are couple of other types as well,

256
00:11:57,889 --> 00:11:59,856
but we don't really need to use them.

257
00:11:59,856 --> 00:12:02,787
So we just need to give
this new network a name,

258
00:12:02,787 --> 00:12:05,870
and we could call it fleetman network

259
00:12:06,771 --> 00:12:09,081
and simply delete the previous,

260
00:12:09,081 --> 00:12:11,495
in fact I think that's what we'll do.

261
00:12:11,495 --> 00:12:14,477
So if we use the name fleetman network,

262
00:12:14,477 --> 00:12:18,054
we will get an error
because that already exists,

263
00:12:18,054 --> 00:12:20,637
so we'll do a docker network rm

264
00:12:21,780 --> 00:12:25,947
to remove fleetman network,
that's the old bridge version,

265
00:12:28,189 --> 00:12:29,781
that was successful,

266
00:12:29,781 --> 00:12:32,457
and now I can recall the create command

267
00:12:32,457 --> 00:12:36,520
and now I have one of
these new overlay networks.

268
00:12:36,520 --> 00:12:38,225
I get a sense that people
think there's something

269
00:12:38,225 --> 00:12:41,523
really complicated and weird
about the overlay networks

270
00:12:41,523 --> 00:12:43,460
but really from this point on

271
00:12:43,460 --> 00:12:47,544
we will just be treating
that network exactly the same

272
00:12:47,544 --> 00:12:50,677
as we've been treating
the network up until now.

273
00:12:50,677 --> 00:12:55,604
So I hope now if I recall
my service create command,

274
00:12:55,604 --> 00:12:58,895
can't quite fit all of
that onto the screen,

275
00:12:58,895 --> 00:13:00,645
but it's really identical to the

276
00:13:00,645 --> 00:13:02,947
docker container run command,

277
00:13:02,947 --> 00:13:05,181
all of the arguments are the same,

278
00:13:05,181 --> 00:13:08,348
it's just the first part of
the command that's different.

279
00:13:08,348 --> 00:13:11,080
Let's see what happens.

280
00:13:11,080 --> 00:13:12,275
Well I've been given one of these

281
00:13:12,275 --> 00:13:13,988
weird IDs back in response.

282
00:13:13,988 --> 00:13:16,063
The IDs here are slightly different

283
00:13:16,063 --> 00:13:18,109
to the ones we've been seeing before,

284
00:13:18,109 --> 00:13:21,188
previously they were hexadecimal digits

285
00:13:21,188 --> 00:13:25,957
but now we have a sequence
of alphanumeric characters

286
00:13:25,957 --> 00:13:27,368
by the look of it.

287
00:13:27,368 --> 00:13:30,504
That's just a unique ID for the service.

288
00:13:30,504 --> 00:13:32,914
Now we can see what
services we've got running

289
00:13:32,914 --> 00:13:37,081
with a docker service LS
and there's our new service.

290
00:13:39,361 --> 00:13:41,276
Now, all this will have done,

291
00:13:41,276 --> 00:13:45,465
is in the background it will
have created a container

292
00:13:45,465 --> 00:13:48,139
for that service and there's nothing

293
00:13:48,139 --> 00:13:51,860
particularly special
about those containers

294
00:13:51,860 --> 00:13:54,267
even though I'm running in swarm mode,

295
00:13:54,267 --> 00:13:56,208
I can perfectly well drop back

296
00:13:56,208 --> 00:13:59,041
to the docker container LS command

297
00:14:00,183 --> 00:14:03,532
and there you can see the
container beginning DE

298
00:14:03,532 --> 00:14:07,099
is the container that
this service has started.

299
00:14:07,099 --> 00:14:10,846
So, at the moment, this
doesn't feel any different

300
00:14:10,846 --> 00:14:13,412
to what we had before, but remember,

301
00:14:13,412 --> 00:14:17,713
if we were running in a
real, multiple node system

302
00:14:17,713 --> 00:14:20,208
then when we started this service,

303
00:14:20,208 --> 00:14:23,033
that container would have
been randomly created

304
00:14:23,033 --> 00:14:26,530
on one of the nodes of our system,

305
00:14:26,530 --> 00:14:29,652
not necessarily the one
that we're running on.

306
00:14:29,652 --> 00:14:32,430
So, I hope you got a feel
for the basic commands, but

307
00:14:32,430 --> 00:14:35,430
I think we've really gone as far as we can

308
00:14:35,430 --> 00:14:36,954
with a single instance,

309
00:14:36,954 --> 00:14:39,824
it would be really good
if we could try this

310
00:14:39,824 --> 00:14:42,857
in a more production-like environment.

311
00:14:42,857 --> 00:14:45,937
And we will be using Amazon EC2 instances

312
00:14:45,937 --> 00:14:47,775
later on in the course,

313
00:14:47,775 --> 00:14:49,935
but if you don't want to run on EC2,

314
00:14:49,935 --> 00:14:51,782
then there's a really attractive option

315
00:14:51,782 --> 00:14:54,232
that you can use for
experimenting with this

316
00:14:54,232 --> 00:14:57,288
and it's called Play With Docker.

317
00:14:57,288 --> 00:15:00,830
It's also affectionately
referred to as PWD.

318
00:15:00,830 --> 00:15:04,691
So you'll find it at playwithdocker.com,

319
00:15:04,691 --> 00:15:08,703
and it will redirect to
labs.playwithdocker.com.

320
00:15:08,703 --> 00:15:10,738
You will need to verify that you're human

321
00:15:10,738 --> 00:15:12,948
by clicking on create session.

322
00:15:12,948 --> 00:15:16,229
Now what we've got here
is really fantastic.

323
00:15:16,229 --> 00:15:18,829
This is a cloud based system where we can

324
00:15:18,829 --> 00:15:23,625
spin up several instances
of a physical machine.

325
00:15:23,625 --> 00:15:24,769
Now, actually, in real life,

326
00:15:24,769 --> 00:15:26,447
they're not really physical instances,

327
00:15:26,447 --> 00:15:28,698
they are all virtual machines, of course,

328
00:15:28,698 --> 00:15:30,434
but that doesn't really matter.

329
00:15:30,434 --> 00:15:34,533
To us it will feel as though
these are standalone computers

330
00:15:34,533 --> 00:15:38,789
that we can just provision
at will for free.

331
00:15:38,789 --> 00:15:40,447
So a really amazing service.

332
00:15:40,447 --> 00:15:42,253
Now there is a restriction on it,

333
00:15:42,253 --> 00:15:45,778
as you can see here,
there's a ticking clock.

334
00:15:45,778 --> 00:15:49,264
And we're given four hours
to work with this session.

335
00:15:49,264 --> 00:15:52,104
In four hours all of
the nodes that we create

336
00:15:52,104 --> 00:15:53,573
will be destroyed.

337
00:15:53,573 --> 00:15:55,477
So, obviously, we're not
going to be using this

338
00:15:55,477 --> 00:15:56,441
in real production,

339
00:15:56,441 --> 00:15:59,531
but it's a great way with
experimenting with docker,

340
00:15:59,531 --> 00:16:01,886
without incurring costs and without

341
00:16:01,886 --> 00:16:06,053
having all of the complexity
of EC2 or Microsoft Azure

342
00:16:07,464 --> 00:16:10,534
or any of these cloud services.

343
00:16:10,534 --> 00:16:12,535
So, what we can do on here,

344
00:16:12,535 --> 00:16:14,811
if we click on the button
on the left hand side,

345
00:16:14,811 --> 00:16:18,858
we can just fire up a new
instance of a virtual machine

346
00:16:18,858 --> 00:16:22,025
and there we are, we have an instance.

347
00:16:22,944 --> 00:16:25,308
Almost instantly provisioned.

348
00:16:25,308 --> 00:16:28,276
And it's a regular Linux distribution,

349
00:16:28,276 --> 00:16:31,026
we can do all of the usual LS PWD

350
00:16:32,118 --> 00:16:34,511
to print our working directory,

351
00:16:34,511 --> 00:16:38,972
who am I, to determine who
I'm logged on as, and so on.

352
00:16:38,972 --> 00:16:42,890
But, crucially, of course,
we've got docker installed,

353
00:16:42,890 --> 00:16:47,261
so I'll do a docker --version
and yeah, docker's installed.

354
00:16:47,261 --> 00:16:49,790
But we can add more instances.

355
00:16:49,790 --> 00:16:52,748
If I click on the add
new instance button here,

356
00:16:52,748 --> 00:16:54,348
on the left hand side,

357
00:16:54,348 --> 00:16:55,738
that will take a few seconds,

358
00:16:55,738 --> 00:16:58,144
but now I've got a second instance,

359
00:16:58,144 --> 00:17:00,070
and I can switch between them

360
00:17:00,070 --> 00:17:04,153
by clicking on these links
on the left hand side.

361
00:17:05,596 --> 00:17:08,124
And now we can start
to have some real fun.

362
00:17:08,124 --> 00:17:10,164
So I'm going to take both of these nodes

363
00:17:10,164 --> 00:17:12,561
and join them to a docker swarm.

364
00:17:12,561 --> 00:17:15,429
And to do that, pick one of the instances,

365
00:17:15,429 --> 00:17:17,218
let's go for node one,

366
00:17:17,218 --> 00:17:20,989
and we'll do exactly the
same as we did locally.

367
00:17:20,989 --> 00:17:23,406
We'll do a docker swarm init.

368
00:17:24,768 --> 00:17:27,682
Now, often when you're running in a

369
00:17:27,682 --> 00:17:30,494
cloud based environment,
you get this error back,

370
00:17:30,494 --> 00:17:33,236
saying, it couldn't choose an IP address,

371
00:17:33,236 --> 00:17:37,438
because this particular
system has multiple addresses

372
00:17:37,438 --> 00:17:39,421
on different interfaces.

373
00:17:39,421 --> 00:17:42,526
Now all you have to do is pick
one of these IP addresses,

374
00:17:42,526 --> 00:17:45,159
I'll go for the one beginning 10.0

375
00:17:45,159 --> 00:17:47,909
and as suggested here, you add in

376
00:17:48,912 --> 00:17:52,495
the command line argument
--advertise -addr

377
00:17:56,638 --> 00:17:58,731
followed by one of those addresses,

378
00:17:58,731 --> 00:18:02,898
so for me it's 10.0.16.3,
it'll be different for you.

379
00:18:05,594 --> 00:18:07,639
So hopefully now we're
seeing exactly the same kind

380
00:18:07,639 --> 00:18:10,435
of output that we had when
we were running locally.

381
00:18:10,435 --> 00:18:14,222
It's telling us now that this
node is running as a manager,

382
00:18:14,222 --> 00:18:17,223
and if we want to add
a worker to this swarm,

383
00:18:17,223 --> 00:18:19,873
we need to run this command.

384
00:18:19,873 --> 00:18:23,026
And be careful here, it
is a very long command,

385
00:18:23,026 --> 00:18:25,591
and you'll need to copy and paste this.

386
00:18:25,591 --> 00:18:27,427
I notice that my command's gone off

387
00:18:27,427 --> 00:18:30,120
the edge of the screen there,

388
00:18:30,120 --> 00:18:33,703
and there's a trailing
number seven, there.

389
00:18:34,931 --> 00:18:39,098
That's because it's using
pour 23774, the docker daemon.

390
00:18:40,123 --> 00:18:42,485
So we need to copy that line,

391
00:18:42,485 --> 00:18:44,804
and then in our other node,

392
00:18:44,804 --> 00:18:47,909
we haven't done anything
with this node yet,

393
00:18:47,909 --> 00:18:49,742
paste that command in,

394
00:18:50,762 --> 00:18:53,095
and it's as simple as that,

395
00:18:53,095 --> 00:18:56,515
this node is now part of the swarm.

396
00:18:56,515 --> 00:18:59,277
So if we go back to node one,

397
00:18:59,277 --> 00:19:01,836
we've got more commands
that we can use now,

398
00:19:01,836 --> 00:19:05,265
we have the docker node command.

399
00:19:05,265 --> 00:19:08,211
And as usual with docker commands,

400
00:19:08,211 --> 00:19:10,859
we can do an LS and that will give us

401
00:19:10,859 --> 00:19:14,808
a list of all of the nodes in the swarm.

402
00:19:14,808 --> 00:19:16,928
So, we're seeing two.

403
00:19:16,928 --> 00:19:19,210
Any point in the future, if we want to,

404
00:19:19,210 --> 00:19:22,166
we can add more nodes to this swarm.

405
00:19:22,166 --> 00:19:23,932
And now we can simply repeat the commands

406
00:19:23,932 --> 00:19:25,429
that we did locally,

407
00:19:25,429 --> 00:19:27,680
I'll start by creating the network,

408
00:19:27,680 --> 00:19:31,263
docker network create,
we need the --driver

409
00:19:32,200 --> 00:19:34,976
to specify the overlay driver,

410
00:19:34,976 --> 00:19:39,143
and the network I'm going
to call fleetman-network.

411
00:19:42,156 --> 00:19:46,323
So that's created, and I
can do a docker network LS.

412
00:19:47,729 --> 00:19:50,885
And there's the overlay
network right there.

413
00:19:50,885 --> 00:19:54,075
Just out of interest,
in case you're curious,

414
00:19:54,075 --> 00:19:56,929
if we switch across to node two,

415
00:19:56,929 --> 00:19:59,596
and do a docker network LS there

416
00:20:02,887 --> 00:20:05,667
you'll notice that that
network doesn't appear

417
00:20:05,667 --> 00:20:08,646
on that list and that's
because this is a worker.

418
00:20:08,646 --> 00:20:10,877
You're going to find
that most of the commands

419
00:20:10,877 --> 00:20:13,407
that we use on the manager node

420
00:20:13,407 --> 00:20:15,471
are not going to work here.

421
00:20:15,471 --> 00:20:18,721
For example, if I do the docker node LS

422
00:20:20,018 --> 00:20:23,764
I get an error because
this is not a manager.

423
00:20:23,764 --> 00:20:26,294
And that's the point of a worker, they,

424
00:20:26,294 --> 00:20:30,007
worker nodes can't be used
to issue commands, bascially,

425
00:20:30,007 --> 00:20:33,592
although they will have
containers running on them,

426
00:20:33,592 --> 00:20:35,022
so bear that in mind,

427
00:20:35,022 --> 00:20:37,913
but let's switch across back to node one.

428
00:20:37,913 --> 00:20:41,490
And it's just a case now
of launching services.

429
00:20:41,490 --> 00:20:45,295
So we'll do a docker service create,

430
00:20:45,295 --> 00:20:48,241
and here we go again with
our long boring command.

431
00:20:48,241 --> 00:20:51,201
This is going to be the database service,

432
00:20:51,201 --> 00:20:53,951
so -D --network fleetman-network,

433
00:20:59,519 --> 00:21:01,807
oh those environment variables again,

434
00:21:01,807 --> 00:21:03,890
- E my sql_route_password,

435
00:21:06,944 --> 00:21:09,974
this is going to be set equal to password

436
00:21:09,974 --> 00:21:14,057
- E my sql_database will
be set equal to fleetman.

437
00:21:20,445 --> 00:21:22,086
We need a name for this service,

438
00:21:22,086 --> 00:21:24,003
- -name will be database

439
00:21:25,470 --> 00:21:28,543
and finally we need the name of the image

440
00:21:28,543 --> 00:21:30,260
that we're running from

441
00:21:30,260 --> 00:21:31,992
and remember the my sql image

442
00:21:31,992 --> 00:21:34,620
is one of the standard
images on docker hub

443
00:21:34,620 --> 00:21:37,479
and we do have network
connectivity on these machines

444
00:21:37,479 --> 00:21:41,152
so it will be able to download that image.

445
00:21:41,152 --> 00:21:43,255
Okay, that's exactly
how we did it locally,

446
00:21:43,255 --> 00:21:45,123
let's see what the difference is

447
00:21:45,123 --> 00:21:47,540
on this more realistic swarm.

448
00:21:48,694 --> 00:21:51,838
Well, it's responded with a service ID

449
00:21:51,838 --> 00:21:55,090
and we can do a docker service LS,

450
00:21:55,090 --> 00:21:58,643
and what this is telling
me is that currently,

451
00:21:58,643 --> 00:22:02,065
there are no instances
of this container running

452
00:22:02,065 --> 00:22:04,398
but we require one instance.

453
00:22:05,544 --> 00:22:07,690
The reason for that is the container

454
00:22:07,690 --> 00:22:10,629
will be starting up in the background,

455
00:22:10,629 --> 00:22:12,994
and only when that container's started

456
00:22:12,994 --> 00:22:15,350
will that switch to a one.

457
00:22:15,350 --> 00:22:18,237
If I repeat the docker service LS,

458
00:22:18,237 --> 00:22:21,046
yeah that's now switched to a one.

459
00:22:21,046 --> 00:22:24,837
So that means somewhere in our swarm,

460
00:22:24,837 --> 00:22:28,482
there is a container
running for the database.

461
00:22:28,482 --> 00:22:31,694
We don't actually know where it is,

462
00:22:31,694 --> 00:22:34,143
and actually when we get into production

463
00:22:34,143 --> 00:22:36,856
we kind of tend not to care where it is,

464
00:22:36,856 --> 00:22:39,674
but if we do on this instance,

465
00:22:39,674 --> 00:22:41,674
say docker container LS,

466
00:22:42,909 --> 00:22:47,076
I am seeing that database
container, but you might not.

467
00:22:48,170 --> 00:22:50,156
It might have decided to launch that

468
00:22:50,156 --> 00:22:53,052
database container on the other node,

469
00:22:53,052 --> 00:22:55,510
so we can switch across to the other node,

470
00:22:55,510 --> 00:22:59,154
and although we can't run swarm
commands on the worker node,

471
00:22:59,154 --> 00:23:02,311
you can run all of the
usual docker commands,

472
00:23:02,311 --> 00:23:04,228
so docker container LS,

473
00:23:07,900 --> 00:23:11,772
will give you a list of all of
the containers on this node,

474
00:23:11,772 --> 00:23:14,766
and it might be that
your database container

475
00:23:14,766 --> 00:23:17,307
is running on this node, who knows.

476
00:23:17,307 --> 00:23:19,185
It's a little bit random.

477
00:23:19,185 --> 00:23:23,132
So if you go back, now, to
our manager node on node one,

478
00:23:23,132 --> 00:23:25,078
we can run our second service,

479
00:23:25,078 --> 00:23:28,161
docker service create, I do apologise

480
00:23:29,136 --> 00:23:31,887
for the long tedium of these commands,

481
00:23:31,887 --> 00:23:34,809
in the next chapter,
we'll be returning to this

482
00:23:34,809 --> 00:23:37,281
and we'll see how we can use a tool

483
00:23:37,281 --> 00:23:40,598
very similar to docker
compose to achieve what we had

484
00:23:40,598 --> 00:23:42,594
in the last chapter.

485
00:23:42,594 --> 00:23:44,877
Anyway, we need to connect
this to the same network,

486
00:23:44,877 --> 00:23:48,452
so this will be fleetman-network again,

487
00:23:48,452 --> 00:23:52,119
and we need to map the
port 80 to port 8080.

488
00:23:53,841 --> 00:23:58,008
We need to give it a name,
--name fleetman-webapp,

489
00:23:59,167 --> 00:24:02,381
and the image, now if you've been pushing

490
00:24:02,381 --> 00:24:05,968
your fleetman webapp images to docker hub,

491
00:24:05,968 --> 00:24:09,667
feel free to use your docker hub ID here

492
00:24:09,667 --> 00:24:12,281
and the name of the
image that you've pushed.

493
00:24:12,281 --> 00:24:15,572
If you don't have that, then
feel free to use my image,

494
00:24:15,572 --> 00:24:18,321
so you can use virtual pair programmers

495
00:24:18,321 --> 00:24:21,154
forward slash fleetman-production.

496
00:24:23,887 --> 00:24:26,466
As usual, that will be
downloaded from docker hub

497
00:24:26,466 --> 00:24:29,958
although the difference is you
won't see the pull happening

498
00:24:29,958 --> 00:24:32,969
that will all happen in the background.

499
00:24:32,969 --> 00:24:36,223
So, I think that's all we
need for the command line,

500
00:24:36,223 --> 00:24:38,959
let's see what happens this time.

501
00:24:38,959 --> 00:24:41,199
Again, I have a service ID returned,

502
00:24:41,199 --> 00:24:44,671
and a docker service LS will confirm

503
00:24:44,671 --> 00:24:47,171
that we now have two services.

504
00:24:49,036 --> 00:24:52,902
Currently, the webapp
service is starting up

505
00:24:52,902 --> 00:24:56,985
so we have zero of one,
I'll recall that command,

506
00:24:57,978 --> 00:24:59,631
and I just waited long enough there

507
00:24:59,631 --> 00:25:03,159
so it's now incremented up
to one container running.

508
00:25:03,159 --> 00:25:06,352
But as before, if we do
a docker container LS,

509
00:25:06,352 --> 00:25:08,670
there's no guarantee as to which node

510
00:25:08,670 --> 00:25:10,793
it's going to be running on.

511
00:25:10,793 --> 00:25:14,887
Now my guess is, my guess is
it will be on the other node,

512
00:25:14,887 --> 00:25:17,605
because it's going to
balance the containers,

513
00:25:17,605 --> 00:25:20,296
you're not going to see
two containers on one node

514
00:25:20,296 --> 00:25:22,828
and no containers on another.

515
00:25:22,828 --> 00:25:26,248
So docker container LS on this node

516
00:25:26,248 --> 00:25:28,816
is only showing me one container,

517
00:25:28,816 --> 00:25:31,613
but if I switch across to the other node,

518
00:25:31,613 --> 00:25:34,252
I can repeat the docker container LS

519
00:25:34,252 --> 00:25:36,316
and we confirm there that we have

520
00:25:36,316 --> 00:25:39,292
a regular docker container
running on this node.

521
00:25:39,292 --> 00:25:40,836
So I think that's one of the points

522
00:25:40,836 --> 00:25:42,760
I want to make about docker swarm,

523
00:25:42,760 --> 00:25:45,591
we have a layer of management,

524
00:25:45,591 --> 00:25:48,386
with some very sophisticated
orchestration tools

525
00:25:48,386 --> 00:25:51,412
but really all that's happening underneath

526
00:25:51,412 --> 00:25:55,839
is regular docker containers
are being started and stopped

527
00:25:55,839 --> 00:25:57,964
sort of in the background.

528
00:25:57,964 --> 00:26:00,872
I we go back to our manager node,

529
00:26:00,872 --> 00:26:04,700
we can get the logs for
all of the services,

530
00:26:04,700 --> 00:26:06,450
docker service logs-f

531
00:26:07,952 --> 00:26:10,291
followed by the name of the service

532
00:26:10,291 --> 00:26:11,896
that you want to check the logs for,

533
00:26:11,896 --> 00:26:13,813
so here's our database,

534
00:26:14,708 --> 00:26:19,542
there's my sql log, and
we can do exactly the same

535
00:26:19,542 --> 00:26:21,802
for the fleetman-webapp,

536
00:26:21,802 --> 00:26:25,294
even though this container's
running on a worker node,

537
00:26:25,294 --> 00:26:29,408
I can see that log from
here on the manager node.

538
00:26:29,408 --> 00:26:31,966
I'm fairly sure that's a new feature.

539
00:26:31,966 --> 00:26:34,508
It used to be you had
to go and find the node

540
00:26:34,508 --> 00:26:36,056
that the container was running on

541
00:26:36,056 --> 00:26:38,460
and you had to do docker container logs.

542
00:26:38,460 --> 00:26:41,146
I think it's a new feature
anyway, but if it is,

543
00:26:41,146 --> 00:26:43,766
it's certainly a very good feature.

544
00:26:43,766 --> 00:26:45,504
So this is pretty wonderful.

545
00:26:45,504 --> 00:26:47,937
What we can see here is that we can now

546
00:26:47,937 --> 00:26:51,090
fire up services and they're
going to be distributed

547
00:26:51,090 --> 00:26:53,658
across as many nodes as we like

548
00:26:53,658 --> 00:26:57,174
without us having to do
really very much work.

549
00:26:57,174 --> 00:26:59,605
We just have to think in terms of services

550
00:26:59,605 --> 00:27:01,826
instead of containers.

551
00:27:01,826 --> 00:27:05,116
And this Play With Docker
is really fantastic.

552
00:27:05,116 --> 00:27:07,608
You should find now
you've got a little link

553
00:27:07,608 --> 00:27:09,626
up at the top and these links

554
00:27:09,626 --> 00:27:11,393
are showing you all of the ports

555
00:27:11,393 --> 00:27:13,815
that you're exposing from this node.

556
00:27:13,815 --> 00:27:16,322
Now, as soon as we started that container,

557
00:27:16,322 --> 00:27:19,397
you might have noticed
that this 80 appeared,

558
00:27:19,397 --> 00:27:21,679
and if you click on that link now,

559
00:27:21,679 --> 00:27:25,482
you now have your fleetman
containerized application

560
00:27:25,482 --> 00:27:27,992
published to a real, running host.

561
00:27:27,992 --> 00:27:30,700
Now you might notice
that the little vehicles

562
00:27:30,700 --> 00:27:32,850
are not moving around in this system

563
00:27:32,850 --> 00:27:34,818
and that's because there is a little bit

564
00:27:34,818 --> 00:27:37,745
of a problem with using
the web socket technology

565
00:27:37,745 --> 00:27:41,428
that I've used here on Play With Docker.

566
00:27:41,428 --> 00:27:43,566
If you're interested,
it's a problem to do with

567
00:27:43,566 --> 00:27:45,520
cross-site scripting,

568
00:27:45,520 --> 00:27:48,054
and I haven't had time
to debug that problem

569
00:27:48,054 --> 00:27:49,626
before releasing the course,

570
00:27:49,626 --> 00:27:52,215
it's not serious, I'm
not bothered about that,

571
00:27:52,215 --> 00:27:54,698
just as long as the
containers are standing up

572
00:27:54,698 --> 00:27:56,944
and appear to be working, I'm happy.

573
00:27:56,944 --> 00:27:58,360
When we move across to running this

574
00:27:58,360 --> 00:27:59,644
on some Amazon instances,

575
00:27:59,644 --> 00:28:01,852
we'd definitely want that to work,

576
00:28:01,852 --> 00:28:04,433
but for here, I think it's enough.

577
00:28:04,433 --> 00:28:07,192
So, I think that's enough for
a basic demo of docker swarm.

578
00:28:07,192 --> 00:28:09,831
There's still a lot more
to learn with docker swarm,

579
00:28:09,831 --> 00:28:12,043
and we're going to be doing
that in future chapters

580
00:28:12,043 --> 00:28:14,140
when we expand the architecture to

581
00:28:14,140 --> 00:28:17,019
incorporate our own microservices,

582
00:28:17,019 --> 00:28:19,240
but also we're going to spin this out

583
00:28:19,240 --> 00:28:22,013
onto some Amazon EC2 instances.

584
00:28:22,013 --> 00:28:24,338
So lots more to come with swarm,

585
00:28:24,338 --> 00:28:25,938
but in the next chapter,

586
00:28:25,938 --> 00:28:29,031
we'll look at a concept
called docker stacks,

587
00:28:29,031 --> 00:28:30,895
which will certainly make working with

588
00:28:30,895 --> 00:28:33,264
swarm a lot easier.

589
00:28:33,264 --> 00:28:34,847
I'll see you then.

1
00:00:00,393 --> 00:00:02,386
- [Instructor] Hello and
welcome back, in this chapter

2
00:00:02,386 --> 00:00:05,175
we're going to automate
the deployment of services

3
00:00:05,175 --> 00:00:07,258
to a swarm using a stack.

4
00:00:09,232 --> 00:00:12,793
And really, as long as you
already know Docker Compose,

5
00:00:12,793 --> 00:00:15,469
which we covered earlier,
then there's very little

6
00:00:15,469 --> 00:00:17,098
to learn in this chapter.

7
00:00:17,098 --> 00:00:18,864
So that's going to give us time to look at

8
00:00:18,864 --> 00:00:23,031
a few extra aspects to swarms,
such as deployment options,

9
00:00:24,011 --> 00:00:26,891
and how to visualise your swarm.

10
00:00:26,891 --> 00:00:29,042
So in the previous chapter
we used the wonderful

11
00:00:29,042 --> 00:00:33,369
Play with Docker to experiment
with working with a swarm.

12
00:00:33,369 --> 00:00:35,090
Now I'm on a brand new session.

13
00:00:35,090 --> 00:00:38,552
As you know you only have four hours.

14
00:00:38,552 --> 00:00:41,213
You can always start a brand new session,

15
00:00:41,213 --> 00:00:42,571
it just means that any work

16
00:00:42,571 --> 00:00:45,143
you've done previously will be lost.

17
00:00:45,143 --> 00:00:46,212
And that's not a problem

18
00:00:46,212 --> 00:00:48,323
because we're just using
this as a playground.

19
00:00:48,323 --> 00:00:50,826
In the next chapter we'll
finally get to deploy

20
00:00:50,826 --> 00:00:53,409
to some really hardware on EC2.

21
00:00:54,732 --> 00:00:57,486
But in the previous chapter we
set up a couple of instances

22
00:00:57,486 --> 00:01:00,152
and we initialised a swarm.

23
00:01:00,152 --> 00:01:02,016
I can tell you now, I don't
know if you've noticed,

24
00:01:02,016 --> 00:01:04,766
there is a little tool icon here.

25
00:01:05,688 --> 00:01:07,915
This is the templates menu,

26
00:01:07,915 --> 00:01:12,377
and this enables you to
set up a pre-defined swarm.

27
00:01:12,377 --> 00:01:14,466
So it's much easier to do it this way

28
00:01:14,466 --> 00:01:16,689
than what we did previously.

29
00:01:16,689 --> 00:01:18,332
I'm going to go for this option here,

30
00:01:18,332 --> 00:01:22,082
which is three manager
nodes and two workers.

31
00:01:23,606 --> 00:01:27,327
So that's going to save me probably about

32
00:01:27,327 --> 00:01:30,041
four or five minutes of work.

33
00:01:30,041 --> 00:01:33,303
So it's automatically
done a docker swarm in it

34
00:01:33,303 --> 00:01:36,804
on the first node, and
then the other nodes

35
00:01:36,804 --> 00:01:41,261
have automatically been joined
either as manager or workers.

36
00:01:41,261 --> 00:01:45,428
And we can do a docker node
LS as previously to confirm.

37
00:01:46,424 --> 00:01:49,869
The manager status here,
the entry marked as leader

38
00:01:49,869 --> 00:01:53,811
is the instance that
initialised the swarm.

39
00:01:53,811 --> 00:01:57,422
The two marked as reachable
are the other two managers.

40
00:01:57,422 --> 00:02:01,450
And the two with no
status are just workers.

41
00:02:01,450 --> 00:02:02,930
And before we go on to stacks

42
00:02:02,930 --> 00:02:05,463
I think this is probably
a good time to talk about

43
00:02:05,463 --> 00:02:08,150
the difference between
a manager and a worker

44
00:02:08,150 --> 00:02:11,224
and how many of them you
should have in a swarm.

45
00:02:11,224 --> 00:02:13,554
As you saw in the previous chapter,

46
00:02:13,554 --> 00:02:16,207
from a container point of
view there's no difference

47
00:02:16,207 --> 00:02:18,500
between a manager and a worker.

48
00:02:18,500 --> 00:02:20,945
Both managers and workers

49
00:02:20,945 --> 00:02:24,624
will have containers deployed to them.

50
00:02:24,624 --> 00:02:27,732
The difference between
a manager and a worker

51
00:02:27,732 --> 00:02:31,582
as you saw in the previous
chapter is that on a manager

52
00:02:31,582 --> 00:02:34,397
and I am on one of the manager nodes,

53
00:02:34,397 --> 00:02:36,542
I can manage the swarm.

54
00:02:36,542 --> 00:02:41,059
So I can do things such
as docker service LS.

55
00:02:41,059 --> 00:02:44,855
And I can do that from any
manager, so here's manager2.

56
00:02:44,855 --> 00:02:47,355
Docker service LS, no problem.

57
00:02:48,529 --> 00:02:52,363
But workers, we can't manage the swarm.

58
00:02:52,363 --> 00:02:55,363
So docker service LS here will fail.

59
00:02:58,152 --> 00:03:01,341
That's really the only
difference between them.

60
00:03:01,341 --> 00:03:03,549
So you might be wondering
well why don't we just make

61
00:03:03,549 --> 00:03:07,716
all of the nodes be managers,
and actually you can.

62
00:03:08,965 --> 00:03:12,253
The only problem with
that is there is a lot

63
00:03:12,253 --> 00:03:15,582
of communication between
the manager nodes.

64
00:03:15,582 --> 00:03:17,810
If you're interested in
the deep details of this,

65
00:03:17,810 --> 00:03:22,445
it uses a raft system to
communicate between the managers.

66
00:03:22,445 --> 00:03:25,694
Do explore that if you're
interested, but the point of that

67
00:03:25,694 --> 00:03:28,106
is the more managers you have,

68
00:03:28,106 --> 00:03:30,139
the more work will be involved

69
00:03:30,139 --> 00:03:33,475
in keeping those managers in sync.

70
00:03:33,475 --> 00:03:35,529
So you might come at it the
other way then and think

71
00:03:35,529 --> 00:03:37,779
well why don't we just have one manager

72
00:03:37,779 --> 00:03:40,230
and make everything else be workers.

73
00:03:40,230 --> 00:03:41,710
And the problem with that would be,

74
00:03:41,710 --> 00:03:45,877
if the only manager crashes
then your swarm is unusable.

75
00:03:46,795 --> 00:03:48,462
So the usual advice,

76
00:03:49,657 --> 00:03:52,658
I won't go into too much
detail on this for the course,

77
00:03:52,658 --> 00:03:56,871
but if you are administering
a swarm of docker instances,

78
00:03:56,871 --> 00:03:59,205
then do check the administration guide

79
00:03:59,205 --> 00:04:01,714
at the URL you can see here.

80
00:04:01,714 --> 00:04:05,976
And they talk in some
detail about a good balance

81
00:04:05,976 --> 00:04:08,387
between managers and workers.

82
00:04:08,387 --> 00:04:12,320
And I think the key point
here is that they recommend

83
00:04:12,320 --> 00:04:16,210
maintaining an odd number
of managers in the swarm.

84
00:04:16,210 --> 00:04:18,321
You might be familiar with this concept,

85
00:04:18,321 --> 00:04:22,058
we've covered it previously
on our NoSQL course

86
00:04:22,058 --> 00:04:23,805
where we look at Mongo databases

87
00:04:23,805 --> 00:04:26,326
and we do exactly the same thing there.

88
00:04:26,326 --> 00:04:27,822
With an odd number of instances

89
00:04:27,822 --> 00:04:30,514
in the event of a network
partition it's much easier

90
00:04:30,514 --> 00:04:33,795
for the raft system to continue operating.

91
00:04:33,795 --> 00:04:35,999
So actually I think this
template is a really good one.

92
00:04:35,999 --> 00:04:40,196
We have five instances, and
we need more than one manager

93
00:04:40,196 --> 00:04:42,993
but we need an odd number of managers.

94
00:04:42,993 --> 00:04:46,043
So three managers I think
is a really good choice.

95
00:04:46,043 --> 00:04:49,249
We could have had five, but
that would probably be overkill,

96
00:04:49,249 --> 00:04:51,589
so three's a good compromise.

97
00:04:51,589 --> 00:04:53,551
Anyway we're not really here to talk about

98
00:04:53,551 --> 00:04:57,999
managers and workers, we're
here to talk about stacks.

99
00:04:57,999 --> 00:05:00,998
You'll remember from the
previous chapter that to set up

100
00:05:00,998 --> 00:05:03,983
our very basic system
with just two containers,

101
00:05:03,983 --> 00:05:07,066
we have to do a docker service create

102
00:05:08,113 --> 00:05:09,986
and then we had to remember that huge

103
00:05:09,986 --> 00:05:12,886
great long list of command line arguments.

104
00:05:12,886 --> 00:05:15,371
Well we had exactly this discussion

105
00:05:15,371 --> 00:05:18,660
back on the chapter on Docker Compose.

106
00:05:18,660 --> 00:05:21,958
You'll remember that we
wrote a reasonably simple

107
00:05:21,958 --> 00:05:24,756
YAML text file which was declaring

108
00:05:24,756 --> 00:05:27,032
the containers that we needed.

109
00:05:27,032 --> 00:05:29,056
And that meant when
doing local development

110
00:05:29,056 --> 00:05:31,731
we could just type docker compose up

111
00:05:31,731 --> 00:05:33,489
and it would spin up containers

112
00:05:33,489 --> 00:05:36,703
based on the definition that we have here.

113
00:05:36,703 --> 00:05:39,203
So you might be thinking,

114
00:05:39,203 --> 00:05:43,370
perhaps we can use Docker
Compose in a docker swarm.

115
00:05:44,318 --> 00:05:47,149
The answer's kind of yes and kind of no.

116
00:05:47,149 --> 00:05:48,516
In fact as you probably guessed

117
00:05:48,516 --> 00:05:50,278
from the title of this chapter,

118
00:05:50,278 --> 00:05:54,445
when we're working in a swarm,
we have a concept of a stack.

119
00:05:55,748 --> 00:05:57,462
And you can think of a stack

120
00:05:57,462 --> 00:06:00,712
as simply being a complete application.

121
00:06:01,883 --> 00:06:06,050
On one of your manager nodes
you can do a docker stack LS

122
00:06:07,646 --> 00:06:09,545
and you'll see that we get an answer back.

123
00:06:09,545 --> 00:06:13,259
We currently have none of
these stacks but we can now

124
00:06:13,259 --> 00:06:16,948
go ahead and create one
or more of these stacks.

125
00:06:16,948 --> 00:06:21,115
And just think of a stack as
being a single application.

126
00:06:22,907 --> 00:06:25,359
And what we can do to
define that application

127
00:06:25,359 --> 00:06:28,773
is write a simple-ish text file

128
00:06:28,773 --> 00:06:33,440
determining what we want
to appear in that stack.

129
00:06:33,440 --> 00:06:35,150
And what's great about this is

130
00:06:35,150 --> 00:06:38,654
I guess whoever invented
stack could have gone

131
00:06:38,654 --> 00:06:42,272
and invented their own
language, their own text file

132
00:06:42,272 --> 00:06:45,269
to define the contents of a stack,

133
00:06:45,269 --> 00:06:49,436
but we don't need to because
the syntax of Docker Compose

134
00:06:50,970 --> 00:06:55,844
is almost identical to the
syntax of Docker Stack.

135
00:06:55,844 --> 00:06:58,377
So that means we're going
to be able to simply

136
00:06:58,377 --> 00:07:01,616
take our Docker Compose
file that we wrote earlier,

137
00:07:01,616 --> 00:07:04,096
and we're going to be able to reuse it

138
00:07:04,096 --> 00:07:05,926
as a stack definition.

139
00:07:05,926 --> 00:07:08,573
So how do we do that,
well all we have to do

140
00:07:08,573 --> 00:07:09,990
to deploy a stack

141
00:07:10,898 --> 00:07:13,731
is the command docker stack deploy

142
00:07:16,011 --> 00:07:19,424
followed by -C and the name of the file

143
00:07:19,424 --> 00:07:22,104
that we're using to define our stack.

144
00:07:22,104 --> 00:07:24,470
So actually all we need to
do is transfer this file

145
00:07:24,470 --> 00:07:26,698
across to Play with Docker.

146
00:07:26,698 --> 00:07:29,068
I guess we could SFTP the file across

147
00:07:29,068 --> 00:07:32,158
to play-with-docker.com, but to be honest

148
00:07:32,158 --> 00:07:34,305
I really can't be bothered
to even attempt that

149
00:07:34,305 --> 00:07:36,640
because it's such a small file.

150
00:07:36,640 --> 00:07:39,894
So we could just use a
text that it's like VI

151
00:07:39,894 --> 00:07:42,378
and create that file locally here.

152
00:07:42,378 --> 00:07:46,212
Actually my editor Matt Greencroft
has banned the use of VI

153
00:07:46,212 --> 00:07:49,089
on our training courses,
which is deeply irritating,

154
00:07:49,089 --> 00:07:51,466
so I'm going to use the nano editor

155
00:07:51,466 --> 00:07:53,402
but unfortunately by default

156
00:07:53,402 --> 00:07:56,527
it's not installed on Play with Docker.

157
00:07:56,527 --> 00:07:58,655
But we can instal it easily.

158
00:07:58,655 --> 00:08:02,896
Play with Docker uses the
APK package management tool

159
00:08:02,896 --> 00:08:04,813
so we do a APK add nano

160
00:08:07,346 --> 00:08:09,245
but you also have to add in the

161
00:08:09,245 --> 00:08:10,078
- -no-cache

162
00:08:13,427 --> 00:08:15,701
command line argument.

163
00:08:15,701 --> 00:08:18,379
And that will just take a few seconds.

164
00:08:18,379 --> 00:08:20,634
And now we have nano installed.

165
00:08:20,634 --> 00:08:23,967
So we can do a nano docker compose.yaml,

166
00:08:25,654 --> 00:08:29,213
and we'll copy the contents of
the Docker Compose YAML file

167
00:08:29,213 --> 00:08:31,297
you created in the previous chapter.

168
00:08:31,297 --> 00:08:34,382
If you didn't watch that
chapter and you don't have

169
00:08:34,382 --> 00:08:37,363
a copy of that then you will find a copy

170
00:08:37,363 --> 00:08:40,651
in the fleetman webapp project

171
00:08:40,651 --> 00:08:43,362
in the practicals and
code download folder,

172
00:08:43,362 --> 00:08:47,017
and you'll find that in the
chapter called docker-compose.

173
00:08:47,017 --> 00:08:50,651
So once you've got that,
just paste it into your file.

174
00:08:50,651 --> 00:08:52,037
Now before I save this file,

175
00:08:52,037 --> 00:08:54,986
let's have a quick review of
what we were doing in there.

176
00:08:54,986 --> 00:08:57,592
Now the first thing to point
out is I was a little casual

177
00:08:57,592 --> 00:09:01,691
about this earlier, but we
have a services tag here.

178
00:09:01,691 --> 00:09:04,203
I've said several times
that that should make sense

179
00:09:04,203 --> 00:09:07,693
because these containers
are representing services,

180
00:09:07,693 --> 00:09:10,151
but I hope you can see
now that the terminology

181
00:09:10,151 --> 00:09:12,008
has really come together.

182
00:09:12,008 --> 00:09:14,264
When we're working in a docker swarm

183
00:09:14,264 --> 00:09:17,909
we really are deploying
services rather than containers,

184
00:09:17,909 --> 00:09:21,447
but everything here still applies.

185
00:09:21,447 --> 00:09:23,455
I do want to point out the network here.

186
00:09:23,455 --> 00:09:26,062
Now previously when we ran this locally,

187
00:09:26,062 --> 00:09:29,262
this would have created a bridge network.

188
00:09:29,262 --> 00:09:32,043
Do we need to go in here and specify

189
00:09:32,043 --> 00:09:36,246
that this needs to be
an overlay network now.

190
00:09:36,246 --> 00:09:39,558
Well actually we don't, if we
don't specify a driver in here

191
00:09:39,558 --> 00:09:43,725
then Docker Stacks will assume
we want a default driver.

192
00:09:44,867 --> 00:09:48,716
And when you're in a swarm
the default is an overlay.

193
00:09:48,716 --> 00:09:52,845
And when you're running locally
the default is a bridge.

194
00:09:52,845 --> 00:09:55,821
So I have seen people in these files

195
00:09:55,821 --> 00:09:59,200
hard code the type of driver in here,

196
00:09:59,200 --> 00:10:00,796
and I think that's a mistake

197
00:10:00,796 --> 00:10:03,245
because that would mean
you wouldn't be able

198
00:10:03,245 --> 00:10:06,578
to use this file locally and in a swarm,

199
00:10:07,573 --> 00:10:10,094
and generally that's what
we're gonna aim to do.

200
00:10:10,094 --> 00:10:12,397
We don't want to change
this file at all really

201
00:10:12,397 --> 00:10:16,917
compared to how we were using
it in local development.

202
00:10:16,917 --> 00:10:19,040
So that's a lot of talk really

203
00:10:19,040 --> 00:10:22,305
just to say reuse your
Docker Compose file.

204
00:10:22,305 --> 00:10:25,337
A Control + O will write out the file.

205
00:10:25,337 --> 00:10:28,170
Hit Enter, and a Control + X.

206
00:10:29,104 --> 00:10:33,023
And now all we need to do
is to deploy that stack.

207
00:10:33,023 --> 00:10:35,297
And as always all of the commands

208
00:10:35,297 --> 00:10:37,496
that we're doing on this
course, or most of them anyway,

209
00:10:37,496 --> 00:10:40,342
will be in the PDF
document that you can find

210
00:10:40,342 --> 00:10:43,410
in the practicals and code
folder for this course.

211
00:10:43,410 --> 00:10:45,571
But to deploy a stack based on that file

212
00:10:45,571 --> 00:10:47,821
we do a docker stack deploy

213
00:10:49,494 --> 00:10:52,911
then a -C, which stands for compose file.

214
00:10:53,990 --> 00:10:56,740
So using the docker-compose.yaml.

215
00:10:58,188 --> 00:11:00,785
For some reason my tab
completion's not working here

216
00:11:00,785 --> 00:11:03,911
so you might have to
type that our long-hand.

217
00:11:03,911 --> 00:11:06,127
I implied earlier that we can have

218
00:11:06,127 --> 00:11:10,245
multiple stacks running at the same time.

219
00:11:10,245 --> 00:11:11,555
That's really the big difference

220
00:11:11,555 --> 00:11:14,707
between Stack and Docker Compose.

221
00:11:14,707 --> 00:11:17,639
And each stack will represent I would say

222
00:11:17,639 --> 00:11:19,789
a single application.

223
00:11:19,789 --> 00:11:22,501
So you must remember when
you're deploying a stack

224
00:11:22,501 --> 00:11:25,574
that you have to give it a name.

225
00:11:25,574 --> 00:11:28,019
And that's the final option here.

226
00:11:28,019 --> 00:11:30,942
So I'm going to go for fleetman-stack

227
00:11:30,942 --> 00:11:34,318
it can really be anything you like.

228
00:11:34,318 --> 00:11:36,292
And that's all there is to it.

229
00:11:36,292 --> 00:11:39,552
That will now run the services

230
00:11:39,552 --> 00:11:41,653
based on all of those
command line arguments

231
00:11:41,653 --> 00:11:43,182
that we specified.

232
00:11:43,182 --> 00:11:44,884
And it seemed to work.

233
00:11:44,884 --> 00:11:47,217
If I do a docker service LS,

234
00:11:48,545 --> 00:11:52,712
yeah I've got two services,
they're not currently running.

235
00:12:00,792 --> 00:12:01,625
Good.

236
00:12:02,522 --> 00:12:06,372
I've done a few docker
service LSs in sequence

237
00:12:06,372 --> 00:12:08,700
and I've been very lucky
in that I've caught

238
00:12:08,700 --> 00:12:11,548
an interesting situation at this point.

239
00:12:11,548 --> 00:12:14,285
So I'm gonna talk a little bit about this.

240
00:12:14,285 --> 00:12:16,209
You're probably not
surprised that as I was doing

241
00:12:16,209 --> 00:12:19,018
docker service LS several times

242
00:12:19,018 --> 00:12:21,498
and I was doing it in
quite quick succession,

243
00:12:21,498 --> 00:12:25,665
each time I was getting zero
of one in the replicas column.

244
00:12:26,784 --> 00:12:27,999
No surprise there at all,

245
00:12:27,999 --> 00:12:31,313
this simply means that the
services were starting up,

246
00:12:31,313 --> 00:12:33,860
or I should really say
the underlying containers

247
00:12:33,860 --> 00:12:37,733
for the service were just starting up.

248
00:12:37,733 --> 00:12:41,147
And it can take some
time for that to happen.

249
00:12:41,147 --> 00:12:45,529
But I was very lucky in
this particular situation

250
00:12:45,529 --> 00:12:49,394
that on my last docker
service LS, can you see,

251
00:12:49,394 --> 00:12:51,644
that the web app is running

252
00:12:52,791 --> 00:12:54,708
but the database isn't.

253
00:12:55,918 --> 00:12:58,258
Now that's simply due to timing,

254
00:12:58,258 --> 00:13:01,869
it's simply due to the
order in which the swarm

255
00:13:01,869 --> 00:13:05,278
has decided to start up these containers.

256
00:13:05,278 --> 00:13:07,981
I want to mention that
that depends on flag

257
00:13:07,981 --> 00:13:11,187
that we have in the compose
file is going to be ignored.

258
00:13:11,187 --> 00:13:14,481
Basically these containers
will be started in parallel

259
00:13:14,481 --> 00:13:16,470
and you don't really have much control

260
00:13:16,470 --> 00:13:20,074
over the order in which they start.

261
00:13:20,074 --> 00:13:22,006
So you might be thinking oh no we're back

262
00:13:22,006 --> 00:13:25,540
to that long discussion
that we had previously

263
00:13:25,540 --> 00:13:27,522
about how we can force the containers

264
00:13:27,522 --> 00:13:29,980
to start in a certain order.

265
00:13:29,980 --> 00:13:34,952
But it turns out in a swarm,
in general it doesn't matter.

266
00:13:34,952 --> 00:13:38,011
If we look at this specific situation

267
00:13:38,011 --> 00:13:40,355
you know now that the fleetman web app,

268
00:13:40,355 --> 00:13:45,226
because it started up first,
it's going to have crashed.

269
00:13:45,226 --> 00:13:47,858
It won't have found a database running

270
00:13:47,858 --> 00:13:50,247
so it will have fallen over.

271
00:13:50,247 --> 00:13:52,915
But one of the wonderful features of Swarm

272
00:13:52,915 --> 00:13:55,595
is that by default we can tune this,

273
00:13:55,595 --> 00:13:57,649
I'll show you how to do that later,

274
00:13:57,649 --> 00:14:01,056
but by default what Swarm will do

275
00:14:01,056 --> 00:14:03,515
is if a container crashes

276
00:14:03,515 --> 00:14:07,990
Swarm will automatically
restart that container.

277
00:14:07,990 --> 00:14:12,086
So we have a nice situation
now in that this attempt

278
00:14:12,086 --> 00:14:14,103
will definitely have crashed,

279
00:14:14,103 --> 00:14:15,564
but I've been talking an waffling

280
00:14:15,564 --> 00:14:17,556
for quite a few minutes now.

281
00:14:17,556 --> 00:14:19,148
I reckon that by the time I do

282
00:14:19,148 --> 00:14:22,438
a docker service LS this time,

283
00:14:22,438 --> 00:14:24,858
yeah the database has started up,

284
00:14:24,858 --> 00:14:29,225
but notice that the web
app is still running.

285
00:14:29,225 --> 00:14:32,323
Even though we can infer
that almost certainly

286
00:14:32,323 --> 00:14:36,490
that web app crashed at
least once when starting up.

287
00:14:37,388 --> 00:14:40,073
And we can verify this
by as usual following

288
00:14:40,073 --> 00:14:44,462
the 80 link here because
we're publishing port 80.

289
00:14:44,462 --> 00:14:47,237
And yeah there's our application standing.

290
00:14:47,237 --> 00:14:48,855
As I mentioned in the previous chapter

291
00:14:48,855 --> 00:14:51,497
don't worry that the
markers are not moving,

292
00:14:51,497 --> 00:14:53,523
that's a development
problem that I would expect

293
00:14:53,523 --> 00:14:55,992
the coder to fix at some
point in the future.

294
00:14:55,992 --> 00:14:59,076
It doesn't work well on Play with Docker.

295
00:14:59,076 --> 00:15:02,358
It'll work just fine
when we move across EC2.

296
00:15:02,358 --> 00:15:04,431
But that's really quite
fantastic, it means that we have

297
00:15:04,431 --> 00:15:07,751
a large degree of resilience in our swarm.

298
00:15:07,751 --> 00:15:12,255
Now to demonstrate this,
I'm going to find the node

299
00:15:12,255 --> 00:15:14,463
on which this web app is running,

300
00:15:14,463 --> 00:15:15,900
and we'll kill the container

301
00:15:15,900 --> 00:15:17,958
and we'll verify that it really will

302
00:15:17,958 --> 00:15:19,894
just spring back up again.

303
00:15:19,894 --> 00:15:21,918
I don't think I've shown
you how to find out

304
00:15:21,918 --> 00:15:25,460
on which node a particular
service is running.

305
00:15:25,460 --> 00:15:29,127
Well we can do that
using docker service PS,

306
00:15:30,768 --> 00:15:32,457
for process.

307
00:15:32,457 --> 00:15:34,638
And then the name of the service,

308
00:15:34,638 --> 00:15:37,471
so fleetman-stack_fleetman-webapp.

309
00:15:39,584 --> 00:15:42,478
It's not that easy to read here, but aha,

310
00:15:42,478 --> 00:15:45,032
actually I'd forgot this,
this shows me kind of

311
00:15:45,032 --> 00:15:48,200
the history of the service as well.

312
00:15:48,200 --> 00:15:52,731
And this actually confirms
that yeah four minutes ago

313
00:15:52,731 --> 00:15:56,064
this service started up on node worker2.

314
00:15:58,290 --> 00:16:01,733
However, also four minutes ago,
and that will be a bit more

315
00:16:01,733 --> 00:16:05,507
than four minutes ago,
be earlier than this one,

316
00:16:05,507 --> 00:16:09,257
this one tried to run
on manager2 but failed.

317
00:16:10,494 --> 00:16:13,003
Well that's fantastic,
that's really confirmed

318
00:16:13,003 --> 00:16:16,834
what I was guessing had
happened in the background.

319
00:16:16,834 --> 00:16:19,032
It means now if we go to this node here,

320
00:16:19,032 --> 00:16:20,314
for you it will be different,

321
00:16:20,314 --> 00:16:23,200
but I can go to the worker2 node.

322
00:16:23,200 --> 00:16:25,479
So here we are, now we
can't do any swarm commands,

323
00:16:25,479 --> 00:16:28,564
but we can do a docker container LS.

324
00:16:28,564 --> 00:16:31,047
That is indeed the
container that was working.

325
00:16:31,047 --> 00:16:33,838
Now I can simulate perhaps
this node crashing,

326
00:16:33,838 --> 00:16:36,193
or some I don't know network failure

327
00:16:36,193 --> 00:16:39,356
or disc problem with this particular node.

328
00:16:39,356 --> 00:16:41,856
I could do a docker container.

329
00:16:42,707 --> 00:16:46,118
If I do a --help, I can actually,

330
00:16:46,118 --> 00:16:48,302
I don't think I've ever
used this on the course.

331
00:16:48,302 --> 00:16:50,449
I wouldn't normally use the kill command,

332
00:16:50,449 --> 00:16:53,961
that will sort of
violently kill a container.

333
00:16:53,961 --> 00:16:55,347
So I wouldn't normally do that

334
00:16:55,347 --> 00:16:57,013
but it will be good for this demo.

335
00:16:57,013 --> 00:16:59,096
Docker container kill 84.

336
00:17:01,126 --> 00:17:04,623
And then I'm going to
as quickly as possible,

337
00:17:04,623 --> 00:17:08,981
switch across back to my manager
and do a docker service LS.

338
00:17:08,981 --> 00:17:13,148
And yeah we have no replicas
now of that fleetman web app.

339
00:17:14,516 --> 00:17:16,433
If I just sit and wait,

340
00:17:17,695 --> 00:17:21,862
aha, see we've sprung back to
one replica being available.

341
00:17:23,110 --> 00:17:24,996
Now I'll need to wait a little bit

342
00:17:24,996 --> 00:17:27,374
and play for time for a few seconds.

343
00:17:27,374 --> 00:17:32,261
We'll take some time for
that web app to fully start.

344
00:17:32,261 --> 00:17:34,317
And you see I've just
followed the link there

345
00:17:34,317 --> 00:17:37,330
to port 80 and we have an error,

346
00:17:37,330 --> 00:17:40,880
that will just be because
it's still starting up.

347
00:17:40,880 --> 00:17:45,303
If I be a bit patient,
and yet do a refresh,

348
00:17:45,303 --> 00:17:49,470
the container is back up and
running, which is fantastic.

349
00:17:50,694 --> 00:17:52,549
Now something I want to warn you about

350
00:17:52,549 --> 00:17:56,190
is that you might have a problem
when looking at the logs.

351
00:17:56,190 --> 00:17:57,940
If I docker container

352
00:17:59,828 --> 00:18:01,957
so docker service LS.

353
00:18:01,957 --> 00:18:03,440
Now I've shown you that we can do

354
00:18:03,440 --> 00:18:06,273
a docker service logs -F as usual.

355
00:18:08,615 --> 00:18:10,172
And then the name of the service

356
00:18:10,172 --> 00:18:13,005
is fleetman-stack_fleetman-webapp.

357
00:18:16,086 --> 00:18:18,866
And can you see there that we're seeing

358
00:18:18,866 --> 00:18:21,880
an exception right at the end here.

359
00:18:21,880 --> 00:18:25,767
And that exception is, and I
know this from previous work,

360
00:18:25,767 --> 00:18:28,172
it is a connection refused.

361
00:18:28,172 --> 00:18:31,472
Now what we're seeing
here I'm fairly certain

362
00:18:31,472 --> 00:18:33,882
is the log of that crashed container,

363
00:18:33,882 --> 00:18:38,444
that very first container
that started up and then died.

364
00:18:38,444 --> 00:18:40,848
For some reason that I don't understand

365
00:18:40,848 --> 00:18:43,700
we're not seeing the proper logs

366
00:18:43,700 --> 00:18:46,847
of the actual running container.

367
00:18:46,847 --> 00:18:48,598
Let me confirm that.

368
00:18:48,598 --> 00:18:51,431
Again, if I do a docker service PS

369
00:18:53,162 --> 00:18:55,662
fleetman-stack_fleetman-webapp

370
00:19:01,119 --> 00:19:04,536
the running container is on manager2 now.

371
00:19:07,155 --> 00:19:08,655
So here's manager2

372
00:19:09,541 --> 00:19:12,874
and a docker container LS confirms that.

373
00:19:14,464 --> 00:19:16,610
Now if I do a log on this container

374
00:19:16,610 --> 00:19:18,610
docker container logs -F

375
00:19:19,466 --> 00:19:22,699
the ID of the container begins D7.

376
00:19:22,699 --> 00:19:25,203
Now I wasn't quite expecting to see this,

377
00:19:25,203 --> 00:19:27,658
there is a stack trace in here as well.

378
00:19:27,658 --> 00:19:31,730
But actually this is not a
problem, the stack trace here,

379
00:19:31,730 --> 00:19:33,775
I just had to pause the
recording for a minute,

380
00:19:33,775 --> 00:19:37,942
but actually these stack
traces are related to the

381
00:19:39,046 --> 00:19:40,636
web socket problem that you're seeing,

382
00:19:40,636 --> 00:19:43,425
the vehicles are not moving around.

383
00:19:43,425 --> 00:19:46,330
And if we go all the way up here

384
00:19:46,330 --> 00:19:48,562
I don't want to bore you
too much, but I promise you

385
00:19:48,562 --> 00:19:51,194
I have checked this
stack trace off camera,

386
00:19:51,194 --> 00:19:54,705
and there is no problems
with the database at all,

387
00:19:54,705 --> 00:19:58,156
the database is absolutely fine.

388
00:19:58,156 --> 00:20:01,398
And the point of that is we
are seeing a different log

389
00:20:01,398 --> 00:20:04,096
here in the container to the log

390
00:20:04,096 --> 00:20:07,429
that we're seeing if I do a service log.

391
00:20:08,524 --> 00:20:10,007
Now at the time I'm recording this,

392
00:20:10,007 --> 00:20:14,745
the ability to logs from the
services is actually very new.

393
00:20:14,745 --> 00:20:17,101
And I have a feeling that
there's some kind of a bug

394
00:20:17,101 --> 00:20:19,307
that I've been affected by there.

395
00:20:19,307 --> 00:20:20,651
By the time you watch this video

396
00:20:20,651 --> 00:20:22,218
it might not be a problem for you,

397
00:20:22,218 --> 00:20:25,856
but if you do see strange
results with the logs then

398
00:20:25,856 --> 00:20:28,300
it might be because you're being
affected by the same thing.

399
00:20:28,300 --> 00:20:31,385
So we won't get hung up on it
on the course, the point is

400
00:20:31,385 --> 00:20:35,466
the container for this
service is definitely running.

401
00:20:35,466 --> 00:20:37,792
If there had been a MySQL exception

402
00:20:37,792 --> 00:20:40,993
then the application
would never have started.

403
00:20:40,993 --> 00:20:43,708
So we've seen that when
we're launching services

404
00:20:43,708 --> 00:20:46,615
the services are more than containers.

405
00:20:46,615 --> 00:20:50,059
The main difference between
a service and a container

406
00:20:50,059 --> 00:20:54,647
is that a service by default
is resilient to failure.

407
00:20:54,647 --> 00:20:57,609
If the underlying container
crashes for any reason

408
00:20:57,609 --> 00:21:00,740
then the swarm will automatically fire up

409
00:21:00,740 --> 00:21:03,392
a new instance of that container.

410
00:21:03,392 --> 00:21:05,003
So you might be wondering,

411
00:21:05,003 --> 00:21:09,705
can we have more than one
instance of a service.

412
00:21:09,705 --> 00:21:12,878
Certainly the column here,
given it's called replicas,

413
00:21:12,878 --> 00:21:14,543
implies that's the case.

414
00:21:14,543 --> 00:21:17,868
And the answer is absolutely yes you can.

415
00:21:17,868 --> 00:21:20,585
Now on this system so far I don't have

416
00:21:20,585 --> 00:21:22,998
a great demonstration for this.

417
00:21:22,998 --> 00:21:27,291
I haven't really designed
this system to be replicated.

418
00:21:27,291 --> 00:21:30,349
But we can certainly for an experiment,

419
00:21:30,349 --> 00:21:35,316
have a go at creating two
replicas of the web application.

420
00:21:35,316 --> 00:21:36,994
It won't work perfectly,

421
00:21:36,994 --> 00:21:39,985
but it will be at least a good demo.

422
00:21:39,985 --> 00:21:44,587
Now the way we can do that is
by editing the compose file.

423
00:21:44,587 --> 00:21:47,963
So we'll go back into dockercompose.yaml.

424
00:21:47,963 --> 00:21:51,179
And we can extend the
docker compose file to add

425
00:21:51,179 --> 00:21:53,922
further information about
how we want this system

426
00:21:53,922 --> 00:21:56,982
to be deployed to production.

427
00:21:56,982 --> 00:21:58,242
The way that we do that,

428
00:21:58,242 --> 00:22:01,107
we're gonna work on the
fleetman webapp service.

429
00:22:01,107 --> 00:22:04,857
We can add in another
tag here called deploy.

430
00:22:06,098 --> 00:22:08,927
And as part of this deploy
tag there's a large set

431
00:22:08,927 --> 00:22:11,630
of configurations that we can apply.

432
00:22:11,630 --> 00:22:15,297
Such as for example,
we can say that we want

433
00:22:16,237 --> 00:22:21,028
two instances of this container
to be running in production.

434
00:22:21,028 --> 00:22:22,233
Now I won't have time on the course

435
00:22:22,233 --> 00:22:25,508
to cover every single
option in this deploy tag,

436
00:22:25,508 --> 00:22:27,434
there's quite a lot of them.

437
00:22:27,434 --> 00:22:29,108
And of course you will find information

438
00:22:29,108 --> 00:22:30,390
about this deploy tag

439
00:22:30,390 --> 00:22:34,355
in the reference manual
for Docker Compose.

440
00:22:34,355 --> 00:22:36,861
Now notice that it's flagged up as being

441
00:22:36,861 --> 00:22:39,058
a version three feature only,

442
00:22:39,058 --> 00:22:42,047
and this is the main
reason why I've insisted

443
00:22:42,047 --> 00:22:46,214
that we use version three
or higher for this course.

444
00:22:47,057 --> 00:22:49,379
And as part of this deploy tag,

445
00:22:49,379 --> 00:22:51,098
they have a little example there,

446
00:22:51,098 --> 00:22:55,619
so they have six replicas
of this particular service.

447
00:22:55,619 --> 00:22:58,046
And they've got an update config

448
00:22:58,046 --> 00:23:01,181
and a restart policy flag as well.

449
00:23:01,181 --> 00:23:04,764
The update config tells
Docker Stack what to do

450
00:23:04,764 --> 00:23:07,881
if you're rolling out a
change to that service.

451
00:23:07,881 --> 00:23:09,833
And this is really powerful
because it gives us

452
00:23:09,833 --> 00:23:13,875
the potential to do
so-called rolling updates.

453
00:23:13,875 --> 00:23:17,696
So you might have modified
the code for a service,

454
00:23:17,696 --> 00:23:21,813
you've pushed the image
and then you tell the stack

455
00:23:21,813 --> 00:23:23,035
that there's been a change.

456
00:23:23,035 --> 00:23:25,278
I'll show you how to do that in a moment.

457
00:23:25,278 --> 00:23:27,968
But using this update config field,

458
00:23:27,968 --> 00:23:29,994
you could for example say,

459
00:23:29,994 --> 00:23:32,402
after each container has been changed,

460
00:23:32,402 --> 00:23:36,033
wait 60 seconds or wait
five minutes or whatever

461
00:23:36,033 --> 00:23:39,160
before going on to do the next container.

462
00:23:39,160 --> 00:23:41,111
And that means you always have at least

463
00:23:41,111 --> 00:23:43,686
one healthy container running.

464
00:23:43,686 --> 00:23:45,444
So that's really useful.

465
00:23:45,444 --> 00:23:47,720
And we also have this restart policy here.

466
00:23:47,720 --> 00:23:51,722
Now we've seen this in action,
is what the swarm should do

467
00:23:51,722 --> 00:23:55,492
if a container for that service fails.

468
00:23:55,492 --> 00:23:58,390
Now they're saying here that on failure

469
00:23:58,390 --> 00:24:00,926
they want the container to restart.

470
00:24:00,926 --> 00:24:03,026
Well actually that's
been kind of the default.

471
00:24:03,026 --> 00:24:05,609
If we scroll down a little bit,

472
00:24:06,668 --> 00:24:10,162
there's full information
about each of these tags.

473
00:24:10,162 --> 00:24:13,618
And here's the information
about the restart policy.

474
00:24:13,618 --> 00:24:16,024
And from here there's actually
three different values

475
00:24:16,024 --> 00:24:20,079
we can specify, it's
none, on-failure, or any.

476
00:24:20,079 --> 00:24:23,218
And we've been running with
the default, which is any.

477
00:24:23,218 --> 00:24:25,901
And it might not be obvious
what the difference is.

478
00:24:25,901 --> 00:24:29,752
On-failure will restart the
container if the command,

479
00:24:29,752 --> 00:24:31,661
remember every container has a,

480
00:24:31,661 --> 00:24:33,988
remember the container
is running a command.

481
00:24:33,988 --> 00:24:37,421
If that command exits with an error code,

482
00:24:37,421 --> 00:24:40,448
then the container would be restarted.

483
00:24:40,448 --> 00:24:44,649
With the any field, then the
container will be restarted

484
00:24:44,649 --> 00:24:48,296
even if the container exits successfully.

485
00:24:48,296 --> 00:24:51,887
So actually in many cases the
command that you're running

486
00:24:51,887 --> 00:24:54,906
will never exit because it's
some kind of a daemon process

487
00:24:54,906 --> 00:24:57,921
like tomcat, or in our case we're running

488
00:24:57,921 --> 00:25:01,281
a long-lived Spring Boot application.

489
00:25:01,281 --> 00:25:03,600
So there isn't a great big
difference between the two

490
00:25:03,600 --> 00:25:06,237
but I thought I'd better mention it.

491
00:25:06,237 --> 00:25:10,425
Also worth mentioning that
we have a max attempts field,

492
00:25:10,425 --> 00:25:13,117
the default is to never give up.

493
00:25:13,117 --> 00:25:16,370
So that's probably okay
in most circumstances,

494
00:25:16,370 --> 00:25:19,673
but you might have a situation
where you have a container

495
00:25:19,673 --> 00:25:22,673
that will sometimes fail
and is not recoverable

496
00:25:22,673 --> 00:25:26,302
for some reason, and you
just want it to stop.

497
00:25:26,302 --> 00:25:28,656
So you might set max attempts to five

498
00:25:28,656 --> 00:25:30,387
or something like that.

499
00:25:30,387 --> 00:25:32,027
Now I'm not going to do a lot of tweaking

500
00:25:32,027 --> 00:25:33,723
of these parameters on this course,

501
00:25:33,723 --> 00:25:36,493
but I wanted you to
know that they're there.

502
00:25:36,493 --> 00:25:39,845
For us it's going to be enough
to specify two replicas.

503
00:25:39,845 --> 00:25:42,760
Now before I run this, I
don't want you to worry

504
00:25:42,760 --> 00:25:46,251
that somehow we've damaged
the docker compose file.

505
00:25:46,251 --> 00:25:48,174
If we wanted to run
our docker compose file

506
00:25:48,174 --> 00:25:51,199
outside of a swarm, like we
did earlier in the course

507
00:25:51,199 --> 00:25:53,365
when we're just locally developing,

508
00:25:53,365 --> 00:25:55,519
then the replicas is irrelevant.

509
00:25:55,519 --> 00:25:59,296
In fact everything in the
deploy tag is irrelevant.

510
00:25:59,296 --> 00:26:03,204
Because the deploy is just for swarms.

511
00:26:03,204 --> 00:26:06,619
It's no problem, this
will simply be ignored.

512
00:26:06,619 --> 00:26:08,311
So that's absolutely great,

513
00:26:08,311 --> 00:26:11,412
it means we can use the
same docker compose file

514
00:26:11,412 --> 00:26:14,333
for development as we use for production,

515
00:26:14,333 --> 00:26:17,606
it's a great feature of Docker Stacks.

516
00:26:17,606 --> 00:26:20,615
As I say I'll write that
file out, Control + O,

517
00:26:20,615 --> 00:26:23,623
hit Enter, Control + X.

518
00:26:23,623 --> 00:26:25,466
As I say, don't expect
great things from this

519
00:26:25,466 --> 00:26:26,873
because I haven't really designed

520
00:26:26,873 --> 00:26:29,899
this system web app to be replicated.

521
00:26:29,899 --> 00:26:32,324
The web sockets feature for example

522
00:26:32,324 --> 00:26:34,927
that's animating the vehicles,

523
00:26:34,927 --> 00:26:38,280
I imagine would be upset by
having multiple replicas.

524
00:26:38,280 --> 00:26:39,589
But we can at least try it.

525
00:26:39,589 --> 00:26:43,927
So how do we update a stack
when we've made changes?

526
00:26:43,927 --> 00:26:47,784
Ridiculously simple, I'm
going to run all the way back

527
00:26:47,784 --> 00:26:51,348
to my original docker
stack deploy command.

528
00:26:51,348 --> 00:26:53,644
You just rerun the deploy command.

529
00:26:53,644 --> 00:26:56,529
And it will make any necessary changes.

530
00:26:56,529 --> 00:26:59,063
It's not going to restart anything.

531
00:26:59,063 --> 00:27:02,829
The database will be
absolutely fine and untouched.

532
00:27:02,829 --> 00:27:04,879
The existing service that we have running

533
00:27:04,879 --> 00:27:07,103
will be fine and untouched.

534
00:27:07,103 --> 00:27:09,595
It's going to work out
from this that we need

535
00:27:09,595 --> 00:27:12,156
an additional instance of the web app.

536
00:27:12,156 --> 00:27:16,299
So let's run that and then
do a docker service LS again.

537
00:27:16,299 --> 00:27:18,822
And yeah, nothing's
changed on the database,

538
00:27:18,822 --> 00:27:22,489
but now we're at one
of two for the web app.

539
00:27:23,670 --> 00:27:26,052
Now we're at two of two.

540
00:27:26,052 --> 00:27:28,538
And if we visit the web app again,

541
00:27:28,538 --> 00:27:31,207
then well we're seeing the web app,

542
00:27:31,207 --> 00:27:34,893
but you might be wondering
which instance of the web app

543
00:27:34,893 --> 00:27:37,477
are we actually visiting here.

544
00:27:37,477 --> 00:27:38,682
What I'm about to show you here

545
00:27:38,682 --> 00:27:41,482
is something called the docker mesh.

546
00:27:41,482 --> 00:27:44,586
On Play with Docker it's not
that easy to demonstrate this

547
00:27:44,586 --> 00:27:47,114
and we will see this much more clearly

548
00:27:47,114 --> 00:27:50,958
when we move across to
EC2 in the next chapter.

549
00:27:50,958 --> 00:27:53,729
Select any of your nodes,
I'm gonna go for this one

550
00:27:53,729 --> 00:27:55,817
because I've not really used it before.

551
00:27:55,817 --> 00:27:58,206
You'll see from the prompt
actually that each of these nodes

552
00:27:58,206 --> 00:28:00,938
has their own private IP address,

553
00:28:00,938 --> 00:28:03,021
such as 10.0.76.6 for me.

554
00:28:05,561 --> 00:28:06,845
Now that's a private IP address,

555
00:28:06,845 --> 00:28:09,425
you can't visit that in a browser.

556
00:28:09,425 --> 00:28:12,994
But what's happening if I hover over

557
00:28:12,994 --> 00:28:15,396
the 80 here at the top

558
00:28:15,396 --> 00:28:17,230
and I'm going to zoom
in a little bit there

559
00:28:17,230 --> 00:28:18,908
to make that clearer.

560
00:28:18,908 --> 00:28:21,860
What they've given you is a domain name.

561
00:28:21,860 --> 00:28:24,355
In my case it's pwt,

562
00:28:24,355 --> 00:28:27,612
and then we're seeing
that IP address again,

563
00:28:27,612 --> 00:28:31,995
10-0, they've just put
dashes in for the dots,

564
00:28:31,995 --> 00:28:32,828
- 76-6.

565
00:28:36,027 --> 00:28:39,777
So every one of my nodes
has its own address.

566
00:28:41,365 --> 00:28:44,187
If I switch to this
one here, this manager,

567
00:28:44,187 --> 00:28:48,544
this one has a private
IP address ending in .5.

568
00:28:48,544 --> 00:28:51,087
And if I hover over the 80 here,

569
00:28:51,087 --> 00:28:55,539
notice that we do actually
have a different address here.

570
00:28:55,539 --> 00:28:59,706
So you might be thinking,
if I go back to the manager,

571
00:29:00,998 --> 00:29:05,617
you might be thinking
that if I click that link

572
00:29:05,617 --> 00:29:09,408
all that's happening here is
we're visiting the instance

573
00:29:09,408 --> 00:29:12,658
that's running on this particular node.

574
00:29:13,966 --> 00:29:17,216
But actually if I do a docker container

575
00:29:18,974 --> 00:29:22,688
LS, it's purely by accident,
I didn't plan this,

576
00:29:22,688 --> 00:29:26,249
but there are no containers
running on this node.

577
00:29:26,249 --> 00:29:28,361
So the web app must be
running somewhere else.

578
00:29:28,361 --> 00:29:31,765
If I do a docker container LS on this

579
00:29:31,765 --> 00:29:36,107
second node, now there's
nothing running there either.

580
00:29:36,107 --> 00:29:40,274
Playing hunt the container
here, if we go to the third one.

581
00:29:41,478 --> 00:29:45,432
Yeah, we have an instance
running on this one.

582
00:29:45,432 --> 00:29:48,349
And then I'll go to the fourth one.

583
00:29:49,598 --> 00:29:52,041
That's the database.

584
00:29:52,041 --> 00:29:57,029
So the other instance must
be running on this one.

585
00:29:57,029 --> 00:29:59,420
So the point of that is,

586
00:29:59,420 --> 00:30:02,724
notice that it actually doesn't matter

587
00:30:02,724 --> 00:30:06,302
which of these addresses I visit.

588
00:30:06,302 --> 00:30:07,599
That's the first of them which is

589
00:30:07,599 --> 00:30:10,250
the IP address ending in three.

590
00:30:10,250 --> 00:30:12,368
Here's the second of them.

591
00:30:12,368 --> 00:30:14,492
I still get the web app.

592
00:30:14,492 --> 00:30:17,113
And here I still get the web app.

593
00:30:17,113 --> 00:30:20,381
Doesn't matter which of the
nodes we visit directly,

594
00:30:20,381 --> 00:30:21,874
what Docker's automatically doing

595
00:30:21,874 --> 00:30:25,644
is it's routing the request
to one of the containers

596
00:30:25,644 --> 00:30:28,328
that's publishing port 80.

597
00:30:28,328 --> 00:30:31,298
In other words it's doing
a kind of load balancing.

598
00:30:31,298 --> 00:30:33,923
From request to request,

599
00:30:33,923 --> 00:30:37,349
on any of these addresses,
doesn't matter which I use,

600
00:30:37,349 --> 00:30:41,559
on any of these addresses
I'm getting one container

601
00:30:41,559 --> 00:30:46,339
or the other container, and
I don't know which is which.

602
00:30:46,339 --> 00:30:51,098
It means that using Docker
Swarm we have an automatic

603
00:30:51,098 --> 00:30:54,323
load balancing system
without the need potentially

604
00:30:54,323 --> 00:30:58,724
for other external load
balancers such as Amazon ELB.

605
00:30:58,724 --> 00:31:00,942
Docker's implementing this via a feature

606
00:31:00,942 --> 00:31:04,143
that it calls its routing mesh.

607
00:31:04,143 --> 00:31:06,651
While here in the UK we
pronounce it routing,

608
00:31:06,651 --> 00:31:09,016
you might pronounce it routing of course.

609
00:31:09,016 --> 00:31:10,414
It's worth putting up a picture

610
00:31:10,414 --> 00:31:13,078
to review what Docker's doing here

611
00:31:13,078 --> 00:31:17,732
because it's really
clever and really elegant.

612
00:31:17,732 --> 00:31:20,143
So here's a picture of a swarm

613
00:31:20,143 --> 00:31:22,893
which has for example four nodes.

614
00:31:23,793 --> 00:31:26,953
And we've been deploying a stack to it.

615
00:31:26,953 --> 00:31:29,671
And the current state
is it's fairly random,

616
00:31:29,671 --> 00:31:34,081
we have node one here which
is the address ending in .24,

617
00:31:34,081 --> 00:31:37,783
which has had our Java
container deployed to it.

618
00:31:37,783 --> 00:31:41,607
Now it's a Java container
running a web application

619
00:31:41,607 --> 00:31:43,895
and let's say it's standard tomcat

620
00:31:43,895 --> 00:31:46,145
so it's exposing port 8080.

621
00:31:47,470 --> 00:31:50,213
As I hope you know by
now that does not mean

622
00:31:50,213 --> 00:31:53,811
that port 8080 is visible to the public.

623
00:31:53,811 --> 00:31:58,496
That port is only visible
within our private network,

624
00:31:58,496 --> 00:32:01,175
the private overlay network.

625
00:32:01,175 --> 00:32:03,403
If this container wanted to ping

626
00:32:03,403 --> 00:32:07,236
this container's port
8080 that would be fine.

627
00:32:08,118 --> 00:32:10,118
If this container wants to ping

628
00:32:10,118 --> 00:32:14,540
this container's port
3306, that's fine too.

629
00:32:14,540 --> 00:32:18,193
In fact that's exactly what
we're doing in our system.

630
00:32:18,193 --> 00:32:20,862
Our web app container is contacting

631
00:32:20,862 --> 00:32:23,862
the database container on port 3306.

632
00:32:24,937 --> 00:32:26,892
But a really important concept

633
00:32:26,892 --> 00:32:30,068
that I cannot get across strongly enough

634
00:32:30,068 --> 00:32:34,600
is that these ports are only
visible to other containers

635
00:32:34,600 --> 00:32:39,185
on that overlay network, they're
not visible to the public.

636
00:32:39,185 --> 00:32:42,596
The only way we can make a
port visible to the public,

637
00:32:42,596 --> 00:32:46,269
as we've seen, is by publishing the port.

638
00:32:46,269 --> 00:32:50,474
That mapping, either using
the -P command line argument

639
00:32:50,474 --> 00:32:53,455
or as we've been doing in
our docker compose file

640
00:32:53,455 --> 00:32:55,705
we're mapping port 80

641
00:32:55,705 --> 00:32:59,072
to the internal port of port 8080,

642
00:32:59,072 --> 00:33:02,603
and that makes port 80 open to the public.

643
00:33:02,603 --> 00:33:03,919
By the way it's also worth mentioning,

644
00:33:03,919 --> 00:33:08,086
we have a node here running
a MySQL container port 3306

645
00:33:09,144 --> 00:33:13,248
and another container here
running another MySQL container.

646
00:33:13,248 --> 00:33:15,339
For some reason we've replicated it,

647
00:33:15,339 --> 00:33:17,413
it's absolutely fine to have multiple

648
00:33:17,413 --> 00:33:21,854
internal container ports
which are the same.

649
00:33:21,854 --> 00:33:23,405
That's absolutely fine.

650
00:33:23,405 --> 00:33:26,822
But we can only publish one of each port,

651
00:33:28,378 --> 00:33:30,266
that's so important.

652
00:33:30,266 --> 00:33:32,569
Now what we've seen in
the previous demonstration

653
00:33:32,569 --> 00:33:35,056
is that if a browser comes along,

654
00:33:35,056 --> 00:33:38,447
that's supposed to be a
browser believe it or not.

655
00:33:38,447 --> 00:33:40,481
And if the browser types in

656
00:33:40,481 --> 00:33:42,981
the IP address of 32.68.89.102

657
00:33:46,405 --> 00:33:49,790
and they're going to go
for the default port 80,

658
00:33:49,790 --> 00:33:51,762
there's nothing special about this node,

659
00:33:51,762 --> 00:33:53,955
it just doesn't happen
to have any containers

660
00:33:53,955 --> 00:33:55,842
running on it but it could have done.

661
00:33:55,842 --> 00:33:59,009
But the important thing is
there is no web app container

662
00:33:59,009 --> 00:34:00,982
running on this node.

663
00:34:00,982 --> 00:34:03,422
But as you've seen now
what will happen seamlessly

664
00:34:03,422 --> 00:34:06,072
in the background, is that request

665
00:34:06,072 --> 00:34:09,703
will be routed or routed to a node

666
00:34:09,703 --> 00:34:12,453
that does have port 80 published.

667
00:34:13,517 --> 00:34:16,735
And all of that will happen
seamlessly in the background.

668
00:34:16,735 --> 00:34:19,232
So this container will respond with data

669
00:34:19,232 --> 00:34:23,202
which will then get returned
back to the user's browser.

670
00:34:23,202 --> 00:34:25,697
So that means you have
a lot of flexibility.

671
00:34:25,697 --> 00:34:27,319
Now it's beyond the scope of the course

672
00:34:27,319 --> 00:34:30,270
as to how you would actually
use this in practise.

673
00:34:30,270 --> 00:34:34,051
It might be that you just set
up one of these IP addresses

674
00:34:34,051 --> 00:34:37,081
to your website's domain name for example.

675
00:34:37,081 --> 00:34:40,279
Or you might apply some
external load balancing

676
00:34:40,279 --> 00:34:43,192
on top of this, and you
might use more than one

677
00:34:43,192 --> 00:34:46,833
of these addresses on that
external load balancer.

678
00:34:46,833 --> 00:34:49,247
Lots of different ways you
can use this in practise

679
00:34:49,247 --> 00:34:51,602
but it's a very clever set up.

680
00:34:51,602 --> 00:34:55,019
It's called the routing, or routing mesh.

681
00:34:56,067 --> 00:34:57,499
As always, there's a full page of this

682
00:34:57,499 --> 00:34:59,236
on the reference manual,

683
00:34:59,236 --> 00:35:01,615
do check out that if you're interested.

684
00:35:01,615 --> 00:35:04,888
One important point that we
will need for future chapters

685
00:35:04,888 --> 00:35:06,799
is that to make all of
this work you do need

686
00:35:06,799 --> 00:35:10,132
a couple of ports open on your firewall.

687
00:35:11,776 --> 00:35:14,233
I won't look into detail on that just yet,

688
00:35:14,233 --> 00:35:16,169
we'll do that when we go to EC2.

689
00:35:16,169 --> 00:35:18,259
But it would be worth remembering

690
00:35:18,259 --> 00:35:20,782
that that work's going to be needed later.

691
00:35:20,782 --> 00:35:22,879
Clearly on the Play with Docker,

692
00:35:22,879 --> 00:35:26,220
they've already configured
these ports appropriately.

693
00:35:26,220 --> 00:35:27,853
I don't know about you,
I'm starting to feel

694
00:35:27,853 --> 00:35:32,020
a little lost already, that
I know that I have a stack

695
00:35:33,723 --> 00:35:36,998
called fleetman stack
and it has two services.

696
00:35:36,998 --> 00:35:39,868
So I can do a docker service LS

697
00:35:39,868 --> 00:35:42,716
and find out details
of those two services.

698
00:35:42,716 --> 00:35:44,682
You've seen that we can
drill into one of these

699
00:35:44,682 --> 00:35:46,996
using the docker service PS commands

700
00:35:46,996 --> 00:35:49,880
and that will tell us which
node they're running on.

701
00:35:49,880 --> 00:35:52,202
But it would be nice if
somehow we could visualise

702
00:35:52,202 --> 00:35:55,631
what's going on here and see
what this swarm looks like

703
00:35:55,631 --> 00:35:57,175
and what's running on it.

704
00:35:57,175 --> 00:35:59,816
There is a wonderful
project from Docker Samples

705
00:35:59,816 --> 00:36:02,399
called Docker Swarm Visualizer.

706
00:36:03,535 --> 00:36:06,701
This is an open source project
and they push their builds

707
00:36:06,701 --> 00:36:10,694
to Docker Hub under the
username dockersamples.

708
00:36:10,694 --> 00:36:15,158
So this is just a container and
we can access that container

709
00:36:15,158 --> 00:36:16,760
and run that container.

710
00:36:16,760 --> 00:36:18,165
If we go a little further down here

711
00:36:18,165 --> 00:36:20,858
they tell us how to run this container.

712
00:36:20,858 --> 00:36:23,445
It's just a regular docker run.

713
00:36:23,445 --> 00:36:25,414
We can run it on any port we like,

714
00:36:25,414 --> 00:36:27,627
that's entirely of our choosing.

715
00:36:27,627 --> 00:36:30,638
We are going to have to do a docker mount.

716
00:36:30,638 --> 00:36:35,102
And then the image is
dockersamples/visualizer.

717
00:36:35,102 --> 00:36:37,681
So we can just pretty
much copy that command.

718
00:36:37,681 --> 00:36:39,296
I'm not going to run this as a service,

719
00:36:39,296 --> 00:36:41,920
I'm not going to include it
in my docker compose file

720
00:36:41,920 --> 00:36:44,611
because this is really not a service

721
00:36:44,611 --> 00:36:48,010
that's part of my application,
this is more of a,

722
00:36:48,010 --> 00:36:51,219
this is more of a utility
container that I'm running.

723
00:36:51,219 --> 00:36:53,869
I don't think it makes sense
to add it to Docker Compose

724
00:36:53,869 --> 00:36:55,691
because I certainly
wouldn't want it to run

725
00:36:55,691 --> 00:36:57,396
when we're developing locally.

726
00:36:57,396 --> 00:36:59,259
I'll dictate the command
just in case you don't have

727
00:36:59,259 --> 00:37:02,351
easy access to copying and
pasting from their website.

728
00:37:02,351 --> 00:37:05,018
Docker run -D to run detached -P

729
00:37:07,420 --> 00:37:08,924
and we need to publish a port.

730
00:37:08,924 --> 00:37:11,959
I'm going to demonstrate that
we can use any port we like.

731
00:37:11,959 --> 00:37:14,149
I'm gonna go for 5000,

732
00:37:14,149 --> 00:37:16,816
but their internal port is 8080.

733
00:37:18,867 --> 00:37:21,044
The only difficult thing
here is that mounting.

734
00:37:21,044 --> 00:37:23,246
We have to do a -V and it's

735
00:37:23,246 --> 00:37:27,413
/var/run/docker.sock

736
00:37:29,306 --> 00:37:33,367
followed by a colon and then
exactly the same thing again.

737
00:37:33,367 --> 00:37:36,867
Var/run/docker.sock.

738
00:37:38,012 --> 00:37:41,779
And that will be because
Docker Swarm uses this socket

739
00:37:41,779 --> 00:37:44,490
on the Linux machine
that we're running on.

740
00:37:44,490 --> 00:37:48,203
And the container needs
visibility of that socket.

741
00:37:48,203 --> 00:37:50,883
Or we don't really need to
care, we can just copy it in

742
00:37:50,883 --> 00:37:54,133
and then it's dockersamples/

743
00:37:55,064 --> 00:37:59,923
and visualizer with a zed
or a Z rather than an S,

744
00:37:59,923 --> 00:38:02,632
which we might have used here in the UK.

745
00:38:02,632 --> 00:38:04,965
So just a regular
container, give that a run,

746
00:38:04,965 --> 00:38:06,214
it will do a pull.

747
00:38:06,214 --> 00:38:08,588
Assuming you've never used it before.

748
00:38:08,588 --> 00:38:10,410
Okay, that will take awhile to start up.

749
00:38:10,410 --> 00:38:13,704
And notice now that we've
published port 5000,

750
00:38:13,704 --> 00:38:16,061
that's now appearing as a link here.

751
00:38:16,061 --> 00:38:19,653
But really importantly
also notice if we go to

752
00:38:19,653 --> 00:38:24,640
the other nodes, can you see,
there's no port 5000 there.

753
00:38:24,640 --> 00:38:28,927
And that's because this is
just a regular container,

754
00:38:28,927 --> 00:38:32,929
it's not a service, it's
not part of the swarm,

755
00:38:32,929 --> 00:38:35,084
so we don't get that mesh routing

756
00:38:35,084 --> 00:38:37,276
that I talked about before.

757
00:38:37,276 --> 00:38:39,687
So this is only running
on a single instance

758
00:38:39,687 --> 00:38:42,911
and we must visit this specific link.

759
00:38:42,911 --> 00:38:45,992
We won't find it on
any of the other nodes.

760
00:38:45,992 --> 00:38:48,262
This is an absolutely
lovely piece of software.

761
00:38:48,262 --> 00:38:49,657
It's simple in what it does,

762
00:38:49,657 --> 00:38:52,160
we can't manipulate any of this,

763
00:38:52,160 --> 00:38:55,646
we can't drag the containers
around or anything like that,

764
00:38:55,646 --> 00:38:59,280
but it does show us details
of each of the instances,

765
00:38:59,280 --> 00:39:03,048
how much RAM they have,
whether they're a manager

766
00:39:03,048 --> 00:39:05,705
or a worker, and most importantly of all,

767
00:39:05,705 --> 00:39:09,153
we can see the running
containers on each of them.

768
00:39:09,153 --> 00:39:13,017
They use a colour coding
system, they're random colours,

769
00:39:13,017 --> 00:39:16,204
but they use the same colour for replicas.

770
00:39:16,204 --> 00:39:18,392
So this is my web app,

771
00:39:18,392 --> 00:39:21,652
which is running on
manager2, and manager3,

772
00:39:21,652 --> 00:39:25,641
and on one of the workers
we've got the database.

773
00:39:25,641 --> 00:39:27,620
We can do a fun demo now.

774
00:39:27,620 --> 00:39:30,718
What would happen if one
of these instances crashed?

775
00:39:30,718 --> 00:39:34,551
Let's say our worker1
for some reason crashes.

776
00:39:36,322 --> 00:39:39,539
We can simulate that by selecting worker1

777
00:39:39,539 --> 00:39:41,971
and I'm gonna press Delete.

778
00:39:41,971 --> 00:39:43,346
I'll press Delete and then switch

779
00:39:43,346 --> 00:39:46,260
very quickly to the visualizer.

780
00:39:46,260 --> 00:39:47,937
And I don't need to do any refreshing,

781
00:39:47,937 --> 00:39:50,437
it's all updated in real time.

782
00:39:51,868 --> 00:39:55,000
And yeah, okay, it took a
while actually but now we have

783
00:39:55,000 --> 00:39:59,167
a big red mark against worker1,
meaning it's out of service.

784
00:40:00,478 --> 00:40:03,051
There we are, we can
see that automatically

785
00:40:03,051 --> 00:40:06,290
that database container has been restarted

786
00:40:06,290 --> 00:40:09,941
and it's running now on
another random instance,

787
00:40:09,941 --> 00:40:14,481
in this case for me it's
appeared on this second worker,

788
00:40:14,481 --> 00:40:16,741
absolutely fantastic.

789
00:40:16,741 --> 00:40:19,154
Now whether my system
would have been resilient

790
00:40:19,154 --> 00:40:22,821
to that failure is down
to my system design.

791
00:40:23,847 --> 00:40:27,974
If these web app instances
were relying on that database

792
00:40:27,974 --> 00:40:30,917
and they would have crashed
if the database had gone down

793
00:40:30,917 --> 00:40:33,590
for a couple of minutes, then
we might have had a problem.

794
00:40:33,590 --> 00:40:35,068
And actually I think I can prove that

795
00:40:35,068 --> 00:40:37,557
if I visit one of the port 80s.

796
00:40:37,557 --> 00:40:41,025
Yeah, I am getting actually
an SQL grammar exception,

797
00:40:41,025 --> 00:40:43,570
and that's simply because I
haven't designed my application

798
00:40:43,570 --> 00:40:45,829
to be resilient to the database going away

799
00:40:45,829 --> 00:40:47,312
and coming back again.

800
00:40:47,312 --> 00:40:49,250
Now that's not a deployment problem,

801
00:40:49,250 --> 00:40:51,425
that's not something we
can solve with Docker,

802
00:40:51,425 --> 00:40:53,420
that's something I'd
have to do in the code.

803
00:40:53,420 --> 00:40:54,933
It's beyond the scope of this course,

804
00:40:54,933 --> 00:40:56,602
but I wanted you to be aware of that,

805
00:40:56,602 --> 00:40:59,892
things aren't just going
to be magically resilient.

806
00:40:59,892 --> 00:41:02,771
But it's still a fantastic
feature that despite

807
00:41:02,771 --> 00:41:05,982
that disaster, the database
came back up and running.

808
00:41:05,982 --> 00:41:07,819
In the full microservice architecture

809
00:41:07,819 --> 00:41:11,271
we're using things such
as Java message queues,

810
00:41:11,271 --> 00:41:14,405
and we are going to see
that if we bring those down

811
00:41:14,405 --> 00:41:17,525
then the system will be
resilient to their failure.

812
00:41:17,525 --> 00:41:20,398
So too if any of the microservices crashes

813
00:41:20,398 --> 00:41:22,646
then the system will keep running.

814
00:41:22,646 --> 00:41:25,417
So the point of that is
although Docker Swarm

815
00:41:25,417 --> 00:41:28,583
is amazing in its resilience features,

816
00:41:28,583 --> 00:41:31,131
you still have to design your applications

817
00:41:31,131 --> 00:41:33,148
to be resilient to failure.

818
00:41:33,148 --> 00:41:34,538
And it's one of the most important things

819
00:41:34,538 --> 00:41:37,087
about building a
microservice architecture.

820
00:41:37,087 --> 00:41:40,620
So we will be looking at
that in the next chapter.

821
00:41:40,620 --> 00:41:43,814
Now to look at how to
make changes to an image,

822
00:41:43,814 --> 00:41:48,584
and how to deploy that to
an already running swarm.

823
00:41:48,584 --> 00:41:50,489
We can simulate that quite easily.

824
00:41:50,489 --> 00:41:54,613
If you have your workspace
from previous chapters

825
00:41:54,613 --> 00:41:56,886
we could just make a very simple change.

826
00:41:56,886 --> 00:41:59,933
Find the source main resources, templates,

827
00:41:59,933 --> 00:42:02,669
LiveTracking.html file,

828
00:42:02,669 --> 00:42:05,384
and I suggest making a stupid change.

829
00:42:05,384 --> 00:42:07,967
Line 88, there's a heading one.

830
00:42:08,971 --> 00:42:09,804
So

831
00:42:11,092 --> 00:42:13,967
I don't know, I'll put updated in there.

832
00:42:13,967 --> 00:42:15,594
Now I can run my build.

833
00:42:15,594 --> 00:42:17,292
I'm going to clean and deploy this.

834
00:42:17,292 --> 00:42:19,735
Now if you're following
along with me at this stage

835
00:42:19,735 --> 00:42:23,020
then you will need to be able
to push this to Docker Hub,

836
00:42:23,020 --> 00:42:25,401
so you will have to be working
with your own Docker Hub

837
00:42:25,401 --> 00:42:28,475
account at this stage if
you want to follow along.

838
00:42:28,475 --> 00:42:31,065
That's going to take a few
minutes to push to Docker Hub

839
00:42:31,065 --> 00:42:33,643
so I'll let that run in the background.

840
00:42:33,643 --> 00:42:35,145
And while that's pushing
it gives me a chance

841
00:42:35,145 --> 00:42:37,232
to show you another couple of features

842
00:42:37,232 --> 00:42:40,919
on the deploy options in
the docker compose file.

843
00:42:40,919 --> 00:42:43,669
Let's get the docker compose file

844
00:42:44,789 --> 00:42:46,064
open in the editor.

845
00:42:46,064 --> 00:42:48,233
Now what we can do with docker stacks

846
00:42:48,233 --> 00:42:52,909
is we can implement a
so-called rolling update.

847
00:42:52,909 --> 00:42:54,447
I mentioned it very briefly before,

848
00:42:54,447 --> 00:42:59,128
it is in the reference
manual under Update Config.

849
00:42:59,128 --> 00:43:01,071
At the time of recording
there are five options,

850
00:43:01,071 --> 00:43:03,750
there may be more by
the time you watch this,

851
00:43:03,750 --> 00:43:07,280
but the main option would be the delay,

852
00:43:07,280 --> 00:43:09,743
which is the time to wait between

853
00:43:09,743 --> 00:43:12,271
updating a group of containers.

854
00:43:12,271 --> 00:43:15,044
Now what they mean by group of containers

855
00:43:15,044 --> 00:43:18,472
is there's this field
here called parallelism,

856
00:43:18,472 --> 00:43:22,337
which is the number of
containers to update at a time.

857
00:43:22,337 --> 00:43:25,515
It doesn't say what the
defaults for parallelism is,

858
00:43:25,515 --> 00:43:27,575
I'm guessing it's one.

859
00:43:27,575 --> 00:43:30,427
But just to be safe, I'm
going to set things up

860
00:43:30,427 --> 00:43:34,002
so that we only update
one container at a time

861
00:43:34,002 --> 00:43:38,169
but there is a two minute delay
between doing those updates.

862
00:43:39,623 --> 00:43:43,077
And that should mean at
any one time we always have

863
00:43:43,077 --> 00:43:46,910
at least one web app
container still standing.

864
00:43:48,324 --> 00:43:52,881
So we need update_config
and that needs to be

865
00:43:52,881 --> 00:43:55,381
at the same level as replicas.

866
00:43:56,598 --> 00:43:59,721
But then on the next
line we'll be indenting,

867
00:43:59,721 --> 00:44:02,847
again use spaces on tabs in YAML.

868
00:44:02,847 --> 00:44:04,514
And for parallelism,

869
00:44:06,614 --> 00:44:08,778
I'm sure they could have
found a better label

870
00:44:08,778 --> 00:44:12,195
than parallelism, we're going to use one,

871
00:44:13,105 --> 00:44:15,637
and for the delay, another thing I love

872
00:44:15,637 --> 00:44:18,425
about these docker syntaxes
is you don't have to guess

873
00:44:18,425 --> 00:44:22,669
what the units are for
these, you have to specify

874
00:44:22,669 --> 00:44:25,483
whether it's seconds or hours or whatever.

875
00:44:25,483 --> 00:44:28,983
So for me I'm going to go for 120 seconds.

876
00:44:30,938 --> 00:44:35,770
So that's all we need, do
a Control + O to write out

877
00:44:35,770 --> 00:44:37,537
and a Contol + X to exit.

878
00:44:37,537 --> 00:44:39,394
Now while I've been talking that build

879
00:44:39,394 --> 00:44:42,835
should have completed, and
I'll check this on Docker Hub.

880
00:44:42,835 --> 00:44:45,443
The image is called fleetman production.

881
00:44:45,443 --> 00:44:49,071
Yeah, it's this latest tag
here which was two minutes ago.

882
00:44:49,071 --> 00:44:50,567
I'll talk about what the no-netflix

883
00:44:50,567 --> 00:44:53,334
and the microservice
are in later chapters,

884
00:44:53,334 --> 00:44:55,897
that's good fun still to come.

885
00:44:55,897 --> 00:44:57,736
So we now have a new version of this image

886
00:44:57,736 --> 00:44:59,472
published on Docker Hub.

887
00:44:59,472 --> 00:45:01,869
How do we roll out those changes?

888
00:45:01,869 --> 00:45:03,810
Well it's the same as we did before.

889
00:45:03,810 --> 00:45:06,781
To update a running swarm we simply rerun

890
00:45:06,781 --> 00:45:09,167
the docker stack deploy command

891
00:45:09,167 --> 00:45:12,449
and it will work out if any
changes need to be made.

892
00:45:12,449 --> 00:45:13,862
It's even clever enough to know

893
00:45:13,862 --> 00:45:17,454
that one of the images has been updated.

894
00:45:17,454 --> 00:45:18,545
And we can demo this.

895
00:45:18,545 --> 00:45:22,613
One of the main reasons I
wanted the visualizer is,

896
00:45:22,613 --> 00:45:27,118
I'm going to have to zoom in
here, but it is showing you

897
00:45:27,118 --> 00:45:28,451
the shar256 hash

898
00:45:30,086 --> 00:45:32,715
of the image in use here.

899
00:45:32,715 --> 00:45:36,879
And the key thing is the
image in use, the old image,

900
00:45:36,879 --> 00:45:38,712
begins nine four zero,

901
00:45:40,940 --> 00:45:45,336
and that's identical on both
replicas of that service.

902
00:45:45,336 --> 00:45:48,694
Now if I run this docker stack deploy,

903
00:45:48,694 --> 00:45:51,354
it tells me it's updating the services.

904
00:45:51,354 --> 00:45:56,267
Now can you see there,
one of them was taken down

905
00:45:56,267 --> 00:45:58,317
and has come back up and running.

906
00:45:58,317 --> 00:46:01,400
And it's a new one now beginning 5F2.

907
00:46:02,454 --> 00:46:06,621
However the previous old one
940 has been left behind.

908
00:46:07,916 --> 00:46:10,296
Now if we go to port 80

909
00:46:10,296 --> 00:46:12,413
there's a problem with this.

910
00:46:12,413 --> 00:46:15,200
The container's running so
Docker is directing traffic

911
00:46:15,200 --> 00:46:17,058
to that new container.

912
00:46:17,058 --> 00:46:19,704
Our Spring Boot app is still starting

913
00:46:19,704 --> 00:46:22,966
so we may have a short period of errors.

914
00:46:22,966 --> 00:46:24,326
I'll come back to that in a moment,

915
00:46:24,326 --> 00:46:26,796
but I want to do some refreshers.

916
00:46:26,796 --> 00:46:28,648
So I've done a refresh there and this time

917
00:46:28,648 --> 00:46:31,493
it's routed me to the old one.

918
00:46:31,493 --> 00:46:34,371
Do a refresh on the old
one and we're getting

919
00:46:34,371 --> 00:46:38,538
load balancing now between the
two instances of container.

920
00:46:39,374 --> 00:46:40,926
Now this might not work for you,

921
00:46:40,926 --> 00:46:42,528
it's all a little bit random,

922
00:46:42,528 --> 00:46:45,185
but can you see there I'm
now starting to be balanced

923
00:46:45,185 --> 00:46:48,754
between the old and the new version.

924
00:46:48,754 --> 00:46:50,565
Now I say that, I do find sometimes

925
00:46:50,565 --> 00:46:53,712
it will stick to a
container if it's getting

926
00:46:53,712 --> 00:46:55,536
a good response from that container,

927
00:46:55,536 --> 00:46:59,332
so it can be difficult to
see consistent results,

928
00:46:59,332 --> 00:47:02,753
but certainly something has changed now,

929
00:47:02,753 --> 00:47:06,336
I'm constantly getting
the updated version.

930
00:47:07,357 --> 00:47:10,085
And yeah looking at the visualizer,

931
00:47:10,085 --> 00:47:11,545
the other one has gone down now,

932
00:47:11,545 --> 00:47:13,857
so it's been about two minutes.

933
00:47:13,857 --> 00:47:15,650
I can keep refreshing.

934
00:47:15,650 --> 00:47:19,065
Ah, now we have an error, that
will be because yes we have,

935
00:47:19,065 --> 00:47:21,502
we've now got the second
instance of the new image,

936
00:47:21,502 --> 00:47:22,927
which is in a state of running

937
00:47:22,927 --> 00:47:27,094
but unfortunately Spring Boot
will still be starting up.

938
00:47:28,613 --> 00:47:31,860
So we have a short period of instability

939
00:47:31,860 --> 00:47:33,693
but now it looks like,

940
00:47:35,210 --> 00:47:39,377
yep, now it looks like we're
getting consistent results.

941
00:47:41,567 --> 00:47:43,118
So although this is a fantastic way

942
00:47:43,118 --> 00:47:46,145
of rolling out deployments,
the one rough edge on this

943
00:47:46,145 --> 00:47:48,689
is that Docker doesn't distinguish

944
00:47:48,689 --> 00:47:53,627
between a running container
and a healthy container.

945
00:47:53,627 --> 00:47:55,345
And our containers are only healthy

946
00:47:55,345 --> 00:47:57,863
once Spring Boot has started.

947
00:47:57,863 --> 00:48:00,357
So for that reason you
might still need to use

948
00:48:00,357 --> 00:48:04,854
traditional load balancers
such as Amazon's ELB,

949
00:48:04,854 --> 00:48:07,037
which have their own
built in health checks

950
00:48:07,037 --> 00:48:10,016
which will check if a
particular port is responding

951
00:48:10,016 --> 00:48:13,556
before they forward traffic
to a particular IP address.

952
00:48:13,556 --> 00:48:16,151
Now that is beyond the
scope of this course.

953
00:48:16,151 --> 00:48:19,573
I wanted to show you how to do
rolling updates using Docker.

954
00:48:19,573 --> 00:48:21,700
It's pretty simple, but
there is that one little

955
00:48:21,700 --> 00:48:23,805
rough edge there that
Docker doesn't distinguish

956
00:48:23,805 --> 00:48:25,634
between a running container

957
00:48:25,634 --> 00:48:30,032
and one that is properly
ready to service requests.

958
00:48:30,032 --> 00:48:32,446
It was still a fun demo
though, and you can see now

959
00:48:32,446 --> 00:48:36,363
that both of these image
are the new 5F2 image.

960
00:48:37,811 --> 00:48:39,111
So that's it for this chapter.

961
00:48:39,111 --> 00:48:42,398
I just need to remember
to undo that change

962
00:48:42,398 --> 00:48:44,670
so that the viewers in earlier chapters

963
00:48:44,670 --> 00:48:46,691
aren't affected by that change.

964
00:48:46,691 --> 00:48:48,372
So what we've been doing up until now

965
00:48:48,372 --> 00:48:49,611
is we've been running this very

966
00:48:49,611 --> 00:48:51,944
cut down version of the system,

967
00:48:51,944 --> 00:48:55,751
which has this weird, random
and chaotic position data.

968
00:48:55,751 --> 00:48:57,656
What I want to do now to close the course

969
00:48:57,656 --> 00:48:59,430
is move forward with this.

970
00:48:59,430 --> 00:49:02,311
I'm going to bring in a full
microservice architecture

971
00:49:02,311 --> 00:49:04,678
that we've developed on previous courses

972
00:49:04,678 --> 00:49:08,971
and we're going to run it
on real Amazon EC2 hardware.

973
00:49:08,971 --> 00:49:11,137
So we've some great stuff still to come.

974
00:49:11,137 --> 00:49:15,304
Hope you're still with me, I'll
see you in the next chapter.

1
00:00:00,962 --> 00:00:01,795
- [Instructor] Well, I hope you've

2
00:00:01,795 --> 00:00:02,790
enjoyed the course so far.

3
00:00:02,790 --> 00:00:04,465
It has been great fun exploring

4
00:00:04,465 --> 00:00:06,519
Docker Swarm and Docker Stacks,

5
00:00:06,519 --> 00:00:10,235
and it's also fun playing
with Play With Docker.

6
00:00:10,235 --> 00:00:11,397
For the rest of the course,

7
00:00:11,397 --> 00:00:13,762
I'm going to switch focus,
and I'm going to apply

8
00:00:13,762 --> 00:00:16,517
really everything that
we've learned to a bigger

9
00:00:16,517 --> 00:00:19,586
architecture and a more
realistic architecture.

10
00:00:19,586 --> 00:00:23,137
And we're also going to
deploy to some real hardware.

11
00:00:23,137 --> 00:00:26,359
In this case, it's going
to be EC2 instances.

12
00:00:26,359 --> 00:00:27,867
I'm going to assume for
this chapter that you've

13
00:00:27,867 --> 00:00:32,403
already studied our Spring
Boot microservices course

14
00:00:32,403 --> 00:00:36,570
and/or the deploying microservices course.

15
00:00:37,581 --> 00:00:38,914
If you haven't, don't worry.

16
00:00:38,914 --> 00:00:41,694
Some of the concepts might
be confusing in this video,

17
00:00:41,694 --> 00:00:44,692
but you will still get
value from watching.

18
00:00:44,692 --> 00:00:46,244
But of course, I would recommend

19
00:00:46,244 --> 00:00:51,019
that you go and do one of
those courses after this one.

20
00:00:51,019 --> 00:00:52,207
I'm going to start this video

21
00:00:52,207 --> 00:00:55,466
by reviewing what we did
on those previous courses,

22
00:00:55,466 --> 00:00:57,439
just to get back up to speed with it.

23
00:00:57,439 --> 00:01:00,464
Then I'm going to show you
how with would use Docker

24
00:01:00,464 --> 00:01:03,333
to deploy it to some real hardware.

25
00:01:03,333 --> 00:01:06,198
On the original Spring
Boot microservices course,

26
00:01:06,198 --> 00:01:07,981
it is a simple system,

27
00:01:07,981 --> 00:01:10,952
probably the simplest
possible microservice system

28
00:01:10,952 --> 00:01:12,692
that I could get away with,

29
00:01:12,692 --> 00:01:14,707
and it comprises of a service

30
00:01:14,707 --> 00:01:16,642
which I've called here the Web Front End.

31
00:01:16,642 --> 00:01:17,881
In fact, it's the webapp

32
00:01:17,881 --> 00:01:21,646
that you've been dealing
with throughout this course.

33
00:01:21,646 --> 00:01:25,254
But that webapp has
two modes of operation.

34
00:01:25,254 --> 00:01:27,692
It can run standalone, in which case,

35
00:01:27,692 --> 00:01:30,122
it generates its own random data,

36
00:01:30,122 --> 00:01:32,732
and that's what you've been
seeing through those course.

37
00:01:32,732 --> 00:01:35,679
But when run in proper mode, if you like,

38
00:01:35,679 --> 00:01:38,242
when run in production, instead,

39
00:01:38,242 --> 00:01:43,076
it gets all of its data from
an external microservice.

40
00:01:43,076 --> 00:01:45,166
It does that using a REST call,

41
00:01:45,166 --> 00:01:47,873
and the external microservice is again

42
00:01:47,873 --> 00:01:49,872
just another Spring Boot application

43
00:01:49,872 --> 00:01:52,066
which I call the position tracker.

44
00:01:52,066 --> 00:01:54,488
Now, the position tracker is
doing various calculations

45
00:01:54,488 --> 00:01:58,430
and so on, but it's not
generating its own data.

46
00:01:58,430 --> 00:02:01,672
It's being sent the data from a queue.

47
00:02:01,672 --> 00:02:04,643
I'm going to think of this
as a separate microservice

48
00:02:04,643 --> 00:02:08,810
which is running a standard
installation of Apache ActiveMQ.

49
00:02:10,536 --> 00:02:12,171
Now, the idea of this system

50
00:02:12,171 --> 00:02:14,851
is that as vehicles
travel around the country,

51
00:02:14,851 --> 00:02:17,878
there'll be a piece of
software on the vehicles

52
00:02:17,878 --> 00:02:21,709
that's transmitting data to that queue.

53
00:02:21,709 --> 00:02:24,387
Of course, we don't have
any real trucks and lorries

54
00:02:24,387 --> 00:02:27,679
to broadcast, so on that previous course,

55
00:02:27,679 --> 00:02:32,140
we built a final microservice
called the position simulator.

56
00:02:32,140 --> 00:02:36,014
Perhaps arguably this
is not a microservice.

57
00:02:36,014 --> 00:02:38,005
It depends on your thinking, really.

58
00:02:38,005 --> 00:02:40,257
It's more a simulation system,

59
00:02:40,257 --> 00:02:43,068
and all this microservice does,

60
00:02:43,068 --> 00:02:47,571
it sends generated position
data to this queue.

61
00:02:47,571 --> 00:02:49,384
And we talked a lot in the previous course

62
00:02:49,384 --> 00:02:52,005
about how as long as you do things right,

63
00:02:52,005 --> 00:02:54,570
this can be a more resilient system.

64
00:02:54,570 --> 00:02:57,941
If the position tracker were
to crash for any reason,

65
00:02:57,941 --> 00:02:59,788
then the web front end will carry on,

66
00:02:59,788 --> 00:03:02,701
albeit maybe with old data.

67
00:03:02,701 --> 00:03:04,989
If the queue crashes, we've made sure

68
00:03:04,989 --> 00:03:09,336
that the position tracker will
simply stop receiving data,

69
00:03:09,336 --> 00:03:11,385
but when the queue comes back,

70
00:03:11,385 --> 00:03:14,790
everything will continue
working again, and so on.

71
00:03:14,790 --> 00:03:16,960
That's all discussed
in the previous course.

72
00:03:16,960 --> 00:03:18,163
But I hope you got a feel

73
00:03:18,163 --> 00:03:20,963
for the basic components of this system

74
00:03:20,963 --> 00:03:22,866
and clearly where we're heading with this.

75
00:03:22,866 --> 00:03:25,466
It would be nice if we
could make each of these

76
00:03:25,466 --> 00:03:28,955
a container that we deploy to swam.

77
00:03:28,955 --> 00:03:31,020
Well, is it a bit more
complicated than that,

78
00:03:31,020 --> 00:03:34,254
because as discussed on
the previous courses,

79
00:03:34,254 --> 00:03:35,774
we need more than that.

80
00:03:35,774 --> 00:03:40,032
It's very difficult just to
build standalone microservices

81
00:03:40,032 --> 00:03:42,249
using something like Spring Boot

82
00:03:42,249 --> 00:03:44,524
and hope it will all fit together.

83
00:03:44,524 --> 00:03:46,862
We need extra support.

84
00:03:46,862 --> 00:03:48,786
We need frameworks.

85
00:03:48,786 --> 00:03:50,346
Otherwise, we're going to end up doing

86
00:03:50,346 --> 00:03:54,612
a lot of really boring,
tedious routine work.

87
00:03:54,612 --> 00:03:56,965
So for that reason, on
the previous courses,

88
00:03:56,965 --> 00:04:00,695
we introduced a so-called
service registry.

89
00:04:00,695 --> 00:04:02,746
Now, a service registry

90
00:04:02,746 --> 00:04:05,623
is away of all of the microservices.

91
00:04:05,623 --> 00:04:07,892
In our system, it's actually
just the web front end

92
00:04:07,892 --> 00:04:10,726
and the position tracker
that are relevant here.

93
00:04:10,726 --> 00:04:14,570
They automatically register
themselves with the service

94
00:04:14,570 --> 00:04:19,298
registry, and that gives us
some really powerful features.

95
00:04:19,298 --> 00:04:24,258
It means that each service
can find the other services,

96
00:04:24,258 --> 00:04:26,705
even if the web front end
and the position tracker

97
00:04:26,705 --> 00:04:30,864
are deployed to physically
separate pieces of hardware.

98
00:04:30,864 --> 00:04:32,985
They'll be on different IP addresses,

99
00:04:32,985 --> 00:04:35,729
probably on different ports as well.

100
00:04:35,729 --> 00:04:38,203
By using this registry,

101
00:04:38,203 --> 00:04:41,259
if the web front end wants
to call the position tracker,

102
00:04:41,259 --> 00:04:44,713
then the web front end can
simply ask the registry,

103
00:04:44,713 --> 00:04:48,093
where is the position tracker,
and the registry responds

104
00:04:48,093 --> 00:04:51,757
with the correct IP address
and the correct port.

105
00:04:51,757 --> 00:04:54,725
Now, on that previous course,
we needed a service registry,

106
00:04:54,725 --> 00:04:57,142
so we used one called Eureka.

107
00:04:58,407 --> 00:05:00,593
Eureka is really well thought of,

108
00:05:00,593 --> 00:05:03,450
because it was created by Netflix,

109
00:05:03,450 --> 00:05:05,758
who are credited really as being

110
00:05:05,758 --> 00:05:09,896
one of the leading forces in
the microservice movement.

111
00:05:09,896 --> 00:05:12,872
So Eureka is a very battle-tested,

112
00:05:12,872 --> 00:05:15,872
well-proven service registry system.

113
00:05:17,274 --> 00:05:21,253
Now, you might want to
start thinking about whether

114
00:05:21,253 --> 00:05:26,059
we still need a service registry
when we're using Docker.

115
00:05:26,059 --> 00:05:28,895
I'll come back to that much later on,

116
00:05:28,895 --> 00:05:33,171
but for now, it works, and
we can continue to use it.

117
00:05:33,171 --> 00:05:35,458
So the upshot of that
is we're going to need

118
00:05:35,458 --> 00:05:38,962
a container for this registry as well,

119
00:05:38,962 --> 00:05:39,795
and it's more than that.

120
00:05:39,795 --> 00:05:42,681
There are a lot of problems
with deploying microservices,

121
00:05:42,681 --> 00:05:44,099
and one of the biggest problems

122
00:05:44,099 --> 00:05:46,813
is how do you share common data?

123
00:05:46,813 --> 00:05:49,030
There's always common data in systems,

124
00:05:49,030 --> 00:05:52,011
and the real risk of building
a microservice architecture

125
00:05:52,011 --> 00:05:54,687
is if every single one of these systems

126
00:05:54,687 --> 00:05:58,304
starts hardcoding values, then clearly,

127
00:05:58,304 --> 00:06:00,466
if you need to change one of those values,

128
00:06:00,466 --> 00:06:02,170
then it would be a nightmare.

129
00:06:02,170 --> 00:06:04,360
Not only would you have to code

130
00:06:04,360 --> 00:06:07,941
potentially lots and lots
of different microservices;

131
00:06:07,941 --> 00:06:10,601
you'd also have to redeploy them all,

132
00:06:10,601 --> 00:06:13,056
which would be absolutely horrible.

133
00:06:13,056 --> 00:06:16,436
So it's very common on a
microservice architecture

134
00:06:16,436 --> 00:06:19,180
to have something called a config server.

135
00:06:19,180 --> 00:06:22,280
I've called it my global config server,

136
00:06:22,280 --> 00:06:25,799
and that's a kind of
repository for key value pairs

137
00:06:25,799 --> 00:06:29,253
that any of the microservices might need.

138
00:06:29,253 --> 00:06:31,658
I've used Spring Cloud for that

139
00:06:31,658 --> 00:06:35,825
because it integrates seamlessly
with a Spring Boot programme.

140
00:06:37,539 --> 00:06:39,386
If you have been on the previous courses,

141
00:06:39,386 --> 00:06:42,287
then I have to warn you
that I have made some tweaks

142
00:06:42,287 --> 00:06:45,845
to these projects to make
them work under Docker.

143
00:06:45,845 --> 00:06:49,846
Now those changes are largely
small changes to config files,

144
00:06:49,846 --> 00:06:52,346
but it has taken quite
a long time to do that.

145
00:06:52,346 --> 00:06:53,901
Now, I'm not going to sit here

146
00:06:53,901 --> 00:06:57,429
ploughing through what
all of those changes are.

147
00:06:57,429 --> 00:07:00,588
You can review all of
those changes for yourself.

148
00:07:00,588 --> 00:07:03,451
In the Practicals and Code
folder for this course,

149
00:07:03,451 --> 00:07:08,002
I've given you a folder
called Microservice Projects,

150
00:07:08,002 --> 00:07:12,502
and inside there, there is
a collection of projects,

151
00:07:12,502 --> 00:07:14,812
one for each of the containers

152
00:07:14,812 --> 00:07:16,657
that we're going to be deploying.

153
00:07:16,657 --> 00:07:20,928
And we also have a
docker-compose.yaml file.

154
00:07:20,928 --> 00:07:22,751
And of course you can
open up those projects

155
00:07:22,751 --> 00:07:26,019
for yourself in Eclipse
if you're interested.

156
00:07:26,019 --> 00:07:28,876
You probably won't need to do
any coding in this chapter,

157
00:07:28,876 --> 00:07:33,500
so you don't have to open
them in Eclipse by any means.

158
00:07:33,500 --> 00:07:37,570
And if you prefer, you can
go to my GitHub repository.

159
00:07:37,570 --> 00:07:40,056
My GitHub is called DickChesterwood.

160
00:07:40,056 --> 00:07:44,223
Any of the repositories
that begin docker-netflix,

161
00:07:45,378 --> 00:07:48,403
they're the projects that we're
looking at in this chapter.

162
00:07:48,403 --> 00:07:53,111
There are some repositories
prefixed docker-only,

163
00:07:53,111 --> 00:07:55,140
and I'm giving the game away here.

164
00:07:55,140 --> 00:07:57,099
In the next chapter,
we're going to look at how

165
00:07:57,099 --> 00:08:01,243
you can remove Netflix
Eureka from a Docker system,

166
00:08:01,243 --> 00:08:02,969
and that's what those projects are for.

167
00:08:02,969 --> 00:08:05,151
So, ignore those for now.

168
00:08:05,151 --> 00:08:09,093
It's the docker-netflix projects
that we're interested in.

169
00:08:09,093 --> 00:08:10,697
Now, I'll pick one of them at random.

170
00:08:10,697 --> 00:08:12,963
I think I'll go for the webapp, in fact.

171
00:08:12,963 --> 00:08:15,459
I just want to very
quickly review the changes

172
00:08:15,459 --> 00:08:18,563
that I've had to make before dockerizing.

173
00:08:18,563 --> 00:08:20,300
And the main changes really

174
00:08:20,300 --> 00:08:23,366
are just in the way
that the profiles work.

175
00:08:23,366 --> 00:08:26,816
One of the criticisms I had
from the microservice course,

176
00:08:26,816 --> 00:08:29,011
and it's definitely a valid criticism,

177
00:08:29,011 --> 00:08:31,372
is that to get anything running,

178
00:08:31,372 --> 00:08:34,302
we had to have the entire system running.

179
00:08:34,302 --> 00:08:37,016
Without the microservice running,

180
00:08:37,016 --> 00:08:39,693
you couldn't run the webapp, for example.

181
00:08:39,693 --> 00:08:42,302
That was really just the
getting up and running

182
00:08:42,302 --> 00:08:43,871
quickly on that previous course,

183
00:08:43,871 --> 00:08:46,200
but I really want to
make clear at this point

184
00:08:46,200 --> 00:08:49,186
that that's not a good situation to be in.

185
00:08:49,186 --> 00:08:51,705
If you're working on a
microservice architecture,

186
00:08:51,705 --> 00:08:54,864
then you really want to
make as much as possible

187
00:08:54,864 --> 00:08:57,758
be able to run in standalone mode

188
00:08:57,758 --> 00:09:01,035
so that you can develop it in isolation.

189
00:09:01,035 --> 00:09:03,716
And so for that reason,
I've altered the webapp.

190
00:09:03,716 --> 00:09:06,334
In fact, you've seen
it through this course.

191
00:09:06,334 --> 00:09:09,295
I have a development profile.

192
00:09:09,295 --> 00:09:11,708
Let's look at that here.

193
00:09:11,708 --> 00:09:14,143
So I've got a set of
development properties here

194
00:09:14,143 --> 00:09:17,159
which is using an embedded database,

195
00:09:17,159 --> 00:09:20,656
and if I look in the
bootstrap-development.properties,

196
00:09:20,656 --> 00:09:25,049
you can see here that I'm
disabling the spring.cloud.config.

197
00:09:25,049 --> 00:09:27,333
That's the global config server.

198
00:09:27,333 --> 00:09:29,731
So that helps it to run standalone.

199
00:09:29,731 --> 00:09:31,564
But the main change is

200
00:09:32,911 --> 00:09:36,531
if I look in this services
package in the code.

201
00:09:36,531 --> 00:09:40,896
Now, the webapp makes a call
to that external microservice,

202
00:09:40,896 --> 00:09:43,081
the position tracker.

203
00:09:43,081 --> 00:09:45,018
What I had previously was just

204
00:09:45,018 --> 00:09:49,020
this PositionTrackingExternalService.java.

205
00:09:49,020 --> 00:09:52,500
And what we're doing here is on line 23,

206
00:09:52,500 --> 00:09:56,061
we are actually making a live rest call.

207
00:09:56,061 --> 00:09:57,661
We're also using Hystrix.

208
00:09:57,661 --> 00:09:58,950
I haven't mentioned that so far.

209
00:09:58,950 --> 00:10:02,241
Fantastic Hystrix from Netflix,

210
00:10:02,241 --> 00:10:04,849
and that gives us a lot of resilience.

211
00:10:04,849 --> 00:10:07,600
If there's any problems
with that REST call,

212
00:10:07,600 --> 00:10:10,428
then it will fall back to a backup method

213
00:10:10,428 --> 00:10:13,017
which doesn't need to
call the REST service.

214
00:10:13,017 --> 00:10:15,873
And we exploit that
extensively at runtime.

215
00:10:15,873 --> 00:10:17,812
We'll see that later.

216
00:10:17,812 --> 00:10:20,437
But the important thing here is that this

217
00:10:20,437 --> 00:10:25,162
won't really run if the
microservice isn't available.

218
00:10:25,162 --> 00:10:26,910
So, for that reason,

219
00:10:26,910 --> 00:10:30,686
I have provided a second
implementation of the remote

220
00:10:30,686 --> 00:10:33,676
microservice which I've called
the stub implementation,

221
00:10:33,676 --> 00:10:38,498
and it just generates random
values in a particular range.

222
00:10:38,498 --> 00:10:40,383
And that's why you've seen the vehicles

223
00:10:40,383 --> 00:10:44,291
bouncing around chaotically
at random through this course.

224
00:10:44,291 --> 00:10:47,055
I'm using the @Profile annotation here

225
00:10:47,055 --> 00:10:50,517
to make sure that that
only works in development

226
00:10:50,517 --> 00:10:54,345
and when we're been demoing
Docker through this course.

227
00:10:54,345 --> 00:10:58,066
So off-camera, I'd built a
jar file for this system,

228
00:10:58,066 --> 00:11:00,763
and I've pushed it to Docker Hub.

229
00:11:00,763 --> 00:11:04,346
And I'm just going down
to my Maven plugin.

230
00:11:05,634 --> 00:11:07,921
I've pushed it to Docker Hub

231
00:11:07,921 --> 00:11:10,330
on the fleetman-production repository.

232
00:11:10,330 --> 00:11:14,302
I've added a tag on there,
the microservice tag.

233
00:11:14,302 --> 00:11:16,003
So, when we go to our hardware

234
00:11:16,003 --> 00:11:18,781
and we do a Docker pull,

235
00:11:18,781 --> 00:11:22,715
we'll make sure that we pull
that version of the repository.

236
00:11:22,715 --> 00:11:23,989
Oh, and I haven't said.

237
00:11:23,989 --> 00:11:27,242
If we look under src > main > docker,

238
00:11:27,242 --> 00:11:30,689
there's the Dockerfile that
I've used to build the image.

239
00:11:30,689 --> 00:11:33,318
Notice that from now on,

240
00:11:33,318 --> 00:11:36,591
we're going to be running
under the docker profile,

241
00:11:36,591 --> 00:11:41,546
which I intend to mean the
Docker production profile.

242
00:11:41,546 --> 00:11:45,191
So if we have a look in the
application-docker.properties,

243
00:11:45,191 --> 00:11:46,264
throughout this course,

244
00:11:46,264 --> 00:11:50,685
I've been connecting this
webapp to a MySQL database.

245
00:11:50,685 --> 00:11:54,417
Now, I've been doing that just
for a demonstration really.

246
00:11:54,417 --> 00:11:55,846
Really, there's no reason

247
00:11:55,846 --> 00:11:58,924
to have a MySQL database on this system.

248
00:11:58,924 --> 00:12:01,679
A local embedded database
will work just as well.

249
00:12:01,679 --> 00:12:04,637
So I've reverted back to a local database.

250
00:12:04,637 --> 00:12:07,742
It just makes the
deployment less complicated.

251
00:12:07,742 --> 00:12:09,733
But a really important change,

252
00:12:09,733 --> 00:12:13,966
if we check in the
bootstrap-docker.properties file,

253
00:12:13,966 --> 00:12:17,244
and all of the microservices
will have a similar setup.

254
00:12:17,244 --> 00:12:21,077
I'm pointing here at the
global-config-server.

255
00:12:22,418 --> 00:12:24,793
Now, you know now how this works.

256
00:12:24,793 --> 00:12:27,557
This is going to be the
name of the container

257
00:12:27,557 --> 00:12:28,777
that we're connecting to.

258
00:12:28,777 --> 00:12:32,610
It will become a DNS
name in our Docker Swarm.

259
00:12:34,049 --> 00:12:35,918
Previously, I just left it at that,

260
00:12:35,918 --> 00:12:39,289
but I've added a few
extra properties here.

261
00:12:39,289 --> 00:12:41,687
And the reason for those
properties is to solve a problem

262
00:12:41,687 --> 00:12:43,722
which is very similar to
the problem we've seen

263
00:12:43,722 --> 00:12:46,477
several times on this
course with the database.

264
00:12:46,477 --> 00:12:48,539
Now, when we start up a microservice,

265
00:12:48,539 --> 00:12:51,230
let's say the position
tracking microservice,

266
00:12:51,230 --> 00:12:52,750
the very first thing it will do

267
00:12:52,750 --> 00:12:55,910
is it will consult a global config server

268
00:12:55,910 --> 00:12:57,535
to get its properties,

269
00:12:57,535 --> 00:13:00,213
and the default in Spring Boot

270
00:13:00,213 --> 00:13:02,756
is if that server's unavailable,

271
00:13:02,756 --> 00:13:05,898
then the Spring Boot
application will crash.

272
00:13:05,898 --> 00:13:06,994
Now, we've seen that cause us

273
00:13:06,994 --> 00:13:08,753
all kinds of problems in Docker,

274
00:13:08,753 --> 00:13:10,951
because we don't really have,

275
00:13:10,951 --> 00:13:13,496
well, we don't have a way of ensuring

276
00:13:13,496 --> 00:13:15,861
that this server is running,

277
00:13:15,861 --> 00:13:18,515
this service, I should say, is running,

278
00:13:18,515 --> 00:13:21,718
before this one tries to call it.

279
00:13:21,718 --> 00:13:23,297
So, what we'll almost certainly see

280
00:13:23,297 --> 00:13:25,180
when we deploy this into Docker

281
00:13:25,180 --> 00:13:28,547
is the position tracker will
contact the config server.

282
00:13:28,547 --> 00:13:29,612
It's not there.

283
00:13:29,612 --> 00:13:32,490
Position tracker would fall over.

284
00:13:32,490 --> 00:13:34,484
Now, we know from the previous chapters

285
00:13:34,484 --> 00:13:37,592
that actually when
running in a Docker Stack,

286
00:13:37,592 --> 00:13:38,568
that won't be a problem,

287
00:13:38,568 --> 00:13:42,409
because this container
will keep restarting again

288
00:13:42,409 --> 00:13:44,882
until it finally gets successful.

289
00:13:44,882 --> 00:13:46,766
But that's not very elegant,

290
00:13:46,766 --> 00:13:50,462
and also, it wouldn't work
very effectively locally.

291
00:13:50,462 --> 00:13:51,749
But we're looking in this case

292
00:13:51,749 --> 00:13:54,933
because after reading the
spring.cloud.config reference

293
00:13:54,933 --> 00:13:58,234
manual, I've discovered that
you can set a few properties.

294
00:13:58,234 --> 00:14:00,819
If you set failFast to true

295
00:14:00,819 --> 00:14:03,810
and you set these retry properties,

296
00:14:03,810 --> 00:14:06,060
then it will keep retrying.

297
00:14:06,936 --> 00:14:10,596
And I've set it to keep
retrying up to 15 times.

298
00:14:10,596 --> 00:14:14,138
And what it does is it starts
trying every five seconds,

299
00:14:14,138 --> 00:14:15,945
but every time it fails,

300
00:14:15,945 --> 00:14:17,801
it waits a little longer,

301
00:14:17,801 --> 00:14:20,129
up to a maximum of 20 seconds.

302
00:14:20,129 --> 00:14:21,608
So if you do the maths on that,

303
00:14:21,608 --> 00:14:23,605
it's going to wait several minutes

304
00:14:23,605 --> 00:14:26,067
before it finally gives up.

305
00:14:26,067 --> 00:14:29,293
So, I'm really glad that
cloud.config has that feature.

306
00:14:29,293 --> 00:14:32,471
I hope that Spring Boot in
general will include that feature

307
00:14:32,471 --> 00:14:33,738
in the future so that we can do

308
00:14:33,738 --> 00:14:36,897
the same kind of thing
with database connections.

309
00:14:36,897 --> 00:14:39,013
I've done exactly the
same kind of configuration

310
00:14:39,013 --> 00:14:42,799
for the other microservices
such as the position tracker.

311
00:14:42,799 --> 00:14:43,830
I just wanted to cover that

312
00:14:43,830 --> 00:14:46,774
so you're not confused if you've
done the previous courses.

313
00:14:46,774 --> 00:14:48,323
I did have to make some changes,

314
00:14:48,323 --> 00:14:50,415
and you can check them out for yourself.

315
00:14:50,415 --> 00:14:52,756
The only slightly strange project in here

316
00:14:52,756 --> 00:14:54,771
is the fleetman-queue,

317
00:14:54,771 --> 00:14:57,954
which doesn't really
have anything inside it,

318
00:14:57,954 --> 00:14:59,932
other than a Docker file.

319
00:14:59,932 --> 00:15:01,915
And that's because the fleetman-queue

320
00:15:01,915 --> 00:15:03,915
is just Apache ActiveMQ.

321
00:15:05,326 --> 00:15:07,935
So, you can check this out for yourself.

322
00:15:07,935 --> 00:15:10,196
All I'm doing in the Docker file here

323
00:15:10,196 --> 00:15:14,096
is I'm getting a version
of Apache ActiveMQ

324
00:15:14,096 --> 00:15:15,729
which I'm unzipping,

325
00:15:15,729 --> 00:15:18,160
and then I'm running ActiveMQ.

326
00:15:18,160 --> 00:15:19,898
So, it's really simple to deploy.

327
00:15:19,898 --> 00:15:21,452
Unfortunately, as far as I know,

328
00:15:21,452 --> 00:15:24,914
there are no standard containers
available from Docker Hub

329
00:15:24,914 --> 00:15:26,747
with ActiveMQ on them.

330
00:15:27,696 --> 00:15:30,037
So, what I've done with
all of these projects then

331
00:15:30,037 --> 00:15:31,647
is I've run their POMs,

332
00:15:31,647 --> 00:15:33,687
I've built images from each of them,

333
00:15:33,687 --> 00:15:36,902
and I've uploaded them to Docker Hub.

334
00:15:36,902 --> 00:15:39,724
So, we have fleetman-production,

335
00:15:39,724 --> 00:15:41,429
which is our webapp,

336
00:15:41,429 --> 00:15:43,789
and this now has tags.

337
00:15:43,789 --> 00:15:45,097
The latest tag is the one

338
00:15:45,097 --> 00:15:47,494
you've been working with
throughout the course.

339
00:15:47,494 --> 00:15:51,420
That's just a standalone
basic implementation.

340
00:15:51,420 --> 00:15:53,880
But we now have this microservice tag,

341
00:15:53,880 --> 00:15:56,848
which we are going to
use in a short while.

342
00:15:56,848 --> 00:16:00,083
We'll be using the no-netflix
tag in the next chapter.

343
00:16:00,083 --> 00:16:02,553
And you'll see all of the
other repositories are there.

344
00:16:02,553 --> 00:16:05,006
We've got the global-config-server,

345
00:16:05,006 --> 00:16:07,536
the position-simulator,
the position-tracker,

346
00:16:07,536 --> 00:16:10,526
the registry, and the queue.

347
00:16:10,526 --> 00:16:12,588
Now, you can use exactly the same images

348
00:16:12,588 --> 00:16:14,123
that I'm using here.

349
00:16:14,123 --> 00:16:15,728
I'm going to leave them on Docker Hub,

350
00:16:15,728 --> 00:16:19,531
and I promise I won't be
changing any of those instances

351
00:16:19,531 --> 00:16:21,649
for as long as Docker Hub exists.

352
00:16:21,649 --> 00:16:22,982
I won't touch them again.

353
00:16:22,982 --> 00:16:25,724
So you can follow along
with this demo and use

354
00:16:25,724 --> 00:16:30,397
exactly the same docker-compose.yaml
file as I'm using.

355
00:16:30,397 --> 00:16:32,721
Of course, if you want
to tweak the system,

356
00:16:32,721 --> 00:16:34,241
and you want to make changes,

357
00:16:34,241 --> 00:16:36,930
then you're going to have
to build your own images,

358
00:16:36,930 --> 00:16:38,841
and you can do that using the code

359
00:16:38,841 --> 00:16:41,610
from the Practical and
Code download folder.

360
00:16:41,610 --> 00:16:43,749
Just make whatever changes you want

361
00:16:43,749 --> 00:16:47,420
and push the images to
your own repository.

362
00:16:47,420 --> 00:16:51,161
All we have to do now is
get running in production.

363
00:16:51,161 --> 00:16:54,745
So for this course, we're going
to use Amazon EC2 to deploy.

364
00:16:54,745 --> 00:16:57,370
You might be aware that
there's a service in Amazon

365
00:16:57,370 --> 00:17:01,537
called ECS, which is basically
the Amazon container service.

366
00:17:03,474 --> 00:17:05,365
That allows us to do many of the things

367
00:17:05,365 --> 00:17:06,733
that we've been doing on this course

368
00:17:06,733 --> 00:17:09,227
in a kind of a managed way.

369
00:17:09,227 --> 00:17:12,413
Now, I'm not a big fan
of ECS, I must admit,

370
00:17:12,413 --> 00:17:15,063
and I was planning to have a
chapter on ECS on this course,

371
00:17:15,063 --> 00:17:17,228
but due to time pressures,

372
00:17:17,228 --> 00:17:20,205
we won't be using ECS on this course.

373
00:17:20,205 --> 00:17:23,285
I may do a follow-on
module a little later.

374
00:17:23,285 --> 00:17:25,740
That's to say, I'm not
an enormous fan of ECS.

375
00:17:25,740 --> 00:17:27,811
One of the main problems I have with it

376
00:17:27,811 --> 00:17:30,711
is it always lags behind
the Docker functionality.

377
00:17:30,711 --> 00:17:33,746
So I often find I can do what I want to do

378
00:17:33,746 --> 00:17:36,825
using the regular tools
such as Docker Swam

379
00:17:36,825 --> 00:17:37,912
that we've seen.

380
00:17:37,912 --> 00:17:40,182
Having said that, we
should do a video on it,

381
00:17:40,182 --> 00:17:42,393
and that will be coming in the future.

382
00:17:42,393 --> 00:17:44,295
But what I'm going to do for this video

383
00:17:44,295 --> 00:17:46,603
is just manually launch some instances,

384
00:17:46,603 --> 00:17:50,252
and then we'll set those
instances up as a swarm,

385
00:17:50,252 --> 00:17:53,217
and we will deploy a stack to it.

386
00:17:53,217 --> 00:17:55,331
If you don't have an Amazon account,

387
00:17:55,331 --> 00:17:58,492
then I recommend you just
watch the rest of this video.

388
00:17:58,492 --> 00:18:00,625
You should still learn plenty from it.

389
00:18:00,625 --> 00:18:04,792
Or you can check out or Getting
Started with AWS course,

390
00:18:05,660 --> 00:18:08,741
which is available at
Virtual Pair Programmers.

391
00:18:08,741 --> 00:18:11,754
As I always say on any
course where we're using AWS,

392
00:18:11,754 --> 00:18:13,365
if you are following along with me,

393
00:18:13,365 --> 00:18:16,905
please remember to delete
any resources that you use

394
00:18:16,905 --> 00:18:18,319
at the end of your session,

395
00:18:18,319 --> 00:18:20,411
or you will be charged.

396
00:18:20,411 --> 00:18:21,955
However, all we're going to need

397
00:18:21,955 --> 00:18:24,570
are four basic instances.

398
00:18:24,570 --> 00:18:26,560
So I'm going to do this manually

399
00:18:26,560 --> 00:18:29,391
using the graphical interface.

400
00:18:29,391 --> 00:18:32,740
In real life, I would be scripting this.

401
00:18:32,740 --> 00:18:35,452
I use Ansible scripts to do this.

402
00:18:35,452 --> 00:18:37,100
So I'd run a simple Ansible script,

403
00:18:37,100 --> 00:18:39,003
and it would have four instances,

404
00:18:39,003 --> 00:18:41,603
ready to go, configured in swarm mode.

405
00:18:41,603 --> 00:18:43,473
I don't want to
overcomplicate this session,

406
00:18:43,473 --> 00:18:46,240
though, so if you're
interested in Ansible,

407
00:18:46,240 --> 00:18:48,812
then check out our
microservice deployment course.

408
00:18:48,812 --> 00:18:51,096
I've got a load of good stuff in there.

409
00:18:51,096 --> 00:18:52,968
But manual will do for now.

410
00:18:52,968 --> 00:18:55,095
And before you launch any instances,

411
00:18:55,095 --> 00:18:58,533
I'm going to recommend that you
go into the security groups,

412
00:18:58,533 --> 00:19:02,688
and we're going to create a
security group in advance.

413
00:19:02,688 --> 00:19:05,073
Now, I know that you can
create a security group

414
00:19:05,073 --> 00:19:07,921
while you're going through
the Launch Instance wizard,

415
00:19:07,921 --> 00:19:10,506
but there's a reason why I
want to do this in advance.

416
00:19:10,506 --> 00:19:12,594
I'll explain in a moment.

417
00:19:12,594 --> 00:19:14,236
Security group name can be anything.

418
00:19:14,236 --> 00:19:18,403
I'm going to go for
fleetman-swarm-security-group.

419
00:19:19,533 --> 00:19:21,492
Description doesn't matter.

420
00:19:21,492 --> 00:19:24,325
I'll in fact just copy that label.

421
00:19:25,306 --> 00:19:26,887
And you will almost certainly be working

422
00:19:26,887 --> 00:19:29,297
in a virtual private cloud here.

423
00:19:29,297 --> 00:19:32,779
Almost all accounts now
have this as the default.

424
00:19:32,779 --> 00:19:35,558
Now, we're doing this because
we do need to open up some

425
00:19:35,558 --> 00:19:39,287
special ports to allow things
like the Docker routing mesh

426
00:19:39,287 --> 00:19:42,488
or routing mesh to operate successfully.

427
00:19:42,488 --> 00:19:43,321
You might remember

428
00:19:43,321 --> 00:19:44,505
we saw this earlier on the course

429
00:19:44,505 --> 00:19:48,672
that we need a few ports
open, such as TCP port 2377.

430
00:19:49,932 --> 00:19:51,209
So, we'll add a rule then,

431
00:19:51,209 --> 00:19:53,459
a Custom TCP rule for 2377,

432
00:19:55,881 --> 00:20:00,442
and for now, I'm going
to set that to Anywhere.

433
00:20:00,442 --> 00:20:02,998
That's opening up that
port to the entire world,

434
00:20:02,998 --> 00:20:06,188
even though that port's
only needed internally

435
00:20:06,188 --> 00:20:07,884
in our virtual private cloud.

436
00:20:07,884 --> 00:20:09,743
I can't find an easy way to set the source

437
00:20:09,743 --> 00:20:13,518
to be just instances in
this virtual private cloud.

438
00:20:13,518 --> 00:20:16,254
So I'm going to set it to anywhere

439
00:20:16,254 --> 00:20:17,793
and then save these rules,

440
00:20:17,793 --> 00:20:20,922
and then we'll edit
them to tighten them up.

441
00:20:20,922 --> 00:20:23,755
So, we'll also need TCP port 7946.

442
00:20:25,708 --> 00:20:26,708
So TCP 7946.

443
00:20:28,642 --> 00:20:30,860
Again, I'll leave that on Anywhere.

444
00:20:30,860 --> 00:20:33,610
We need UDP ports 7946, Anywhere,

445
00:20:40,792 --> 00:20:42,542
and we need UDP 4789.

446
00:20:45,155 --> 00:20:46,738
UDP 4789, Anywhere.

447
00:20:51,071 --> 00:20:54,597
And my reasoning for doing that
is if I now click on Create,

448
00:20:54,597 --> 00:20:57,614
and then we go into that security group

449
00:20:57,614 --> 00:21:00,614
and click on Inbound, click on Edit,

450
00:21:01,748 --> 00:21:04,213
and now, I can change this.

451
00:21:04,213 --> 00:21:07,269
I can add into here, if I just clear out

452
00:21:07,269 --> 00:21:11,548
what was there and press
F-L, I now get the option

453
00:21:11,548 --> 00:21:14,884
to choose fleetman-swarm-security-group.

454
00:21:14,884 --> 00:21:17,338
Now, I couldn't work out how
to do that in the first place,

455
00:21:17,338 --> 00:21:21,058
so that's why I've done this
saving and then re-editing.

456
00:21:21,058 --> 00:21:22,805
I'm sure there's a better way of doing it,

457
00:21:22,805 --> 00:21:24,035
but I don't know it.

458
00:21:24,035 --> 00:21:26,186
I usually do this through Ansible scripts,

459
00:21:26,186 --> 00:21:28,326
but I can now do exactly the same thing

460
00:21:28,326 --> 00:21:30,266
for the rest of them now.

461
00:21:30,266 --> 00:21:33,288
So I need the
fleetman-swarm-security-group

462
00:21:33,288 --> 00:21:36,681
on all of these, and what this now means

463
00:21:36,681 --> 00:21:41,524
is that these ports are
only open to other instances

464
00:21:41,524 --> 00:21:44,305
which are in the same security group.

465
00:21:44,305 --> 00:21:45,373
So that's very powerful.

466
00:21:45,373 --> 00:21:48,464
It means I'm not opening up these ports

467
00:21:48,464 --> 00:21:50,639
to the wider internet.

468
00:21:50,639 --> 00:21:52,503
But I should also, while I'm here,

469
00:21:52,503 --> 00:21:55,296
add in another rule for SSH

470
00:21:55,296 --> 00:21:59,978
so we can log onto it, and
I can set that to be my IP

471
00:21:59,978 --> 00:22:02,036
so that only I can log onto it.

472
00:22:02,036 --> 00:22:03,595
You can do the same.

473
00:22:03,595 --> 00:22:05,657
And we also ought to,

474
00:22:05,657 --> 00:22:08,907
we'll definitely need HTTP port 80 open

475
00:22:09,765 --> 00:22:12,958
so that nobody else can
access this application.

476
00:22:12,958 --> 00:22:15,031
We'll definitely need
to make changes here,

477
00:22:15,031 --> 00:22:15,982
but that will do for now.

478
00:22:15,982 --> 00:22:17,833
Let's click on save.

479
00:22:17,833 --> 00:22:18,849
Well, I have an error doing that,

480
00:22:18,849 --> 00:22:21,927
and I wasn't really thinking
as I was going down this.

481
00:22:21,927 --> 00:22:23,757
If you just rewind the video back,

482
00:22:23,757 --> 00:22:26,812
there were two entries
for each of these rules.

483
00:22:26,812 --> 00:22:30,557
And I think one entry was the IPv4 format

484
00:22:30,557 --> 00:22:33,298
and one was the IPv6 format.

485
00:22:33,298 --> 00:22:36,378
I don't think it's a very
good user interface at all,

486
00:22:36,378 --> 00:22:37,211
this really.

487
00:22:37,211 --> 00:22:38,308
I think what we can do here

488
00:22:38,308 --> 00:22:41,432
is we an delete every duplicate entry.

489
00:22:41,432 --> 00:22:44,682
Be careful that you still have UDP 7946

490
00:22:46,937 --> 00:22:48,020
and TCP 7946.

491
00:22:52,545 --> 00:22:55,021
So you should end up with four rules,

492
00:22:55,021 --> 00:22:56,854
two TCPs and two UDPs.

493
00:22:59,589 --> 00:23:01,256
Hopefully this time,

494
00:23:02,237 --> 00:23:03,921
it will allow me to save.

495
00:23:03,921 --> 00:23:05,621
As I've said many times before,

496
00:23:05,621 --> 00:23:08,580
we'd be doing this via
script in real life.

497
00:23:08,580 --> 00:23:10,350
Anyway, now we can go back to instances,

498
00:23:10,350 --> 00:23:12,389
and we can launch our swarm.

499
00:23:12,389 --> 00:23:16,029
So I'll choose the Amazon Linux AMI.

500
00:23:16,029 --> 00:23:19,590
T2 micro should do the
job for what we're doing.

501
00:23:19,590 --> 00:23:22,940
You could possibly even
get away with the t2 nano.

502
00:23:22,940 --> 00:23:24,720
T2 micro is fine.

503
00:23:24,720 --> 00:23:26,508
Configure instance details.

504
00:23:26,508 --> 00:23:27,597
This is important.

505
00:23:27,597 --> 00:23:29,848
I'm going to change the one to a four,

506
00:23:29,848 --> 00:23:32,670
and it nags me that I should
use an auto-scaling group here.

507
00:23:32,670 --> 00:23:33,690
No I shouldn't.

508
00:23:33,690 --> 00:23:35,438
I'm doing a demo, thank you.

509
00:23:35,438 --> 00:23:38,259
I think all of the
defaults will be good here.

510
00:23:38,259 --> 00:23:39,771
Next page is Add Storage,

511
00:23:39,771 --> 00:23:40,901
that's fine.

512
00:23:40,901 --> 00:23:42,922
Next page is Add Tags.

513
00:23:42,922 --> 00:23:46,237
I think we should add in a name tag.

514
00:23:46,237 --> 00:23:49,797
I'll just call this Docker Swarm.

515
00:23:49,797 --> 00:23:51,057
Click on Next.

516
00:23:51,057 --> 00:23:52,254
Now, this is important.

517
00:23:52,254 --> 00:23:54,675
Select an existing security group

518
00:23:54,675 --> 00:23:57,341
and choose the one you created previously,

519
00:23:57,341 --> 00:24:00,397
and at last, we're on Review and Launch.

520
00:24:00,397 --> 00:24:03,274
Click on Launch, and you'll
need to either create

521
00:24:03,274 --> 00:24:07,408
a new key pair or use one
that you have access to

522
00:24:07,408 --> 00:24:10,268
and make sure you download that key pair.

523
00:24:10,268 --> 00:24:11,845
I'm sorry if I'm boring you here.

524
00:24:11,845 --> 00:24:15,164
I'm assuming you're all
familiar with EC2 anyway.

525
00:24:15,164 --> 00:24:19,331
So, we now have four instances
all in the pending state.

526
00:24:20,727 --> 00:24:24,526
Now, without the script, this
is going to be really tedious,

527
00:24:24,526 --> 00:24:26,475
but hey, ho, nevermind.

528
00:24:26,475 --> 00:24:28,826
Go into the directory
where your key pair is,

529
00:24:28,826 --> 00:24:31,060
and we'll log in.

530
00:24:31,060 --> 00:24:34,810
I think I called mine
fleetman-swarm-keypair,

531
00:24:36,046 --> 00:24:38,959
and I'll go for the first one on my list.

532
00:24:38,959 --> 00:24:41,880
It's this IP address here,

533
00:24:41,880 --> 00:24:44,239
and we'll need to confirm
that we're connecting.

534
00:24:44,239 --> 00:24:46,830
Now, if this is the first
time we've used this key pair,

535
00:24:46,830 --> 00:24:47,847
you'll need to remember

536
00:24:47,847 --> 00:24:50,432
to change the permissions
on that key pair.

537
00:24:50,432 --> 00:24:54,926
Something like a chmod, G
and O for group and others,

538
00:24:54,926 --> 00:24:57,509
minus read, write, and execute,

539
00:25:00,145 --> 00:25:03,062
on that file should make SSH happy.

540
00:25:04,097 --> 00:25:05,349
So, there we are.

541
00:25:05,349 --> 00:25:07,503
We're logged into that instance.

542
00:25:07,503 --> 00:25:10,336
I'll log into the second instance.

543
00:25:13,012 --> 00:25:14,300
And you get the idea.

544
00:25:14,300 --> 00:25:17,077
I'll log into the other
two instances off camera.

545
00:25:17,077 --> 00:25:19,191
Okay, so I'm logged into all of them,

546
00:25:19,191 --> 00:25:20,957
and the first job we need to do.

547
00:25:20,957 --> 00:25:23,176
Again, this would be done
by a script normally,

548
00:25:23,176 --> 00:25:24,904
so we'll have to do it by hand.

549
00:25:24,904 --> 00:25:26,874
And you're going to need to instal Docker

550
00:25:26,874 --> 00:25:29,003
on all four of these instances,

551
00:25:29,003 --> 00:25:32,238
but it won't be too bad just as a one-off.

552
00:25:32,238 --> 00:25:34,668
Exactly as we did in
the very first chapter

553
00:25:34,668 --> 00:25:39,323
probably on module one, you
can instal on Amazon Linux AMI

554
00:25:39,323 --> 00:25:41,490
with a sudo yum instal -y

555
00:25:43,388 --> 00:25:46,523
to avoid having to confirm Docker.

556
00:25:46,523 --> 00:25:48,033
I will warn you, this will instal

557
00:25:48,033 --> 00:25:51,279
a slightly older version of
Docker at the time of recording,

558
00:25:51,279 --> 00:25:55,001
so we might find that some
feature are not available.

559
00:25:55,001 --> 00:25:57,765
But it's reasonably up-to-date.

560
00:25:57,765 --> 00:25:59,324
So, I've installed docker on all four,

561
00:25:59,324 --> 00:26:02,974
and we'll need to do a sudo
usermod, dash, lowercase a,

562
00:26:02,974 --> 00:26:05,557
capital G, docker and ec2-user,

563
00:26:07,222 --> 00:26:10,722
which will add us to the Docker usergroup.

564
00:26:11,796 --> 00:26:14,895
And I'll repeat that on the other...

565
00:26:14,895 --> 00:26:18,087
I'll repeat that on the other instances.

566
00:26:18,087 --> 00:26:21,837
We'll need to do a sudo
service docker start,

567
00:26:24,649 --> 00:26:25,982
and on the rest,

568
00:26:28,720 --> 00:26:29,797
and I think that's it.

569
00:26:29,797 --> 00:26:32,605
If we exit out of all of those now,

570
00:26:32,605 --> 00:26:36,203
the exiting just is a
quick way of picking up

571
00:26:36,203 --> 00:26:39,486
the changes to the changing usergroup.

572
00:26:39,486 --> 00:26:42,403
We log back onto all of them again.

573
00:26:43,517 --> 00:26:45,185
We should now be able to do

574
00:26:45,185 --> 00:26:48,102
a docker container run hello-world.

575
00:26:50,606 --> 00:26:53,758
May as well do it on all of them.

576
00:26:53,758 --> 00:26:55,091
Spinning plates.

577
00:26:57,201 --> 00:26:58,451
That's working,

578
00:27:00,494 --> 00:27:01,327
and there,

579
00:27:03,689 --> 00:27:04,522
and there.

580
00:27:06,698 --> 00:27:09,131
So, we need to initiate
a Docker swarm then,

581
00:27:09,131 --> 00:27:10,292
and you know what to do now.

582
00:27:10,292 --> 00:27:11,792
Docker swarm init.

583
00:27:13,252 --> 00:27:16,266
So now we need to join the
other three to the swarm.

584
00:27:16,266 --> 00:27:20,678
So, it's showing us how to
add a worker to the swarm,

585
00:27:20,678 --> 00:27:23,614
but I want actually three
managers in this swarm.

586
00:27:23,614 --> 00:27:25,952
We'll have three managers and one worker.

587
00:27:25,952 --> 00:27:30,119
So, we can do that, as
indicated here by docker swarm

588
00:27:31,506 --> 00:27:33,089
join-token manager.

589
00:27:36,000 --> 00:27:38,744
I'll just make the screen
wider so it all fits in.

590
00:27:38,744 --> 00:27:40,560
And it's getting late in the course.

591
00:27:40,560 --> 00:27:42,249
I always say that.

592
00:27:42,249 --> 00:27:44,832
Docker swarm, not docker swarn.

593
00:27:45,711 --> 00:27:47,878
So if I copy this command,

594
00:27:49,285 --> 00:27:52,618
and paste that into one of the consoles,

595
00:27:53,472 --> 00:27:54,305
excellent.

596
00:27:54,305 --> 00:27:56,269
The node has now joined as a manager.

597
00:27:56,269 --> 00:27:59,634
Now, if this had failed,
then it's almost certainly

598
00:27:59,634 --> 00:28:02,897
something to do with your security group.

599
00:28:02,897 --> 00:28:06,125
So go back and check
what you've done there.

600
00:28:06,125 --> 00:28:08,327
So, I've got two managers.

601
00:28:08,327 --> 00:28:10,077
Let's add in a third.

602
00:28:11,694 --> 00:28:12,527
Great.

603
00:28:12,527 --> 00:28:15,392
And finally, I want a worker here.

604
00:28:15,392 --> 00:28:17,530
Now, just to demonstrate,

605
00:28:17,530 --> 00:28:19,795
because I have my terminal
a little bit short,

606
00:28:19,795 --> 00:28:20,780
this has gotten mangled,

607
00:28:20,780 --> 00:28:23,290
and it won't be easy to copy and paste.

608
00:28:23,290 --> 00:28:25,206
So I'll just demonstrate
that we can always get

609
00:28:25,206 --> 00:28:29,206
another join token with
docker swarm join-token,

610
00:28:32,392 --> 00:28:33,725
and then worker.

611
00:28:34,726 --> 00:28:36,757
And we're issued, it's
not actually a new token.

612
00:28:36,757 --> 00:28:40,114
It's the same as the
worker token from before.

613
00:28:40,114 --> 00:28:44,281
So let's copy that and paste
that into the final terminal.

614
00:28:46,891 --> 00:28:49,379
So, there's our swarm
up and running going on.

615
00:28:49,379 --> 00:28:53,264
Any manager, we can do a docker node ls,

616
00:28:53,264 --> 00:28:56,447
and there's our swarm up and running.

617
00:28:56,447 --> 00:28:57,667
What to do next?

618
00:28:57,667 --> 00:28:59,716
Well, we need to launch a stack,

619
00:28:59,716 --> 00:29:02,382
and in your Microservice Projects folder,

620
00:29:02,382 --> 00:29:04,966
you will find a docker-compose file

621
00:29:04,966 --> 00:29:06,906
that I will have been using locally

622
00:29:06,906 --> 00:29:10,490
when building the system
up on my local computer.

623
00:29:10,490 --> 00:29:12,200
Let's have a little look at it, but I hope

624
00:29:12,200 --> 00:29:15,360
you'll find absolutely
nothing scary in here at all.

625
00:29:15,360 --> 00:29:19,359
We just have a list of the
services that we're deploying.

626
00:29:19,359 --> 00:29:20,969
Now, for testing purposes,

627
00:29:20,969 --> 00:29:23,804
I'm going to publish the ports
of many of these services.

628
00:29:23,804 --> 00:29:24,722
So, for example,

629
00:29:24,722 --> 00:29:28,889
the global-config-server
runs by default on port 8888.

630
00:29:30,103 --> 00:29:32,468
I've decided to publish that port

631
00:29:32,468 --> 00:29:34,768
so that we can test
this is up and running.

632
00:29:34,768 --> 00:29:38,190
Same thing for the queue, which is 8161.

633
00:29:38,190 --> 00:29:40,944
The registry is on 8010.

634
00:29:40,944 --> 00:29:42,111
That's Eureka.

635
00:29:42,984 --> 00:29:44,453
But as soon as we've got this working,

636
00:29:44,453 --> 00:29:48,183
we can easily remove those
port definitions, and then

637
00:29:48,183 --> 00:29:51,442
those services will not be
available on the internet.

638
00:29:51,442 --> 00:29:53,011
I had so many complaints

639
00:29:53,011 --> 00:29:56,327
from the deployment course about that.

640
00:29:56,327 --> 00:29:57,160
Oh, and at the bottom,

641
00:29:57,160 --> 00:29:59,674
we have the definition
of our Docker network.

642
00:29:59,674 --> 00:30:00,507
But we need to get this file

643
00:30:00,507 --> 00:30:03,395
onto one of the managers on EC2,

644
00:30:03,395 --> 00:30:06,136
and as before, I suggest
we just do this with nano

645
00:30:06,136 --> 00:30:07,054
and a copy and paste.

646
00:30:07,054 --> 00:30:09,508
If you prefer, we could
do a save ftp of it,

647
00:30:09,508 --> 00:30:10,943
if you prefer.

648
00:30:10,943 --> 00:30:14,909
So, exactly as we did in
the previous chapter really,

649
00:30:14,909 --> 00:30:17,851
we'll nano a docker-compose.yaml,

650
00:30:17,851 --> 00:30:22,640
paste in those contents, and
we're almost ready to run,

651
00:30:22,640 --> 00:30:25,217
except there is a little bit of a problem.

652
00:30:25,217 --> 00:30:29,384
When I first ran a system like
this on their EC2 instances,

653
00:30:30,735 --> 00:30:34,795
I had a real problem getting
the overlay network working.

654
00:30:34,795 --> 00:30:37,626
I simply couldn't refer
to another container

655
00:30:37,626 --> 00:30:40,314
simply by its name, which is of course

656
00:30:40,314 --> 00:30:42,608
what we rely on for this system.

657
00:30:42,608 --> 00:30:46,582
And it took me ages to debug that problem.

658
00:30:46,582 --> 00:30:48,971
I must have lost...

659
00:30:48,971 --> 00:30:52,097
It was a lot of days that
I lost, put it that way.

660
00:30:52,097 --> 00:30:54,627
I finally found this case
on the GitHub repository

661
00:30:54,627 --> 00:30:55,993
which gave me a clue.

662
00:30:55,993 --> 00:30:58,884
Now, it is quite a complicated case,

663
00:30:58,884 --> 00:31:02,524
and I don't intend to go into the details.

664
00:31:02,524 --> 00:31:04,694
But going a little further down,

665
00:31:04,694 --> 00:31:06,777
I basically realised
that this guy's problem

666
00:31:06,777 --> 00:31:08,368
is exactly the same as mine.

667
00:31:08,368 --> 00:31:10,952
He was running on EC2 instances,

668
00:31:10,952 --> 00:31:14,344
and the answer here on
the ninth of December

669
00:31:14,344 --> 00:31:17,798
from this user is saying that the problem

670
00:31:17,798 --> 00:31:21,081
I was experiencing was
actually to be expected,

671
00:31:21,081 --> 00:31:22,614
and what we have to do,

672
00:31:22,614 --> 00:31:26,250
his suggestion here is that
we have to explicitly specify

673
00:31:26,250 --> 00:31:29,000
a subnet for the overlay network.

674
00:31:30,655 --> 00:31:32,004
Now, he does go into details

675
00:31:32,004 --> 00:31:34,536
about exactly why this is happening.

676
00:31:34,536 --> 00:31:36,604
It's way beyond the scope of this course,

677
00:31:36,604 --> 00:31:39,552
and you can read that as a
secret code for me saying,

678
00:31:39,552 --> 00:31:42,082
I don't understand all
the details of this.

679
00:31:42,082 --> 00:31:44,224
But what I do know is
if I follow his advice

680
00:31:44,224 --> 00:31:45,825
and set up a subnet,

681
00:31:45,825 --> 00:31:48,096
which is just a range
of private IP addresses

682
00:31:48,096 --> 00:31:49,843
that this network will use,

683
00:31:49,843 --> 00:31:52,265
then all will be well.

684
00:31:52,265 --> 00:31:54,412
Now, the upshot of that
is it just means we need

685
00:31:54,412 --> 00:31:58,579
to configure this network
here by specifying the subnet.

686
00:31:59,605 --> 00:32:00,958
You need to check the reference manual

687
00:32:00,958 --> 00:32:02,380
for details on how to do that.

688
00:32:02,380 --> 00:32:03,672
It's not intuitive.

689
00:32:03,672 --> 00:32:08,581
You have to put in a key
called ipam, first of all.

690
00:32:08,581 --> 00:32:12,248
So ipam, colon, and
then another indentation

691
00:32:13,824 --> 00:32:17,824
and config, colon, and
then another indentation,

692
00:32:19,772 --> 00:32:22,158
and then we have a list element,

693
00:32:22,158 --> 00:32:26,067
subnet, colon, and then you just need

694
00:32:26,067 --> 00:32:29,674
to set a range of private IP addresses.

695
00:32:29,674 --> 00:32:31,710
And I've discovered that
what works perfectly well

696
00:32:31,710 --> 00:32:35,293
is something like 172.28.0.0/16,

697
00:32:39,218 --> 00:32:43,954
and that's going to create
65,000-ish IP addresses

698
00:32:43,954 --> 00:32:46,834
that our Docker Swarm network can use.

699
00:32:46,834 --> 00:32:49,858
Not the most intuitive thing in the world,

700
00:32:49,858 --> 00:32:51,441
but it should work.

701
00:32:52,904 --> 00:32:55,281
So you might want to review
of this before we run it,

702
00:32:55,281 --> 00:32:58,745
but basically, I'm pointing
at a variety of images

703
00:32:58,745 --> 00:33:01,166
that I've pushed to Docker Hub.

704
00:33:01,166 --> 00:33:05,333
The one strange one is the
fleetman-production here,

705
00:33:06,627 --> 00:33:08,219
which is actually the webapp.

706
00:33:08,219 --> 00:33:11,423
We specifically need the
microservice tagged version

707
00:33:11,423 --> 00:33:14,707
because the latest version
is that basic version

708
00:33:14,707 --> 00:33:18,259
that we've been using through
the rest of the course.

709
00:33:18,259 --> 00:33:20,396
Now, before I do anything else,

710
00:33:20,396 --> 00:33:22,873
I would like to have that visualizer

711
00:33:22,873 --> 00:33:25,102
that we saw in the previous chapter.

712
00:33:25,102 --> 00:33:27,100
Definitely worthwhile having.

713
00:33:27,100 --> 00:33:28,783
So if you remember how to do that,

714
00:33:28,783 --> 00:33:32,533
it's docker container
run -data for detached,

715
00:33:34,124 --> 00:33:35,727
- p to publish ports.

716
00:33:35,727 --> 00:33:38,274
Let's go for 5,000 again.

717
00:33:38,274 --> 00:33:39,925
Well, of course, I'm going
to forget how to do this,

718
00:33:39,925 --> 00:33:42,012
so on their reference manual...

719
00:33:42,012 --> 00:33:45,346
Yeah, we have to map to
port 8080, and we need that

720
00:33:45,346 --> 00:33:49,513
mount point, which is -v
/var/run/docker.sock, colon,

721
00:33:55,347 --> 00:33:59,514
and then a repeat, /var/run/docker.sock.

722
00:34:01,893 --> 00:34:06,060
And then the image is
dockersamples/visualizer.

723
00:34:07,947 --> 00:34:10,499
The hardest thing is spelling that right.

724
00:34:10,499 --> 00:34:13,390
Now remember, we're not running
the visualizer in the swarm.

725
00:34:13,390 --> 00:34:15,977
So the visualizer will not be available

726
00:34:15,977 --> 00:34:18,910
on all the IP addresses in the swarm.

727
00:34:18,910 --> 00:34:20,849
I know that the instance
I was working with there

728
00:34:20,849 --> 00:34:23,757
was this one, the first in the list,

729
00:34:23,757 --> 00:34:26,704
with this public IP address here.

730
00:34:26,704 --> 00:34:29,287
Of course, we're going to need
to set some firewall rules.

731
00:34:29,287 --> 00:34:33,406
So if I follow the link
to security group here,

732
00:34:33,406 --> 00:34:36,887
I click on Edit for the inbound rules,

733
00:34:36,887 --> 00:34:39,804
and we'll add a rule for port 5000.

734
00:34:41,145 --> 00:34:43,811
Again, I'll just use my IP address,

735
00:34:43,811 --> 00:34:45,222
and while I'm here,

736
00:34:45,222 --> 00:34:46,547
I know that for the demo,

737
00:34:46,547 --> 00:34:48,986
I'm also going to need 8161

738
00:34:48,986 --> 00:34:50,653
for Apache ActiveMQ.

739
00:34:53,556 --> 00:34:57,473
It'll also be worth
looking at 8010 for Eureka,

740
00:34:58,648 --> 00:35:00,543
and that's probably enough.

741
00:35:00,543 --> 00:35:01,431
I don't think I'll be bothering

742
00:35:01,431 --> 00:35:04,769
looking at 8888 for config server.

743
00:35:04,769 --> 00:35:09,038
Remember, we very quickly
close these down completely

744
00:35:09,038 --> 00:35:12,331
once we're happy everything is running.

745
00:35:12,331 --> 00:35:13,933
So, let's save that.

746
00:35:13,933 --> 00:35:15,726
By now, the container should be running,

747
00:35:15,726 --> 00:35:16,833
and it is.

748
00:35:16,833 --> 00:35:19,289
So back to the browser for the IP address.

749
00:35:19,289 --> 00:35:20,240
Fantastic.

750
00:35:20,240 --> 00:35:22,921
We have a visualisation of our swarm.

751
00:35:22,921 --> 00:35:24,464
It's currently empty.

752
00:35:24,464 --> 00:35:26,368
Let's deploy a stack.

753
00:35:26,368 --> 00:35:28,944
So, back on that manager node then,

754
00:35:28,944 --> 00:35:31,195
exactly as we did in previous chapters,

755
00:35:31,195 --> 00:35:33,028
docker stack deploy -c

756
00:35:37,971 --> 00:35:40,123
for the docker-compose.yaml,

757
00:35:40,123 --> 00:35:42,327
and finally what we
want to call the stack,

758
00:35:42,327 --> 00:35:44,789
I'll go for fleetman -stack again

759
00:35:44,789 --> 00:35:47,923
just to stay consistent
with previous chapters.

760
00:35:47,923 --> 00:35:49,490
So we'll keep the visualizer in place

761
00:35:49,490 --> 00:35:51,250
while we're running this.

762
00:35:51,250 --> 00:35:53,167
Let's see what happens.

763
00:35:56,086 --> 00:35:58,889
Oh, man, that feels good.

764
00:35:58,889 --> 00:36:01,038
So we can see some containers now

765
00:36:01,038 --> 00:36:03,547
being deployed into our stack.

766
00:36:03,547 --> 00:36:06,784
They're all currently
in the preparing state.

767
00:36:06,784 --> 00:36:09,304
Some of them have now switched to running.

768
00:36:09,304 --> 00:36:13,551
So I can see here the
global-config server's running.

769
00:36:13,551 --> 00:36:15,051
That's the webapp.

770
00:36:15,986 --> 00:36:17,317
This is the queue,

771
00:36:17,317 --> 00:36:20,137
which is taking a while,
by the look of it.

772
00:36:20,137 --> 00:36:22,575
Slightly concerned about that.

773
00:36:22,575 --> 00:36:23,945
Now of course I could go behind the scenes

774
00:36:23,945 --> 00:36:25,972
and look at the logs of
any of these services,

775
00:36:25,972 --> 00:36:29,376
but I need to warn you that
at the time of recording,

776
00:36:29,376 --> 00:36:30,653
I've mentioned several times

777
00:36:30,653 --> 00:36:34,236
that the ability to do
a Docker service log

778
00:36:37,054 --> 00:36:40,907
is a new feature, and it
really is a new feature,

779
00:36:40,907 --> 00:36:43,094
because the version that's being installed

780
00:36:43,094 --> 00:36:46,499
on the Amazon instances
is slightly out of date.

781
00:36:46,499 --> 00:36:48,999
If I do a log on, for example,

782
00:36:50,554 --> 00:36:53,137
fleetman-stack_fleetman-webapp,

783
00:36:57,477 --> 00:36:59,274
we're going to get an error,

784
00:36:59,274 --> 00:37:02,775
which is only supported with
the experimental daemon.

785
00:37:02,775 --> 00:37:05,272
With this version, it was
an experimental feature.

786
00:37:05,272 --> 00:37:08,653
So that might or might
not have worked for you.

787
00:37:08,653 --> 00:37:10,074
We could do things a bit manually.

788
00:37:10,074 --> 00:37:11,593
I can see from here

789
00:37:11,593 --> 00:37:13,760
that the production webapp

790
00:37:15,193 --> 00:37:18,580
is running on this instance
here, which is the one

791
00:37:18,580 --> 00:37:22,663
with the Amazon private
IP address ending in 188.

792
00:37:24,126 --> 00:37:27,946
I can identify that from my consoles here.

793
00:37:27,946 --> 00:37:30,424
Yeah, it's this one here,
the private IP there

794
00:37:30,424 --> 00:37:33,951
ending 188, and it is
the private IP address

795
00:37:33,951 --> 00:37:35,170
you're looking for there.

796
00:37:35,170 --> 00:37:38,291
But I can tell from the
title bar on this console

797
00:37:38,291 --> 00:37:41,056
that this is the corresponding terminal,

798
00:37:41,056 --> 00:37:45,223
and a docker container ls
would confirm that on here

799
00:37:46,594 --> 00:37:50,763
I have the queue and
the production webapp.

800
00:37:50,763 --> 00:37:54,143
So the webapp's on this
container beginning a0.

801
00:37:54,143 --> 00:37:56,726
So docker container logs -f a0.

802
00:38:00,799 --> 00:38:01,997
It looks like I've been quick enough

803
00:38:01,997 --> 00:38:04,765
to just catch it while
it's still starting.

804
00:38:04,765 --> 00:38:08,105
It was just going through
the hibernate stuff there,

805
00:38:08,105 --> 00:38:11,470
and it's finally, by the look of it,

806
00:38:11,470 --> 00:38:12,790
it's finally started.

807
00:38:12,790 --> 00:38:15,537
It took about 53 seconds for
me, just to give you an idea

808
00:38:15,537 --> 00:38:18,320
of the kind of timings
that you're going to see

809
00:38:18,320 --> 00:38:21,737
on these quite low-powered EC2 instances.

810
00:38:22,678 --> 00:38:26,789
So, it looks like our
webapp is up and running,

811
00:38:26,789 --> 00:38:29,239
and we have a stack,

812
00:38:29,239 --> 00:38:31,235
which looks very satisfying.

813
00:38:31,235 --> 00:38:32,926
Now, remember to visit the application.

814
00:38:32,926 --> 00:38:35,691
We can use any of the IP addresses,

815
00:38:35,691 --> 00:38:38,861
the public IP addresses,
for these instances.

816
00:38:38,861 --> 00:38:40,129
Pick one at random.

817
00:38:40,129 --> 00:38:43,790
I'm going to go for this instance here,

818
00:38:43,790 --> 00:38:46,198
the one ending .54.

819
00:38:46,198 --> 00:38:49,279
Remember, we have the Docker routing mesh,

820
00:38:49,279 --> 00:38:52,214
which will find whatever
instance is running,

821
00:38:52,214 --> 00:38:54,294
the particular service we're looking for.

822
00:38:54,294 --> 00:38:56,998
Now, to test all of this
is up and running okay,

823
00:38:56,998 --> 00:39:00,826
I'm going to start 8010,
which is the registry.

824
00:39:00,826 --> 00:39:03,916
This is Eureka, and this looks fantastic.

825
00:39:03,916 --> 00:39:07,119
I have my instances correctly registered.

826
00:39:07,119 --> 00:39:09,126
Now, just to mention,

827
00:39:09,126 --> 00:39:11,044
this will become relevant
in the next chapter,

828
00:39:11,044 --> 00:39:14,089
if I hover over the position tracker,

829
00:39:14,089 --> 00:39:16,520
the port, it's not easy to see,

830
00:39:16,520 --> 00:39:18,114
but I'll zoom in there.

831
00:39:18,114 --> 00:39:21,989
The port, we're using
random ports in this system

832
00:39:21,989 --> 00:39:23,486
for all the microservices.

833
00:39:23,486 --> 00:39:26,569
So at random, it's chosen port 41439.

834
00:39:28,135 --> 00:39:30,400
That's one of the great
things about Eureka.

835
00:39:30,400 --> 00:39:33,381
It doesn't matter what ports
the services are running on.

836
00:39:33,381 --> 00:39:36,368
They will be captured and
stored in the registry.

837
00:39:36,368 --> 00:39:37,757
More on that later.

838
00:39:37,757 --> 00:39:39,967
But that's looking healthy.

839
00:39:39,967 --> 00:39:42,467
We could also to go port 8161.

840
00:39:45,802 --> 00:39:48,729
Now, I haven't bothered securing this.

841
00:39:48,729 --> 00:39:50,387
In real life, I would actually,

842
00:39:50,387 --> 00:39:53,294
I probably wouldn't
even publish the ports,

843
00:39:53,294 --> 00:39:56,586
but it's admin, admin,
in case you don't know,

844
00:39:56,586 --> 00:39:58,944
and we can look at the queues.

845
00:39:58,944 --> 00:40:01,501
And this looks very healthy,
because if I refresh,

846
00:40:01,501 --> 00:40:05,184
I can see there are
messages being enqueued,

847
00:40:05,184 --> 00:40:09,017
and there are messages
being dequeued as well.

848
00:40:10,748 --> 00:40:12,164
That's looking nice.

849
00:40:12,164 --> 00:40:13,602
But I'm putting off the inevitable.

850
00:40:13,602 --> 00:40:17,269
If I remove all the
ports on the IP address,

851
00:40:18,603 --> 00:40:22,745
I'm visiting the real
live running application.

852
00:40:22,745 --> 00:40:25,446
You probably had a sense
from the previous chapters

853
00:40:25,446 --> 00:40:28,201
that we've put some kind of
web socket system on here

854
00:40:28,201 --> 00:40:31,688
so that the positions
will automatically update.

855
00:40:31,688 --> 00:40:34,126
Now, we're not graphical
user interface developers,

856
00:40:34,126 --> 00:40:37,989
so don't expect great things
from this user interface.

857
00:40:37,989 --> 00:40:41,715
You'll notice if you try to scroll around,

858
00:40:41,715 --> 00:40:43,060
it sort of won't let you.

859
00:40:43,060 --> 00:40:44,397
It'll keep bouncing back,

860
00:40:44,397 --> 00:40:47,129
and that's because you're able to follow

861
00:40:47,129 --> 00:40:50,379
a particular vehicle by simply clicking

862
00:40:51,227 --> 00:40:53,950
on the radio buttons for each vehicle,

863
00:40:53,950 --> 00:40:58,655
and it will animate and
centre on that vehicle.

864
00:40:58,655 --> 00:41:01,589
It's far from perfect, but
the thing we want to see

865
00:41:01,589 --> 00:41:06,474
is that these vehicles are
receiving live reports.

866
00:41:06,474 --> 00:41:08,497
So I could play around
with this for hours,

867
00:41:08,497 --> 00:41:10,032
but the pubs are opening,

868
00:41:10,032 --> 00:41:13,394
so we'll start to draw
this chapter to a close.

869
00:41:13,394 --> 00:41:14,983
But there's always one thing I want to do

870
00:41:14,983 --> 00:41:16,161
when I've got something working,

871
00:41:16,161 --> 00:41:18,892
and that's, I want to break it.

872
00:41:18,892 --> 00:41:22,126
And all good engineers
should want to break things.

873
00:41:22,126 --> 00:41:23,727
So, the natural question is,

874
00:41:23,727 --> 00:41:26,755
what happens if any of
these containers fail?

875
00:41:26,755 --> 00:41:28,018
I'm watching this vehicle here

876
00:41:28,018 --> 00:41:30,863
at the moment, London,
Riverside, and it's moving...

877
00:41:30,863 --> 00:41:33,449
None of the vehicles move
particularly quickly,

878
00:41:33,449 --> 00:41:36,454
but I can see from the pane here

879
00:41:36,454 --> 00:41:40,661
that we are seeing updates coming through.

880
00:41:40,661 --> 00:41:42,418
Maybe about once a second,

881
00:41:42,418 --> 00:41:45,800
we can see a vehicle updating itself.

882
00:41:45,800 --> 00:41:48,578
Let's take something down.

883
00:41:48,578 --> 00:41:51,511
We have the queue, for example.

884
00:41:51,511 --> 00:41:53,968
This is running on this instance,

885
00:41:53,968 --> 00:41:58,122
which, for me, is the IP address ending,

886
00:41:58,122 --> 00:42:01,313
the private IP address ending 179,

887
00:42:01,313 --> 00:42:04,493
and I can find the
corresponding terminal window

888
00:42:04,493 --> 00:42:06,060
from the titles on the terminals.

889
00:42:06,060 --> 00:42:08,147
It happens to be this one.

890
00:42:08,147 --> 00:42:10,285
So exactly as we did in
the previous chapter,

891
00:42:10,285 --> 00:42:13,083
I can do a docker container ls,

892
00:42:13,083 --> 00:42:14,398
and it's not that easy to read,

893
00:42:14,398 --> 00:42:17,130
because I don't have a lot
of space on this screen.

894
00:42:17,130 --> 00:42:19,257
But I've got, on this particular node,

895
00:42:19,257 --> 00:42:21,808
I've got the position tracker,

896
00:42:21,808 --> 00:42:25,078
the queue, and the visualizer.

897
00:42:25,078 --> 00:42:28,139
So it's the queue that I want to target.

898
00:42:28,139 --> 00:42:30,157
Let's be horrible.

899
00:42:30,157 --> 00:42:33,593
We'll start actually
with a docker service ls

900
00:42:33,593 --> 00:42:36,224
so that we can see all our
services are up and running

901
00:42:36,224 --> 00:42:40,747
with one replica out of one
running for all of them.

902
00:42:40,747 --> 00:42:42,323
But I wanna be nasty now.

903
00:42:42,323 --> 00:42:43,258
Let's do a kill.

904
00:42:43,258 --> 00:42:45,094
Docker container kill,

905
00:42:45,094 --> 00:42:46,594
and this one here.

906
00:42:47,505 --> 00:42:50,775
For me, it's the container beginning b0.

907
00:42:50,775 --> 00:42:52,921
I love doing this.

908
00:42:52,921 --> 00:42:54,343
It's hard to fit all of this in,

909
00:42:54,343 --> 00:42:57,861
but I've got the web application
here and the visualizer

910
00:42:57,861 --> 00:42:58,915
next to each other.

911
00:42:58,915 --> 00:43:01,458
I haven't killed that container yet.

912
00:43:01,458 --> 00:43:02,364
I'm going to run that command,

913
00:43:02,364 --> 00:43:06,733
and then very quickly,
switch to the visualizer.

914
00:43:06,733 --> 00:43:08,900
So there's the visualizer.

915
00:43:10,369 --> 00:43:12,799
And yeah, we've lost one of the containers

916
00:43:12,799 --> 00:43:15,042
and, well, it was so quick actually.

917
00:43:15,042 --> 00:43:18,201
Now, can you see that
the updates have stopped?

918
00:43:18,201 --> 00:43:20,130
Clearly once the queue's gone down,

919
00:43:20,130 --> 00:43:22,064
nothing's going to happen.

920
00:43:22,064 --> 00:43:24,371
Well, clearly, once the queue's down,

921
00:43:24,371 --> 00:43:26,222
there will be no messages coming through.

922
00:43:26,222 --> 00:43:29,626
But as soon as the
queue's restarted again,

923
00:43:29,626 --> 00:43:33,251
then our microservices are back
up and running and consuming

924
00:43:33,251 --> 00:43:36,656
from that queue, and the
vehicle is moving again,

925
00:43:36,656 --> 00:43:39,369
and it was as seamless as that.

926
00:43:39,369 --> 00:43:40,768
That shouldn't be a surprise to you

927
00:43:40,768 --> 00:43:42,548
if you did the microservice course,

928
00:43:42,548 --> 00:43:45,807
because we designed the
system to do just that.

929
00:43:45,807 --> 00:43:47,513
Feel free to experiment with this.

930
00:43:47,513 --> 00:43:48,879
You could even kill,

931
00:43:48,879 --> 00:43:51,317
you could even stop an entire instance

932
00:43:51,317 --> 00:43:53,926
and check that the
containers are restarted

933
00:43:53,926 --> 00:43:57,169
and rebalanced across
the rest of the swarm.

934
00:43:57,169 --> 00:43:59,865
If you do do that, one
thing to be careful of is,

935
00:43:59,865 --> 00:44:02,800
make sure whichever IP
address you're using

936
00:44:02,800 --> 00:44:05,913
in your browser, you
don't kill that instance.

937
00:44:05,913 --> 00:44:08,780
Otherwise, of course, then
nothing's going to work.

938
00:44:08,780 --> 00:44:11,009
That's one reason, by the
way, why you would probably

939
00:44:11,009 --> 00:44:14,650
still have something like
an elastic load balancer

940
00:44:14,650 --> 00:44:18,468
in front of all of this,
so your entire architecture

941
00:44:18,468 --> 00:44:21,863
doesn't depend on one
particular IP address.

942
00:44:21,863 --> 00:44:23,464
I'm not going to play
with this any further,

943
00:44:23,464 --> 00:44:26,409
because we've still more to
come in the next chapter,

944
00:44:26,409 --> 00:44:28,857
and we have something suspicious.

945
00:44:28,857 --> 00:44:31,789
We just ported across here
the entire architecture

946
00:44:31,789 --> 00:44:35,837
from our previous
course, including Eureka,

947
00:44:35,837 --> 00:44:38,639
which, as you know, comes
from the Netflix project

948
00:44:38,639 --> 00:44:41,487
that has been absorbed into Spring,

949
00:44:41,487 --> 00:44:44,197
and it doing it's job perfectly well.

950
00:44:44,197 --> 00:44:47,512
We have a registry of services
here, but there's something

951
00:44:47,512 --> 00:44:50,186
a bit suspicious about this whole thing.

952
00:44:50,186 --> 00:44:52,958
Do we really need Eureka?

953
00:44:52,958 --> 00:44:56,958
Well, we'll talk about
that in the next chapter.

1
00:00:00,400 --> 00:00:01,990
- [Instructor] Apart
from the summary chapter,

2
00:00:01,990 --> 00:00:05,176
this is the final chapter of the course.

3
00:00:05,176 --> 00:00:08,975
And in this chapter, I want to talk about

4
00:00:08,975 --> 00:00:10,975
is Eureka really needed?

5
00:00:12,123 --> 00:00:15,203
So, previously, we finally got proper

6
00:00:15,203 --> 00:00:17,945
microservice architecture up and running.

7
00:00:17,945 --> 00:00:20,431
It's a small architecture, for sure.

8
00:00:20,431 --> 00:00:22,113
But we could easily go ahead now

9
00:00:22,113 --> 00:00:26,194
and add further containers
at further services

10
00:00:26,194 --> 00:00:30,413
because we've got all of
the infrastructure laid out.

11
00:00:30,413 --> 00:00:34,004
We've been using the Netflix stack.

12
00:00:34,004 --> 00:00:36,256
And we've used that since the very first

13
00:00:36,256 --> 00:00:38,474
course I did on microservices,

14
00:00:38,474 --> 00:00:40,938
which is now quite a long time ago.

15
00:00:40,938 --> 00:00:42,906
And it's been working well.

16
00:00:42,906 --> 00:00:45,257
For example, we have Eureka.

17
00:00:45,257 --> 00:00:47,367
And Eureka's a service registry.

18
00:00:47,367 --> 00:00:50,537
So when the position tracker, for example,

19
00:00:50,537 --> 00:00:52,217
starts up and running,

20
00:00:52,217 --> 00:00:54,896
it registers itself with Eureka

21
00:00:54,896 --> 00:00:57,762
and as always, I have to hover here

22
00:00:57,762 --> 00:01:00,486
and zoom in on the fact that

23
00:01:00,486 --> 00:01:01,995
the position tracker happens to be

24
00:01:01,995 --> 00:01:05,662
located at the private
IP address 172.28.0.7

25
00:01:07,232 --> 00:01:10,565
and it's running randomly on port 35441.

26
00:01:11,875 --> 00:01:13,756
And Eureka knows that,

27
00:01:13,756 --> 00:01:15,895
and Eureka's publishing that to

28
00:01:15,895 --> 00:01:18,464
all of the other
microservices in our system.

29
00:01:18,464 --> 00:01:19,874
It works well.

30
00:01:19,874 --> 00:01:22,324
It's a big complicated
to get up and running,

31
00:01:22,324 --> 00:01:25,895
as anyone who's done my
microservice courses will know,

32
00:01:25,895 --> 00:01:28,425
Eureka can be a bit of a pain in the neck.

33
00:01:28,425 --> 00:01:31,517
But once it's running, it does work well.

34
00:01:31,517 --> 00:01:33,406
But I don't think you've spotted,

35
00:01:33,406 --> 00:01:35,484
that now we've moved across the docker,

36
00:01:35,484 --> 00:01:38,015
we might not even need Eureka anymore.

37
00:01:38,015 --> 00:01:39,676
And the reason for that is in Docker,

38
00:01:39,676 --> 00:01:43,896
we have a perfectly good
registry already built in.

39
00:01:43,896 --> 00:01:45,716
And that's because the DNS features

40
00:01:45,716 --> 00:01:48,905
that we've been using really
throughout this course,

41
00:01:48,905 --> 00:01:52,124
form a discovery service, or a registry.

42
00:01:52,124 --> 00:01:55,866
For example, here's a
swarm with multiple nodes

43
00:01:55,866 --> 00:01:59,056
and on each node we have some containers.

44
00:01:59,056 --> 00:02:03,015
So, if we start a container,
which we give the name webapp,

45
00:02:03,015 --> 00:02:06,315
automatically in a DNS service,

46
00:02:06,315 --> 00:02:08,756
we'll get the entry webapp with its

47
00:02:08,756 --> 00:02:11,324
corresponding IP address.

48
00:02:11,324 --> 00:02:12,935
That should be a private IP address

49
00:02:12,935 --> 00:02:14,595
rather than the ones I'm using here,

50
00:02:14,595 --> 00:02:15,765
but that's fine.

51
00:02:15,765 --> 00:02:18,215
And because we're working
on that overlaying network,

52
00:02:18,215 --> 00:02:22,382
these DNS entries are distributed
across the entire swarm,

53
00:02:23,326 --> 00:02:25,645
so it doesn't matter which node we're on,

54
00:02:25,645 --> 00:02:27,015
we can at anytime we like,

55
00:02:27,015 --> 00:02:30,765
make a request on webapp call on 8080

56
00:02:30,765 --> 00:02:32,453
and we'll get a response back

57
00:02:32,453 --> 00:02:35,354
regardless of where we are in the swarm.

58
00:02:35,354 --> 00:02:36,474
And if you think about it,

59
00:02:36,474 --> 00:02:39,635
that's pretty much what
Eureka has been doing for us.

60
00:02:39,635 --> 00:02:41,135
So, although Eureka has been doing

61
00:02:41,135 --> 00:02:43,302
a great job for us up until now,

62
00:02:43,302 --> 00:02:47,965
we can, if you want, remove
Eureka from the system.

63
00:02:47,965 --> 00:02:50,975
And with a few tweaks, a
few tunings here and there,

64
00:02:50,975 --> 00:02:54,876
everything will still work
as well as it did before.

65
00:02:54,876 --> 00:02:56,745
So you might be wondering
why did I show you

66
00:02:56,745 --> 00:02:59,076
Eureka in the first place.

67
00:02:59,076 --> 00:03:00,513
And the answer is simply that,

68
00:03:00,513 --> 00:03:03,206
at the time that I recorded the original

69
00:03:03,206 --> 00:03:05,804
spring boot microservices course,

70
00:03:05,804 --> 00:03:08,355
Docker didn't have these features.

71
00:03:08,355 --> 00:03:11,604
Eureka was the best choice
available at the time

72
00:03:11,604 --> 00:03:14,494
but it's arguable, just arguable,

73
00:03:14,494 --> 00:03:18,574
that today, the docker
overlaying networking

74
00:03:18,574 --> 00:03:20,741
has made Eureka redundant.

75
00:03:22,133 --> 00:03:25,035
Now there are a couple of
features that Eureka offers.

76
00:03:25,035 --> 00:03:28,243
Not least the fact that
it has this console

77
00:03:28,243 --> 00:03:30,733
which you could find very useful.

78
00:03:30,733 --> 00:03:33,035
I mean, we have the visualizer,
and so on in Docker,

79
00:03:33,035 --> 00:03:36,087
but this is one good
way of kind of tracking

80
00:03:36,087 --> 00:03:37,754
the health of the system and seeing

81
00:03:37,754 --> 00:03:40,076
what's currently up and running.

82
00:03:40,076 --> 00:03:43,216
That's possibly a minor
reason to use Eureka.

83
00:03:43,216 --> 00:03:45,578
Another reason that you might
like is when using Eureka,

84
00:03:45,578 --> 00:03:49,174
we can use random ports
and you can see that here.

85
00:03:49,174 --> 00:03:52,097
We're running randomly on port 35441

86
00:03:52,097 --> 00:03:54,274
and when we redeploy this container,

87
00:03:54,274 --> 00:03:55,865
that position tracker will run

88
00:03:55,865 --> 00:03:57,496
under a completely different port

89
00:03:57,496 --> 00:03:59,246
and we just don't care about that

90
00:03:59,246 --> 00:04:02,627
because Docker's discovery
service is using DNS,

91
00:04:02,627 --> 00:04:05,295
but we can't start ports in DNS.

92
00:04:05,295 --> 00:04:07,178
So whenever we make a call to a service,

93
00:04:07,178 --> 00:04:10,888
we need to know what port
that service is running on.

94
00:04:10,888 --> 00:04:12,376
So if you're going to go down the route

95
00:04:12,376 --> 00:04:15,466
in just using Docker's discovery service,

96
00:04:15,466 --> 00:04:18,638
then you have to decide
on a standardised port

97
00:04:18,638 --> 00:04:21,067
for all of your microservices.

98
00:04:21,067 --> 00:04:22,606
So here at Virtual Pair Programmers,

99
00:04:22,606 --> 00:04:26,866
we always just use port
8080 for every microservice.

100
00:04:26,866 --> 00:04:28,468
Now don't forget it's absolutely fine

101
00:04:28,468 --> 00:04:30,268
for you to have multiple containers

102
00:04:30,268 --> 00:04:32,967
all running on port 8080.

103
00:04:32,967 --> 00:04:36,636
It's just that you can't publish
multiple ports on port 8080

104
00:04:36,636 --> 00:04:38,215
but that's fine, we don't want to publish

105
00:04:38,215 --> 00:04:40,132
the microservice ports.

106
00:04:41,177 --> 00:04:42,998
The only other downside
that I can think of

107
00:04:42,998 --> 00:04:47,137
of using the Docker
discovery instead of Eureka,

108
00:04:47,137 --> 00:04:49,073
is that of course to
make all of this work,

109
00:04:49,073 --> 00:04:52,097
you have to have Docker running.

110
00:04:52,097 --> 00:04:54,845
You wouldn't be able
to take these projects

111
00:04:54,845 --> 00:04:57,276
that resulted in these containers,

112
00:04:57,276 --> 00:05:00,117
and run them easily outside of Docker.

113
00:05:00,117 --> 00:05:02,985
Because this is going to be no registry so

114
00:05:02,985 --> 00:05:05,147
if you've wanted to run
your entire microservice

115
00:05:05,147 --> 00:05:08,294
architecture locally, which
is all a portion of it

116
00:05:08,294 --> 00:05:11,106
which is certainly very common,

117
00:05:11,106 --> 00:05:14,307
you would have to run it under Docker.

118
00:05:14,307 --> 00:05:17,088
Otherwise, you would have
no discovery service.

119
00:05:17,088 --> 00:05:18,708
Now when we're working with Eureka,

120
00:05:18,708 --> 00:05:21,725
we can stand up a local
instance of Eureka.

121
00:05:21,725 --> 00:05:24,791
And then attach all of
our microservices to it.

122
00:05:24,791 --> 00:05:26,131
And that works well.

123
00:05:26,131 --> 00:05:27,362
With this approach,

124
00:05:27,362 --> 00:05:30,014
if you wanted to run a significant

125
00:05:30,014 --> 00:05:31,065
part of the architecture,

126
00:05:31,065 --> 00:05:33,415
then you would have to run through Docker.

127
00:05:33,415 --> 00:05:35,284
I don't see that as a serious drawback

128
00:05:35,284 --> 00:05:38,344
because we've got tools
just as Docker compose

129
00:05:38,344 --> 00:05:40,573
to enable us to run multiple containers

130
00:05:40,573 --> 00:05:42,205
with a single command.

131
00:05:42,205 --> 00:05:43,894
And back here in the
workspace that contains

132
00:05:43,894 --> 00:05:46,854
all of those projects
that are using Eureka,

133
00:05:46,854 --> 00:05:48,338
I'm not going to make any changes here

134
00:05:48,338 --> 00:05:50,962
because this is a code that
I will be shipping to you.

135
00:05:50,962 --> 00:05:53,135
But, I'll just, very quickly,

136
00:05:53,135 --> 00:05:55,053
run down the changes
you would need to make

137
00:05:55,053 --> 00:05:58,865
to remove Eureka and pretty simple really.

138
00:05:58,865 --> 00:06:00,456
Let's start with a position tracker

139
00:06:00,456 --> 00:06:02,574
as a good working example.

140
00:06:02,574 --> 00:06:04,003
If we go into the main class,

141
00:06:04,003 --> 00:06:06,484
the main spring boot application class,

142
00:06:06,484 --> 00:06:09,224
you might remember, it's a long time ago,

143
00:06:09,224 --> 00:06:13,816
you put on the annotation
at enable discovery client.

144
00:06:13,816 --> 00:06:15,894
And that's what enables this application

145
00:06:15,894 --> 00:06:18,405
to register itself with Eureka.

146
00:06:18,405 --> 00:06:21,864
Well, you would just
delete that annotation.

147
00:06:21,864 --> 00:06:23,454
Pretty much as simple as that.

148
00:06:23,454 --> 00:06:26,393
And then it would no
longer be using Eureka.

149
00:06:26,393 --> 00:06:29,392
You would also, in your pom,

150
00:06:29,392 --> 00:06:32,892
you would want to remove the dependency on

151
00:06:33,903 --> 00:06:37,153
spring cloud starter Eureka, that's it.

152
00:06:38,794 --> 00:06:41,032
If we go into the web application,

153
00:06:41,032 --> 00:06:43,032
you might also remember,

154
00:06:43,988 --> 00:06:45,516
if we look in the pom,

155
00:06:45,516 --> 00:06:48,516
there is a dependency called Ribbon.

156
00:06:49,410 --> 00:06:51,500
Now if you're struggling to
remember what that's all about,

157
00:06:51,500 --> 00:06:53,532
then just check out the previous course.

158
00:06:53,532 --> 00:06:56,460
Ribbon is a client-side load balancer,

159
00:06:56,460 --> 00:06:59,131
again, provided by Netflix.

160
00:06:59,131 --> 00:07:01,503
I realise I'm throwing a lot
of information at you here

161
00:07:01,503 --> 00:07:04,521
and we really have used
a lot of different tools

162
00:07:04,521 --> 00:07:05,961
to make this system work.

163
00:07:05,961 --> 00:07:08,060
Ribbon kind of seems to be the one

164
00:07:08,060 --> 00:07:10,152
that gets forgotten most of all

165
00:07:10,152 --> 00:07:12,545
because Ribbon's sort of been working

166
00:07:12,545 --> 00:07:14,007
in the background all the time

167
00:07:14,007 --> 00:07:16,353
we've been running this system.

168
00:07:16,353 --> 00:07:18,182
What Netflix Ribbon gives you

169
00:07:18,182 --> 00:07:21,601
is load balancing, but load balancing

170
00:07:21,601 --> 00:07:23,989
inside your application.

171
00:07:23,989 --> 00:07:25,212
Now what I mean by that is,

172
00:07:25,212 --> 00:07:29,032
imagine you have a microservice
like our position tracker

173
00:07:29,032 --> 00:07:32,340
and you decide to deploy
two instances of it.

174
00:07:32,340 --> 00:07:35,310
All you have to do is
launch the second instance,

175
00:07:35,310 --> 00:07:38,249
and that's going to get
picked up by Eureka.

176
00:07:38,249 --> 00:07:42,328
So Eureka knows you have two
instances of this microservice.

177
00:07:42,328 --> 00:07:45,762
Now when a client follows it's
usually being the web app,

178
00:07:45,762 --> 00:07:48,940
makes a call to that microservice,

179
00:07:48,940 --> 00:07:51,351
this layer of software
called Netflix Ribbon

180
00:07:51,351 --> 00:07:53,964
has been balancing those requests

181
00:07:53,964 --> 00:07:56,092
between the two instances.

182
00:07:56,092 --> 00:07:57,552
So it means you can very easily,

183
00:07:57,552 --> 00:08:00,752
if you have a microservice
that's very overloaded,

184
00:08:00,752 --> 00:08:03,714
you can very easily fire
up a new instance of it.

185
00:08:03,714 --> 00:08:06,886
And then automatically
Eureka combined with Ribbon,

186
00:08:06,886 --> 00:08:09,756
combined together to give this very neat

187
00:08:09,756 --> 00:08:12,165
client-side load balancing.

188
00:08:12,165 --> 00:08:15,243
I'm afraid it's the same story for Ribbon.

189
00:08:15,243 --> 00:08:19,616
It's not needed anymore
when you're using Docker.

190
00:08:19,616 --> 00:08:22,033
And again, it's only
because this is a relatively

191
00:08:22,033 --> 00:08:24,254
new feature in Docker vert,

192
00:08:24,254 --> 00:08:26,492
we have used Ribbon in the past.

193
00:08:26,492 --> 00:08:30,602
In Docker, we have the
concept of DNS Round Robin.

194
00:08:30,602 --> 00:08:32,269
If we're using Docker networking,

195
00:08:32,269 --> 00:08:34,802
then the web app is just
going to make a call to,

196
00:08:34,802 --> 00:08:37,162
whatever the name of the microservice is.

197
00:08:37,162 --> 00:08:40,543
Call on whatever the name of its port is.

198
00:08:40,543 --> 00:08:42,522
You've seen from the previous chapters,

199
00:08:42,522 --> 00:08:46,392
that we can launch
replicas of that service

200
00:08:46,392 --> 00:08:49,093
using those simple deploy types.

201
00:08:49,093 --> 00:08:53,221
Well exactly the same thing
happens here for free in Docker.

202
00:08:53,221 --> 00:08:56,600
If we have a replica, then the DNS service

203
00:08:56,600 --> 00:09:00,391
is going to randomly
choose one of the instances

204
00:09:00,391 --> 00:09:04,058
of the replica set each
time we make a call.

205
00:09:05,154 --> 00:09:08,851
So for my money, that
makes Ribbon redundant

206
00:09:08,851 --> 00:09:10,590
if you're using Docker.

207
00:09:10,590 --> 00:09:12,842
Now there are no app special
limitations for Ribbon,

208
00:09:12,842 --> 00:09:15,484
it's just declared as a
dependency in your project,

209
00:09:15,484 --> 00:09:18,610
so you can just simply remove it.

210
00:09:18,610 --> 00:09:20,920
Now I'm not saying we're going
to get rid of everything.

211
00:09:20,920 --> 00:09:23,468
We are going to retain Hystrix.

212
00:09:23,468 --> 00:09:24,951
I'll be demonstrating in a moment that

213
00:09:24,951 --> 00:09:27,339
that still works perfectly fine

214
00:09:27,339 --> 00:09:30,399
without Eureka and Ribbon being present.

215
00:09:30,399 --> 00:09:33,641
And another brilliant tool
from Netflix is feign,

216
00:09:33,641 --> 00:09:36,519
which enables us to make rest calls

217
00:09:36,519 --> 00:09:39,121
without even thinking about rest.

218
00:09:39,121 --> 00:09:42,560
We just call the other services
as if they're local objects

219
00:09:42,560 --> 00:09:44,039
and that's fantastic.

220
00:09:44,039 --> 00:09:48,008
We're also going to continue
to use the cloud config,

221
00:09:48,008 --> 00:09:50,719
which we've been using to
store global variables.

222
00:09:50,719 --> 00:09:53,305
Now you can store config in Docker,

223
00:09:53,305 --> 00:09:55,628
and that's on my to-do list to look up.

224
00:09:55,628 --> 00:09:58,068
For now, I'm very happy
with spring cloud config

225
00:09:58,068 --> 00:09:59,511
so I'm going to continue with it.

226
00:09:59,511 --> 00:10:02,390
But I suspect very soon
I'll be able to report

227
00:10:02,390 --> 00:10:05,179
that we could remove that as well.

228
00:10:05,179 --> 00:10:06,127
So if you wanted to,

229
00:10:06,127 --> 00:10:08,169
the first job to remove
Eureka from your system

230
00:10:08,169 --> 00:10:10,546
would be to remove those dependencies.

231
00:10:10,546 --> 00:10:13,478
But there is one serious job to do.

232
00:10:13,478 --> 00:10:15,950
And here in the web app

233
00:10:15,950 --> 00:10:17,050
and if we have a look at the point

234
00:10:17,050 --> 00:10:20,580
where we're making a call
to another microservice,

235
00:10:20,580 --> 00:10:22,048
we have a class here called

236
00:10:22,048 --> 00:10:25,308
remote position microservice calls.

237
00:10:25,308 --> 00:10:26,417
It's actually an interface.

238
00:10:26,417 --> 00:10:28,318
Now this is the feign client.

239
00:10:28,318 --> 00:10:29,830
Now this is how we define

240
00:10:29,830 --> 00:10:31,587
that we're going to be making calls

241
00:10:31,587 --> 00:10:34,436
to a remote microservice.

242
00:10:34,436 --> 00:10:36,570
Feign brilliantly converts this

243
00:10:36,570 --> 00:10:40,099
into a regular HTTP request
but as you can see here,

244
00:10:40,099 --> 00:10:43,289
it looks pretty much
like a regular method.

245
00:10:43,289 --> 00:10:47,777
Now here's the really
key piece of information.

246
00:10:47,777 --> 00:10:51,328
Up until now, we've been supplying a name.

247
00:10:51,328 --> 00:10:54,969
And that name has been
the name of the service

248
00:10:54,969 --> 00:10:56,969
as registered in Eureka.

249
00:10:57,990 --> 00:11:00,198
Now if we're going to remove Eureka,

250
00:11:00,198 --> 00:11:02,578
what on earth are we going to put on here?

251
00:11:02,578 --> 00:11:03,888
You still have to have a name

252
00:11:03,888 --> 00:11:06,108
but the name's actually
going to become redundant.

253
00:11:06,108 --> 00:11:07,110
You would simply,

254
00:11:07,110 --> 00:11:08,918
I'm not going to keep this change,

255
00:11:08,918 --> 00:11:11,388
I'm just doing this for demonstration,

256
00:11:11,388 --> 00:11:14,909
we can simply pass in the
parameter and see here,

257
00:11:14,909 --> 00:11:17,576
which is the URL of the service.

258
00:11:18,848 --> 00:11:21,138
And the URL of the service is going to be

259
00:11:21,138 --> 00:11:23,175
a regular HTTP URL,

260
00:11:23,175 --> 00:11:27,408
but you know now that we can
use the Docker DNS service.

261
00:11:27,408 --> 00:11:30,018
The name of this microservice,

262
00:11:30,018 --> 00:11:33,309
well it's actually
exactly the same as this,

263
00:11:33,309 --> 00:11:34,768
that's what we've been calling it in our

264
00:11:34,768 --> 00:11:37,229
Docker compose file; therefore,

265
00:11:37,229 --> 00:11:38,807
that's how it's going to be registered

266
00:11:38,807 --> 00:11:41,549
in the Docker DNS service.

267
00:11:41,549 --> 00:11:42,558
So we're just going to need

268
00:11:42,558 --> 00:11:44,725
fleetman-position tracker.

269
00:11:48,409 --> 00:11:51,881
The only problem is,
as I mentioned before,

270
00:11:51,881 --> 00:11:55,149
we need to know what port
that service is running on.

271
00:11:55,149 --> 00:11:57,610
We can't use random ports anymore.

272
00:11:57,610 --> 00:12:00,160
So, we would agree on a standard port

273
00:12:00,160 --> 00:12:03,871
for our microservices such as 8080.

274
00:12:03,871 --> 00:12:07,259
And that will be enough for
Docker to find that service

275
00:12:07,259 --> 00:12:11,171
with no need for Eureka to be present.

276
00:12:11,171 --> 00:12:14,310
So I realise that's really quite hard

277
00:12:14,310 --> 00:12:17,161
and I've thrown a lot
of information at you.

278
00:12:17,161 --> 00:12:19,579
I'm not going to plug through
making all of those changes

279
00:12:19,579 --> 00:12:23,179
because it would be the
world's most boring video.

280
00:12:23,179 --> 00:12:25,220
And I do a lot of those,
so for that reason,

281
00:12:25,220 --> 00:12:28,020
I've given you a folder and
practicals in code called

282
00:12:28,020 --> 00:12:30,397
Non-Netflix version.

283
00:12:30,397 --> 00:12:32,449
And inside there you'll
find a set of projects

284
00:12:32,449 --> 00:12:34,481
which contain all of the tweaks you need

285
00:12:34,481 --> 00:12:38,100
to remove Eureka and
Ribbon from the system.

286
00:12:38,100 --> 00:12:39,769
Feel free to take these for yourself,

287
00:12:39,769 --> 00:12:42,480
inspect them, read them,
tweak them, tune them,

288
00:12:42,480 --> 00:12:44,590
do whatever you want with them.

289
00:12:44,590 --> 00:12:48,798
So for example, if we look
in the fleetman web app,

290
00:12:48,798 --> 00:12:50,631
under src, main, java,

291
00:12:52,911 --> 00:12:56,543
remote position microservice calls,

292
00:12:56,543 --> 00:12:58,011
I'll just open it up and
it takes us into here

293
00:12:58,011 --> 00:13:01,092
and you can see that
I've made those changes.

294
00:13:01,092 --> 00:13:04,203
In fact, you don't need
the HTTP in front of it,

295
00:13:04,203 --> 00:13:07,773
but you do need the port
number that it's running on.

296
00:13:07,773 --> 00:13:09,671
I think it's worth looking at that.

297
00:13:09,671 --> 00:13:11,442
The service that we're calling there

298
00:13:11,442 --> 00:13:13,442
is the position tracker,

299
00:13:14,722 --> 00:13:18,139
and if we look in source, main resources,

300
00:13:19,324 --> 00:13:22,206
under applicationdocker.properties,

301
00:13:22,206 --> 00:13:24,334
I made a comment that we really do need

302
00:13:24,334 --> 00:13:26,273
to return to standard ports.

303
00:13:26,273 --> 00:13:28,206
So I fixed the port there.

304
00:13:28,206 --> 00:13:31,825
At 8080 previously, I had that at zero.

305
00:13:31,825 --> 00:13:33,886
Which spring boot in turn puts is,

306
00:13:33,886 --> 00:13:35,847
just use a random port.

307
00:13:35,847 --> 00:13:38,446
So just a few changes in there.

308
00:13:38,446 --> 00:13:42,613
And notice there's no fleetman
registry project anymore.

309
00:13:43,975 --> 00:13:45,658
I've thrown in the bin.

310
00:13:45,658 --> 00:13:49,498
Now I built an image from
each of these projects,

311
00:13:49,498 --> 00:13:51,608
and I've pushed them to Docker hub.

312
00:13:51,608 --> 00:13:54,743
But rather than creating
a repositories this time,

313
00:13:54,743 --> 00:13:59,239
if you look at fleetman
production for example,

314
00:13:59,239 --> 00:14:01,656
I've used the tag no-Netflix.

315
00:14:03,586 --> 00:14:06,526
So, microservice is the
version with Eureka,

316
00:14:06,526 --> 00:14:08,943
no-Netflix is without Eureka.

317
00:14:10,207 --> 00:14:12,676
So if you want to deploy
this to your stack,

318
00:14:12,676 --> 00:14:16,183
I've also provided a
dockercompose.yaml file

319
00:14:16,183 --> 00:14:19,033
and it's really very similar
to what we had before.

320
00:14:19,033 --> 00:14:22,712
I just switched the tags
on many of the images

321
00:14:22,712 --> 00:14:25,163
to the no-Netflix version.

322
00:14:25,163 --> 00:14:26,711
I don't need to bother for the queue

323
00:14:26,711 --> 00:14:29,145
because that doesn't care about Eureka.

324
00:14:29,145 --> 00:14:30,324
But everything else is using the

325
00:14:30,324 --> 00:14:32,553
alternate version apart from that.

326
00:14:32,553 --> 00:14:34,294
It's the same as before.

327
00:14:34,294 --> 00:14:37,364
Of course we've also removed
the fleetman registry

328
00:14:37,364 --> 00:14:39,048
from the list of services.

329
00:14:39,048 --> 00:14:43,066
It feels very good to
retire complicated services.

330
00:14:43,066 --> 00:14:45,240
I've still got a swarm running
from the previous chapter

331
00:14:45,240 --> 00:14:48,569
because I'm actually still in
the same recording session.

332
00:14:48,569 --> 00:14:52,697
So I think I'll just remove
the dockercompose.yaml file

333
00:14:52,697 --> 00:14:55,030
and put a new version of it,

334
00:14:57,637 --> 00:15:00,528
based on the new no-Netflix version.

335
00:15:00,528 --> 00:15:02,508
Now I could just redeploy this stack,

336
00:15:02,508 --> 00:15:05,479
but I'm concerned that's going to leave,

337
00:15:05,479 --> 00:15:08,118
for example, the registry still running.

338
00:15:08,118 --> 00:15:09,290
When you do a redeploy,

339
00:15:09,290 --> 00:15:12,123
it won't delete existing services.

340
00:15:13,055 --> 00:15:15,339
I guess that's the safety mechanism.

341
00:15:15,339 --> 00:15:16,999
So, it gives me a chance to give you

342
00:15:16,999 --> 00:15:20,308
what would possibly be
the final docker command

343
00:15:20,308 --> 00:15:22,537
on this series of courses.

344
00:15:22,537 --> 00:15:26,829
We can do a Docker stack
rm to take down a stack.

345
00:15:26,829 --> 00:15:29,829
So if I take down the fleetman stack

346
00:15:30,789 --> 00:15:32,076
and there it's gone.

347
00:15:32,076 --> 00:15:34,002
And we can confirm on
the visualizer there that

348
00:15:34,002 --> 00:15:36,134
yeah, that's pretty empty now.

349
00:15:36,134 --> 00:15:39,324
And now I recall my Docker
stack deploy command

350
00:15:39,324 --> 00:15:42,154
to deploy this new, much
lighter and simpler version

351
00:15:42,154 --> 00:15:43,404
with no Eureka.

352
00:15:45,135 --> 00:15:46,524
And here come my containers.

353
00:15:46,524 --> 00:15:47,983
So, we have queue.

354
00:15:47,983 --> 00:15:52,232
We have the production
version of the web app.

355
00:15:52,232 --> 00:15:54,702
We have the simulator,

356
00:15:54,702 --> 00:15:56,103
we have the tracker,

357
00:15:56,103 --> 00:15:58,044
and we have the global config server.

358
00:15:58,044 --> 00:16:00,315
There's no registry, but it does appear

359
00:16:00,315 --> 00:16:02,342
that all of the containers are running.

360
00:16:02,342 --> 00:16:03,856
That's looking good.

361
00:16:03,856 --> 00:16:06,923
Now of course whatever happens,

362
00:16:06,923 --> 00:16:08,756
if we visit port 8010,

363
00:16:10,036 --> 00:16:11,455
we're not going to get anything

364
00:16:11,455 --> 00:16:13,843
so we've lost the Eureka console now.

365
00:16:13,843 --> 00:16:16,555
Which I guess is, I think
find the Eureka console

366
00:16:16,555 --> 00:16:18,581
quite useful in production.

367
00:16:18,581 --> 00:16:21,052
But without it, we should find,

368
00:16:21,052 --> 00:16:22,664
this is the old version.

369
00:16:22,664 --> 00:16:24,497
And if I do a refresh,

370
00:16:26,246 --> 00:16:29,056
and yeah that's up and running healthily.

371
00:16:29,056 --> 00:16:30,655
You might notice this is a slight change

372
00:16:30,655 --> 00:16:33,745
to the user interface on this version.

373
00:16:33,745 --> 00:16:34,846
And that's because I've realised

374
00:16:34,846 --> 00:16:37,963
with this animated map view,

375
00:16:37,963 --> 00:16:40,544
it's actually very difficult to see.

376
00:16:40,544 --> 00:16:44,461
If the position tracking
microservices crashed.

377
00:16:45,426 --> 00:16:47,295
Because basically, if you do a refresh,

378
00:16:47,295 --> 00:16:50,615
you'll still get a map with
the last known position.

379
00:16:50,615 --> 00:16:52,554
What I mean by that is,
on the previous courses,

380
00:16:52,554 --> 00:16:56,275
we worked heavily with a wonderful layer

381
00:16:56,275 --> 00:16:59,333
of software from Netflix called Hystrix.

382
00:16:59,333 --> 00:17:01,244
And Hystrix gives you two things.

383
00:17:01,244 --> 00:17:03,603
It, first of all, gives
you a circuit breaker

384
00:17:03,603 --> 00:17:05,505
which is quite a complex
piece of software.

385
00:17:05,505 --> 00:17:08,813
Check out our microservice
course if you're interested.

386
00:17:08,813 --> 00:17:11,697
But the other thing it
gives you is a fallback

387
00:17:11,697 --> 00:17:13,795
in case a remote microservice

388
00:17:13,795 --> 00:17:16,195
that you're calling has failed.

389
00:17:16,195 --> 00:17:17,642
And just to remind you
if you've forgotten it,

390
00:17:17,642 --> 00:17:19,876
here's the method that we're calling

391
00:17:19,876 --> 00:17:22,604
whenever we get the position of a vehicle.

392
00:17:22,604 --> 00:17:25,874
And this is a remote rest call.

393
00:17:25,874 --> 00:17:27,703
But if that rest call fails,

394
00:17:27,703 --> 00:17:30,775
then this Hystrix command allows me

395
00:17:30,775 --> 00:17:33,384
to set a fallback method,

396
00:17:33,384 --> 00:17:35,713
which is a local method here.

397
00:17:35,713 --> 00:17:37,995
It doesn't use a network connection.

398
00:17:37,995 --> 00:17:40,991
And the strategy that we
defined on the previous course

399
00:17:40,991 --> 00:17:44,085
was, okay well if we
can't get the current,

400
00:17:44,085 --> 00:17:46,015
live up to date position,

401
00:17:46,015 --> 00:17:50,134
then we'll simply use our
own locally cached position

402
00:17:50,134 --> 00:17:53,053
that we're storing in a local database.

403
00:17:53,053 --> 00:17:54,784
Now the trouble is with this animated map,

404
00:17:54,784 --> 00:17:58,995
it's very difficult to
see Hystrix kicking in.

405
00:17:58,995 --> 00:18:01,494
So, I just modified things a
little bit for this version.

406
00:18:01,494 --> 00:18:04,912
I put links on all the vehicles.

407
00:18:04,912 --> 00:18:07,823
And you can follow any of these links.

408
00:18:07,823 --> 00:18:10,495
And it will give you a
static page of information

409
00:18:10,495 --> 00:18:12,245
for this vehicle.

410
00:18:12,245 --> 00:18:15,552
It will give you their latest
position that we know of.

411
00:18:15,552 --> 00:18:18,373
And the time of that position.

412
00:18:18,373 --> 00:18:19,893
So, I just picked a random one here.

413
00:18:19,893 --> 00:18:21,844
And if I do some refreshes,

414
00:18:21,844 --> 00:18:24,305
you do have to refresh this one.

415
00:18:24,305 --> 00:18:27,515
It won't animate but it will tell me,

416
00:18:27,515 --> 00:18:29,486
yeah, we're in live
contact with the vehicle,

417
00:18:29,486 --> 00:18:33,865
it was reported at this
particular time, and so on.

418
00:18:33,865 --> 00:18:36,745
I did that to demonstrate that
a frequently asked question

419
00:18:36,745 --> 00:18:38,426
that I had from the previous course was,

420
00:18:38,426 --> 00:18:40,516
hey I don't want to use Eureka

421
00:18:40,516 --> 00:18:42,585
but can I still use Hystrix?

422
00:18:42,585 --> 00:18:45,148
And the answer is absolutely
yes, no problem at all.

423
00:18:45,148 --> 00:18:48,467
We've left Hystrix in place
but we've taken Eureka out.

424
00:18:48,467 --> 00:18:50,736
On this final demo on the course,

425
00:18:50,736 --> 00:18:54,905
it's good to show you that
Hystrix works just fine.

426
00:18:54,905 --> 00:18:55,846
How can we demonstrate?

427
00:18:55,846 --> 00:18:58,537
Well if we use the visualizer again,

428
00:18:58,537 --> 00:19:02,120
we can see that the
position tracker for me

429
00:19:03,274 --> 00:19:04,777
is running on this instance here

430
00:19:04,777 --> 00:19:08,360
which has the private
IP addess ending 188.

431
00:19:10,036 --> 00:19:13,196
I can find the corresponding
console for that here.

432
00:19:13,196 --> 00:19:14,283
There are other ways of doing this,

433
00:19:14,283 --> 00:19:16,835
but this is the way I like to do it.

434
00:19:16,835 --> 00:19:18,326
So, we can do a Docker container ls

435
00:19:18,326 --> 00:19:20,567
and we do indeed have
those two containers,

436
00:19:20,567 --> 00:19:23,806
one of which is the position tracker.

437
00:19:23,806 --> 00:19:25,957
Now if that position tracker is down,

438
00:19:25,957 --> 00:19:29,186
then I would expect Hystrix to kick in.

439
00:19:29,186 --> 00:19:32,976
So, we'll do the old
Docker container kill,

440
00:19:32,976 --> 00:19:35,126
I love doing this.

441
00:19:35,126 --> 00:19:38,459
76, I'm going to need to be pretty quick

442
00:19:39,976 --> 00:19:42,138
because remember the
swarm is going to detect

443
00:19:42,138 --> 00:19:44,228
the container's gone away

444
00:19:44,228 --> 00:19:47,725
so it's going to start a new
instance of that service.

445
00:19:47,725 --> 00:19:50,596
But we should see some downtime.

446
00:19:50,596 --> 00:19:51,429
Let's go.

447
00:19:52,395 --> 00:19:53,404
Okay, back to the app.

448
00:19:53,404 --> 00:19:56,886
If I do a refresh now, aha fantastic.

449
00:19:56,886 --> 00:19:58,186
And I've tweaked things so that

450
00:19:58,186 --> 00:20:00,316
if the Hystrix fallback kicks in,

451
00:20:00,316 --> 00:20:02,397
we get this big div informing us

452
00:20:02,397 --> 00:20:04,957
that we're actually seeing now the last

453
00:20:04,957 --> 00:20:07,155
known position of this vehicle.

454
00:20:07,155 --> 00:20:09,587
And if I do a few refreshes,

455
00:20:09,587 --> 00:20:10,878
while I was talking quite a long time

456
00:20:10,878 --> 00:20:14,530
and in that time, the service
is sprung back to life.

457
00:20:14,530 --> 00:20:17,209
And I'm not getting live data.

458
00:20:17,209 --> 00:20:18,658
There is a better way of doing that.

459
00:20:18,658 --> 00:20:21,769
If I go back to the leader node,

460
00:20:21,769 --> 00:20:23,409
which I think is this one.

461
00:20:23,409 --> 00:20:27,337
I could just modify the dockercompose.yaml

462
00:20:27,337 --> 00:20:31,138
and find the position
tracker and you know now

463
00:20:31,138 --> 00:20:35,305
we can add a deploy tag and
I could do a replicas zero,

464
00:20:37,377 --> 00:20:39,349
which means when I next do an update,

465
00:20:39,349 --> 00:20:41,088
it's going to destroy this service.

466
00:20:41,088 --> 00:20:43,410
So, we'll redeploy that stack.

467
00:20:43,410 --> 00:20:44,648
Back to the visualizer,

468
00:20:44,648 --> 00:20:46,289
actually it's already,

469
00:20:46,289 --> 00:20:47,778
before I could even get here,

470
00:20:47,778 --> 00:20:50,210
it has now removed the position tracker

471
00:20:50,210 --> 00:20:54,419
from the stack which means we should now,

472
00:20:54,419 --> 00:20:55,968
yeah, and the important thing,

473
00:20:55,968 --> 00:20:58,709
we covered this in detail
on the microservice course.

474
00:20:58,709 --> 00:21:01,219
Important thing is web application's

475
00:21:01,219 --> 00:21:03,248
still performing perfectly well.

476
00:21:03,248 --> 00:21:05,306
If we hadn't used something like Hystrix,

477
00:21:05,306 --> 00:21:06,978
we'd now be seeing the really nasty

478
00:21:06,978 --> 00:21:10,228
HTTP 500 exception here, but we're not.

479
00:21:11,528 --> 00:21:12,484
It's simply saying,

480
00:21:12,484 --> 00:21:14,587
sorry I can't get this
information right now

481
00:21:14,587 --> 00:21:17,596
because part of the system is down.

482
00:21:17,596 --> 00:21:20,179
So that's basically gone stale.

483
00:21:21,574 --> 00:21:22,967
I can't bare to leave it like that.

484
00:21:22,967 --> 00:21:26,337
So, let's switch this to the one replica.

485
00:21:26,337 --> 00:21:27,947
By the way, you can have two instances

486
00:21:27,947 --> 00:21:30,223
of this position tracker
and as I've mentioned,

487
00:21:30,223 --> 00:21:31,747
you don't need Ribbon.

488
00:21:31,747 --> 00:21:33,839
Automatically, Docker
will now load-balance

489
00:21:33,839 --> 00:21:36,019
between those two replicas.

490
00:21:36,019 --> 00:21:37,888
The one reason I'm not
doing it on the demo

491
00:21:37,888 --> 00:21:40,161
is that I simply haven't designed

492
00:21:40,161 --> 00:21:42,930
that microservice to be replicated.

493
00:21:42,930 --> 00:21:45,899
What will happen is
you'll have two instances

494
00:21:45,899 --> 00:21:48,689
of the microservice
competing for each other

495
00:21:48,689 --> 00:21:50,778
to get positional reports.

496
00:21:50,778 --> 00:21:53,190
And the web app is going
cycle between them.

497
00:21:53,190 --> 00:21:55,248
So, if you do a refresh on the web app,

498
00:21:55,248 --> 00:21:58,689
you may find the vehicle's
going backwards and forwards.

499
00:21:58,689 --> 00:22:02,040
Depending on whether it's
getting an old or a new report.

500
00:22:02,040 --> 00:22:03,811
So I'm not going to bother
doing replicas here,

501
00:22:03,811 --> 00:22:06,780
but we have seen how easy it is to do.

502
00:22:06,780 --> 00:22:09,349
So for one final time on this course,

503
00:22:09,349 --> 00:22:11,340
we'll redeploy that stack

504
00:22:11,340 --> 00:22:12,829
straight back to the web app.

505
00:22:12,829 --> 00:22:15,241
I'll do plenty of refreshes so again,

506
00:22:15,241 --> 00:22:17,478
the last time this vehicle was seen

507
00:22:17,478 --> 00:22:19,478
was 1822 and 21 seconds,

508
00:22:21,879 --> 00:22:23,296
but I hope by now

509
00:22:24,979 --> 00:22:27,139
the microservice should be getting itself

510
00:22:27,139 --> 00:22:30,007
back up and running again.

511
00:22:30,007 --> 00:22:32,174
There we are, it's back up

512
00:22:33,199 --> 00:22:35,698
and we're now getting live data.

513
00:22:35,698 --> 00:22:36,789
Don't be too hasty with this.

514
00:22:36,789 --> 00:22:40,726
We get a new report about
every 10 seconds now.

515
00:22:40,726 --> 00:22:42,338
Five seconds in this case.

516
00:22:42,338 --> 00:22:45,778
So, you won't see an
update on every refresh.

517
00:22:45,778 --> 00:22:46,849
But you should see the phrase,

518
00:22:46,849 --> 00:22:49,999
we are in live contact with this vehicle.

519
00:22:49,999 --> 00:22:52,010
So that was quite hard work,

520
00:22:52,010 --> 00:22:53,760
but I hope I've
demonstrated that we can use

521
00:22:53,760 --> 00:22:57,420
Docker swarms without the need for

522
00:22:57,420 --> 00:23:00,259
fairly complex software such as Eureka

523
00:23:00,259 --> 00:23:02,529
to give us service registries

524
00:23:02,529 --> 00:23:05,350
because the DNS service
provided by Docker,

525
00:23:05,350 --> 00:23:09,709
gives us a great registry
service straight out of the box.

526
00:23:09,709 --> 00:23:11,320
In a future course,
I'm planning to look at

527
00:23:11,320 --> 00:23:14,777
orchestration systems such as Kubernetes

528
00:23:14,777 --> 00:23:17,198
which gives us a whole new layer

529
00:23:17,198 --> 00:23:19,758
of sophisticated
functionality on top of this,

530
00:23:19,758 --> 00:23:21,078
but I'll tell you what,

531
00:23:21,078 --> 00:23:25,418
even without things like
Kubernetes or Netflix Eureka,

532
00:23:25,418 --> 00:23:29,179
you have a pretty rich set
of orchestration routines

533
00:23:29,179 --> 00:23:31,519
right out of the box in Docker.

534
00:23:31,519 --> 00:23:33,150
So, I'm out of energy now.

535
00:23:33,150 --> 00:23:34,758
You probably are too.

536
00:23:34,758 --> 00:23:35,899
We just got one final chapter

537
00:23:35,899 --> 00:23:37,957
where I'll do a quick
review of the course.

538
00:23:37,957 --> 00:23:39,559
And I'll give you a few clues

539
00:23:39,559 --> 00:23:41,210
as to what's coming next from

540
00:23:41,210 --> 00:23:42,719
Virtual Pair Programmers.

541
00:23:42,719 --> 00:23:44,096
So, well done if you've got this far.

542
00:23:44,096 --> 00:23:45,468
I hope you like Docker,

543
00:23:45,468 --> 00:23:49,128
and the thing I hope I really
got across here is that,

544
00:23:49,128 --> 00:23:51,650
deploying this system was so simple,

545
00:23:51,650 --> 00:23:55,090
we've just done it with
a few commands really.

546
00:23:55,090 --> 00:23:56,808
Compared to how hard we had to work

547
00:23:56,808 --> 00:24:00,058
on the previous course, it was a dream.

1
00:00:00,372 --> 00:00:02,161
- [Instructor] Well, that's
it then for another course

2
00:00:02,161 --> 00:00:05,827
and thanks for joining me
in this exploration of how

3
00:00:05,827 --> 00:00:09,432
Docker can be used to deploy
multi-container systems

4
00:00:09,432 --> 00:00:11,643
on real trusted hardware.

5
00:00:11,643 --> 00:00:14,351
Compared with the massive
amounts of work that we did

6
00:00:14,351 --> 00:00:18,630
on our previous deploying
Microservices course

7
00:00:18,630 --> 00:00:22,797
where we had to do so much
work to manage a set of EC2

8
00:00:23,764 --> 00:00:27,187
instances, I think
working with Docker Swarm

9
00:00:27,187 --> 00:00:30,456
is wonderful and I hope
you're going to find it useful

10
00:00:30,456 --> 00:00:33,182
on some real deployments.

11
00:00:33,182 --> 00:00:36,311
But don't forget Swarm and
Docker aren't just used

12
00:00:36,311 --> 00:00:39,067
in Microservice architectures.

13
00:00:39,067 --> 00:00:41,503
That's just one working example that

14
00:00:41,503 --> 00:00:43,910
we've used for the course.

15
00:00:43,910 --> 00:00:47,131
You can use it in any environment you like

16
00:00:47,131 --> 00:00:50,366
and I've even seen it used
in a clustered raspberry pie

17
00:00:50,366 --> 00:00:53,199
system which was very cute indeed.

18
00:00:54,165 --> 00:00:57,847
Microservices are all very
well but there is a lot of hype

19
00:00:57,847 --> 00:01:00,862
about them and I don't want
Virtual Pair Programmes

20
00:01:00,862 --> 00:01:04,974
to lose our focus, which
is on the wider Java

21
00:01:04,974 --> 00:01:07,391
and JVM full stack ecosystem.

22
00:01:08,848 --> 00:01:10,435
There are lots of different methods

23
00:01:10,435 --> 00:01:12,355
of deploying live systems.

24
00:01:12,355 --> 00:01:14,835
Microservices is one of them but there are

25
00:01:14,835 --> 00:01:16,455
a lot more out there.

26
00:01:16,455 --> 00:01:19,593
I missed the chance on this
module to cover Amazon's

27
00:01:19,593 --> 00:01:23,814
managed container service,
which is called ECS.

28
00:01:23,814 --> 00:01:27,702
I'll be mopping that up with
a hopefully short module

29
00:01:27,702 --> 00:01:29,594
in the future.

30
00:01:29,594 --> 00:01:31,569
I know some of you have
been asking for it,

31
00:01:31,569 --> 00:01:34,764
it just fell off the schedule
here and I didn't want

32
00:01:34,764 --> 00:01:37,085
to delay the release of this course.

33
00:01:37,085 --> 00:01:39,140
So do keep an eye out for that.

34
00:01:39,140 --> 00:01:43,418
I'm not a big user of ECS,
I like working with Docker

35
00:01:43,418 --> 00:01:46,648
directly so it will be a very light touch

36
00:01:46,648 --> 00:01:48,481
for me on that course.

37
00:01:49,400 --> 00:01:52,121
The only problem I foresee
with Docker is because it's

38
00:01:52,121 --> 00:01:56,274
moving so fast, they're
constantly adding new features

39
00:01:56,274 --> 00:02:00,295
so I hope what you've seen
here isn't going to go out

40
00:02:00,295 --> 00:02:02,099
of date too quickly.

41
00:02:02,099 --> 00:02:05,245
When I first designed
our Microservices course,

42
00:02:05,245 --> 00:02:09,370
I needed Eureka and
Ribbon because support for

43
00:02:09,370 --> 00:02:12,590
service discovery just
wasn't present in Docker.

44
00:02:12,590 --> 00:02:16,579
I would have needed to get
some complex orchestration

45
00:02:16,579 --> 00:02:20,521
system like Kubernetes
to get service discovery,

46
00:02:20,521 --> 00:02:24,422
but now, as you've seen,
Docker has added some

47
00:02:24,422 --> 00:02:27,826
great features on their
distributed DNS service

48
00:02:27,826 --> 00:02:30,159
using their overlay network.

49
00:02:31,073 --> 00:02:35,981
That routing or routing
mesh and round robin DNS.

50
00:02:35,981 --> 00:02:38,967
Which means that potentially
you could run and orchestrate

51
00:02:38,967 --> 00:02:42,663
a complete architecture
without necessarily needing

52
00:02:42,663 --> 00:02:47,346
fancy orchestration tools
but I am definitely planning

53
00:02:47,346 --> 00:02:50,448
on doing a course on Kubernetes.

54
00:02:50,448 --> 00:02:54,356
So that's a layer of more
sophisticated orchestration

55
00:02:54,356 --> 00:02:57,150
services on top of Docker.

56
00:02:57,150 --> 00:02:59,420
I think it came originally from Google

57
00:02:59,420 --> 00:03:01,818
but I won't be recording
that course quickly because

58
00:03:01,818 --> 00:03:05,129
I have perhaps been doing too much on

59
00:03:05,129 --> 00:03:07,344
the DevOps side of things.

60
00:03:07,344 --> 00:03:11,544
My next full course is going
to be back on the developer

61
00:03:11,544 --> 00:03:13,411
side of things.

62
00:03:13,411 --> 00:03:18,025
But Kubernetes, I will do,
hopefully in late 2017.

63
00:03:18,025 --> 00:03:21,870
My worry there is that
quickly Docker is integrating

64
00:03:21,870 --> 00:03:25,505
features right into their
core that might even make

65
00:03:25,505 --> 00:03:28,898
full orchestrated systems
redundant in the future.

66
00:03:28,898 --> 00:03:31,899
So I'll be keeping an eye
on the progress of that

67
00:03:31,899 --> 00:03:33,410
in the industry.

68
00:03:33,410 --> 00:03:36,620
So as always, thanks for
watching, it's thanks to you

69
00:03:36,620 --> 00:03:39,830
our subscribers and customers
of Virtual Pair Programmes

70
00:03:39,830 --> 00:03:43,840
that keeps us going and that
enables us to keep releasing

71
00:03:43,840 --> 00:03:45,160
new material.

72
00:03:45,160 --> 00:03:49,014
I owe you a great big thanks
so from me, Rich Chestwood,

73
00:03:49,014 --> 00:03:50,979
and all the Virtual Pair Programmers,

74
00:03:50,979 --> 00:03:54,896
we'll see you on yet
another course very soon.

